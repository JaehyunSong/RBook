[["iteration.html", "24. 反復処理 24.1 概要 24.2 *apply()関数群とmap_*()関数群 24.3 引数が2つ以上の場合 24.4 データフレームと{purrr} 24.5 モデルの反復推定", " 24. 反復処理 24.1 概要 第24.2章: *apply()関数群とmap_*()関数群 24.2 *apply()関数群とmap_*()関数群 まず、我らの盟友、{tidyverse}を読み込んでおきましょう。 library(tidyverse) それでは、*apply()関数群とmap_*()関数群の動きとその仕組について調べてみましょう。まず、実習用データとして長さ5のnumericベクトルnum_vecを用意します。 num_vec &lt;- c(3, 2, 5, 4, 7) このnum_vecの個々の要素に2を足す場合はどうすれば良いでしょうか。Rはベクトル単位での演算が行われるため、num_vec + 2だけで十分です。+の右側にある2は長さ1のベクトルですが、num_vecの長さに合わせてリサイクルされます（第10.2章を参照）。 num_vec + 2 ## [1] 5 4 7 6 9 賢明なRユーザーなら上のコードが正解でしょう。しかし、これからの練習のために+を使わずに、for()文を使用してみましょう（第11.3章を参照）。 for (i in num_vec) { print(i + 2) } ## [1] 5 ## [1] 4 ## [1] 7 ## [1] 6 ## [1] 9 実はこれと同じ役割をする関数がRには内蔵されており、それがlapply()関数です。 lapply(オブジェクト名, 関数名, 関数の引数) 以下のコードからも確認出来ますが、足し算を意味する+も関数です。ただし、演算子を関数として使う場合は演算子を`で囲む必要があり、+だと`+`と表記します。 `+`(num_vec, 2) ## [1] 5 4 7 6 9 したがって、lapply()関数を使用してnum_vecの全要素に2を足す場合、以下のようなコードとなります。 lapply(num_vec, `+`, 2) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] 4 ## ## [[3]] ## [1] 7 ## ## [[4]] ## [1] 6 ## ## [[5]] ## [1] 9 これと同じ動きをする関数が{purrr}パッケージのmap()です。{purrr}は{tidyverse}を読み込むと自動的に読み込まれます。 map(num_vec, `+`, 2) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] 4 ## ## [[3]] ## [1] 7 ## ## [[4]] ## [1] 6 ## ## [[5]] ## [1] 9 ただし、lapply()とmap()の場合、戻り値はリスト型となります。もし、ベクトル型の戻り値が必要な場合は更にunlist()関数を使うか、sapply()を使います。 # unlist()を利用し、リストを解除する lapply(num_vec, `+`, 2) %&gt;% unlist() ## [1] 5 4 7 6 9 # sapply()を利用すると戻り値はベクトルとなる sapply(num_vec, `+`, 2) ## [1] 5 4 7 6 9 map()関数ならunlist()でも良いですが、sapply()と同じ動きをするmap_dbl()があります。これは戻り値がdoubleのnumericベクトルになるmap()関数です。 # map_dbl()を利用するとnumeric (double)のベクトルが返される map_dbl(num_vec, `+`, 2) ## [1] 5 4 7 6 9 もし、2を足すだけでなく、更に3で割るためにはどうすれば良いでしょうか。まず考えられるのは更にsapply()やmap_dblを使うことです。 map_dbl(num_vec, `+`, 2) %&gt;% map_dbl(`/`, 3) ## [1] 1.666667 1.333333 2.333333 2.000000 3.000000 もう一つの方法はsapply()やmap_dbl()の第二引数に直接関数を指定する方法です。 sapply(num_vec, function(x){(x + 2) / 3}) ## [1] 1.666667 1.333333 2.333333 2.000000 3.000000 map_dbl(num_vec, function(x){(x + 2) / 3}) ## [1] 1.666667 1.333333 2.333333 2.000000 3.000000 上のコードだと、num_vecの要素が第二引数で指定した関数の引数（x）として用いられます。関数が長くなる場合は、sapply()やmap()の外側に関数を予め指定して置くことも可能です。 add_two_divide_three &lt;- function(x){ (x + 2) / 3 } sapply(num_vec, add_two_divide_three) ## [1] 1.666667 1.333333 2.333333 2.000000 3.000000 map_dbl(num_vec, add_two_divide_three) ## [1] 1.666667 1.333333 2.333333 2.000000 3.000000 ここまでの例だとsapply()とmap_dbl()はほぼ同じ関数です。なぜわざわざ{purrr}パッケージを読み込んでまでmap_dbl()関数を使う必要があるでしょうか。それはmap_dbl()の内部にはラムダ（lambda）式、あるいは無名関数（anonymous function）と呼ばれるものが使用可能だからです。ラムダ式は第14.1章でも説明しましたが、もう一回解説します。ラムダ式は使い捨ての関数で、map_dbl()内部での処理が終わるとメモリ上から削除される関数です。使い捨てですので、関数の名前（オブジェクト名）も与えられておりません。 このラムダ式の作り方ですが、~で始まり、引数の部分には.xが入ります1。したがって、~(.x + 2) / 2はfunction(x){(x + 2) / 3}の簡略したものとなります。ただし、後者だと無名関数の引数に該当するxをyやjなどに書き換えても問題ありませんが、ラムダ式では必ず.xと表記する必要があります。 map_dbl(num_vec, ~(.x + 2) / 3) ## [1] 1.666667 1.333333 2.333333 2.000000 3.000000 かなり短めなコードで「num_vecの全要素に2を足して3で割る」処理ができました。一方、sapply()やlapply()のような*apply()関数群だとラムダ式を使うことはできません。現在のメモリ上にある関数のみしか使うことができません。 sapply(num_vec, ~(.x + 2) / 3) ## Error in match.fun(FUN): &#39;~(.x + 2)/3&#39; is not a function, character or symbol これまでの例は正しいコードではありますが、良いコードとは言えないでしょう。なぜならnum_vec + 2という最適解が存在するからです。*apply()とmap_*()はより複雑な処理に特化しています。たとえば、リスト型データの処理です。以下の例を考えてみましょう。 num_list &lt;- list(List1 = c(1, 3, 5, 7, 9), List2 = c(2, 4, 6, 8, 10, 13, 3), List3 = c(3, 2, NA, 5, 8, 9, 1)) num_listは3つのnumeric型ベクトルで構成されたリスト型オブジェクトです。それぞれのベクトルの平均値を求めてみましょう。これを普通にmean()関数のみで済まそうとすると、リストからベクトルを一つずつ抽出し、3回のmean()関数を使用する必要があります、 mean(num_list[[&quot;List1&quot;]], na.rm = TRUE) ## [1] 5 mean(num_list[[&quot;List2&quot;]], na.rm = TRUE) ## [1] 6.571429 mean(num_list[[&quot;List3&quot;]], na.rm = TRUE) ## [1] 4.666667 もしリストの長さが大きくなると、以下のようにfor()文の方が効率的でしょう。 for (i in names(num_list)) { print(mean(num_list[[i]], na.rm = TRUE)) } ## [1] 5 ## [1] 6.571429 ## [1] 4.666667 計算結果をベクトルとして出力/保存する場合は予めベクトルを用意しておく必要があります。 # num_listの長さと同じ長さの空ベクトルを生成 Return_vec &lt;- rep(NA, length(num_list)) for (i in 1:length(num_list)) { Return_vec[i] &lt;- mean(num_list[[i]], na.rm = TRUE) } Return_vec ## [1] 5.000000 6.571429 4.666667 以上の例はsapply()、またはmap_dbl関数を使うとより短くすることができます。 sapply(num_list, mean, na.rm = TRUE) ## List1 List2 List3 ## 5.000000 6.571429 4.666667 map_dbl(num_list, mean, na.rm = TRUE) ## List1 List2 List3 ## 5.000000 6.571429 4.666667 *apply()もmap_*()も、それぞれの要素に対して同じ処理を行うことを得意とする関数です。他の応用としては、各ベクトルからn番目の要素を抽出することもできます。ベクトルからn番目の要素を抽出するにはベクトル名[n]と入力しますが、実はこの[も関数です。関数として使う場合は+と同様、`[`と表記します。num_list内の3つのベクトルから3番目の要素を抽出してみましょう2。 map_dbl(num_list, `[`, 3) ## List1 List2 List3 ## 5 6 NA ここまで来たらmap_*()関数群の仕組みについてイメージが出来たかと思います。map_*()関数群の動きは図24.1のように表すことができます。第一引数はデータであり、そのデータの各要素に対して第二引数で指定された関数を適用します。この関数に必要な（データを除く）引数は第三引数以降に指定します。この関数部（第二引数）はRやパッケージなどで予め提供されている関数でも、内部に直接無名関数を作成することもできます。この無名関数はfunction(x){}のような従来の書き方も可能ですが、map_*()関数群の場合~で始まるラムダ式を使うことも可能です。 図 24.1: map_*()関数群のイメージ map()の場合、返り値はリストとなり、map_dbl()の返り値はnumeric (double)型のベクトルとなります。他にもmap_*()関数群にはmap_int()、map_lgl()、map_chr()、map_df()などがあり、それぞれ返り値のデータ型/データ構造を表しています。例えば、返り値がcharacter型のベクトルであれば、map_chr()を使います。c(1, 2, 3, 4, 5)のベクトルの各要素の前に\"ID: \"を付ける例だと以下のように書きます。 # 以下のコードでもOK # map_chr(c(1, 2, 3, 4, 5), ~paste0(&quot;ID: &quot;, .x)) c(1, 2, 3, 4, 5) %&gt;% map_chr(~paste0(&quot;ID: &quot;, .x)) ## [1] &quot;ID: 1&quot; &quot;ID: 2&quot; &quot;ID: 3&quot; &quot;ID: 4&quot; &quot;ID: 5&quot; 24.3 引数が2つ以上の場合 {purrr}を使った本格的な例を紹介する前に、引数が2つ以上の場合を考えたいと思います。まずは引数が2つの場合です。この場合、map2_*()関数群を使用します。例えば、num_vecに長さ5のnumeric型ベクトルnum_vec2をかける例を考えてみましょう。 この場合、データとしてnum_vecとnum_vec2が必要となり、ラムダ式にも2つの引数が必要です。まず、num_vec2を用意します。 num_vec2 &lt;- c(1, 0, 1, 0, 1) 続いてmap2_dbl()関数を使用しnum_vecとnum_vec2の掛け算を行います。map2_*()の使い方はmap_*()とほぼ同様です。 map2_dbl(データ1, データ2, 関数 or ラムダ式, 追加の引数) map_*()との違いとしては、(1) データが2つである、(2) 関数、またはラムダ式に2つの引数が必要である点です。この2点目の引数ですが、データ2は.yと表記します。したがって、データ1とデータ2の掛け算を意味するラムダ式は~.x * .yです。 map2_dbl(num_vec, num_vec2, ~.x * .y) ## [1] 3 0 5 0 7 num_vecとnum_vec2が必ずしも同じデータ構造、データ型、同じ長さである必要がありません。数字の前に\"ID:\"を付ける先ほどの例をmap2_chr()で書いてみましょう。 map2_chr(num_vec, &quot;ID:&quot;, ~paste0(.y, .x)) ## [1] &quot;ID:3&quot; &quot;ID:2&quot; &quot;ID:5&quot; &quot;ID:4&quot; &quot;ID:7&quot; それでは3つ以上の引数について考えてみましょう。たとえば、num_vecの前に\"ID\"を付けるとします。そして\"ID\"とnum_vecの間に\":\"を入れたい場合はどうすればい良いでしょう。むろん、賢い解決方法は単純にpaste()関数を使うだけです。 paste(&quot;ID&quot;, num_vec, sep = &quot;:&quot;) ## [1] &quot;ID:3&quot; &quot;ID:2&quot; &quot;ID:5&quot; &quot;ID:4&quot; &quot;ID:7&quot; この場合、引数は3つです3。この場合の書き方はどうなるでしょうか。map2_*()はデータを2つまでしか指定できません。3つ目以降は関数/ラムダ式の後ろに書くこととなります。ただし、関数/ラムダ式の後ろに指定される引数は長さ1のベクトルでなければなりません。また、ラムダ式内の引数は.xと.yでなく、..1、..2、..3、…となります。 今回の例だとmap2_chr()内にnum_vecがデータ1、\"ID\"がデータ2です。そして、期待される結果は、「“ID” + sepの実引数 + num_vecの値」となります。したがって、ラムダ式はpaste(..2, ..1, sep = ..3)となります。 map2_chr(num_vec, &quot;ID&quot;, ~paste(..2, ..1, sep = ..3), &quot;-&quot;) ## [1] &quot;ID-3&quot; &quot;ID-2&quot; &quot;ID-5&quot; &quot;ID-4&quot; &quot;ID-7&quot; データ2である\"ID\"は長さ1のcharacter型ベクトルであるため、以下のようにmap_chr()を使うことも可能です。 # データ2も長さ1なのでmap_chr()もOK map_chr(num_vec, ~paste(..2, ..1, sep = ..3), &quot;ID&quot;, &quot;-&quot;) ## [1] &quot;ID-3&quot; &quot;ID-2&quot; &quot;ID-5&quot; &quot;ID-4&quot; &quot;ID-7&quot; それではデータを3つ以上使うにはどうすれば良いでしょうか。そこで登場するのがpmap_*()関数です。以下の3つのベクトルを利用し、「名前:数学成績」を出力してみましょう。ただし、不正行為がある場合（cheat_vecの値が1）は成績が0点になるようにしましょう。 name_vec &lt;- c(&quot;Hadley&quot;, &quot;Song&quot;, &quot;Yanai&quot;) math_vec &lt;- c(70, 55, 80) cheat_vec &lt;- c(0, 1, 0) 賢い解決法は普通にpaste0()関数を使う方法です。 paste0(name_vec, &quot;:&quot;, math_vec * (1 - cheat_vec)) ## [1] &quot;Hadley:70&quot; &quot;Song:0&quot; &quot;Yanai:80&quot; 今回はあえてpmap_*()関数を使ってみましょう。pmap_*()の場合、第一引数であるデータはリスト型で渡す必要があります。したがって、3つのベクトルをlist()関数を用いてリスト化します。第二引数には既存の関数やラムダ式を入力し、各引数は..1、..2、…といった形で表記します。 pmap_chr(list(name_vec, math_vec, cheat_vec), ~paste0(..1, &quot;:&quot;, ..2 * (1 - ..3))) ## [1] &quot;Hadley:70&quot; &quot;Song:0&quot; &quot;Yanai:80&quot; 第一引数はデータであるため、まずリストを作成し、パイプ演算子（%&gt;%）でpmap_*()に渡すことも可能です。 list(name_vec, math_vec, cheat_vec) %&gt;% pmap_chr(~paste0(..1, &quot;:&quot;, ..2 * (1 - ..3))) ## [1] &quot;Hadley:70&quot; &quot;Song:0&quot; &quot;Yanai:80&quot; 24.4 データフレームと{purrr} map_*()関数のデータとしてデータフレームを渡すことも可能です。ここでは5行3列のデータフレームを作成してみましょう。 Dummy_df &lt;- data.frame(X = seq(1, 5, by = 1), Y = seq(10, 50, by = 10), Z = seq(2, 10, by = 2)) 各行のX、Y、Zの合計を計算するには{dplyr}のrowwise()とmutate()を組み合わせることで計算出来ることを第14.4章で紹介しました。 Dummy_df %&gt;% rowwise() %&gt;% mutate(Sum = sum(X, Y, Z)) %&gt;% # rowwise()は1行を1グループとする関数であるため、最後にグループ化を解除 ungroup() ## # A tibble: 5 x 4 ## X Y Z Sum ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 10 2 13 ## 2 2 20 4 26 ## 3 3 30 6 39 ## 4 4 40 8 52 ## 5 5 50 10 65 それでは各列の平均値を計算するにはどうすれば良いでしょうか。ここではR内蔵関数であるcolMeans()を使わないことにしましょう。 colMeans(Dummy_df) ## X Y Z ## 3 30 6 まず、mean(Dummy_df$X)を3回実行する方法や、{dplyr}のsummarise()関数を使う方法があります。 Dummy_df %&gt;% summarise(X = mean(X), Y = mean(Y), Z = mean(Z)) ## X Y Z ## 1 3 30 6 実はこの操作、map_dbl()関数を使えば、より簡単です。 map_dbl(Dummy_df, mean) ## X Y Z ## 3 30 6 map_dbl()はnumeric (double) 型ベクトルを返しますが、データフレーム（具体的にはtibble）に返すならmap_df()を使います。 map_df(Dummy_df, mean) ## # A tibble: 1 x 3 ## X Y Z ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 30 6 なぜこれが出来るでしょうか。これを理解するためにはデータフレームとtibbleが本質的にはリスト型と同じであることを理解する必要があります。たとえば、以下のようなリストについて考えてみましょう。 Dummy_list &lt;- list(X = seq(1, 5, by = 1), Y = seq(10, 50, by = 10), Z = seq(2, 10, by = 2)) Dummy_list ## $X ## [1] 1 2 3 4 5 ## ## $Y ## [1] 10 20 30 40 50 ## ## $Z ## [1] 2 4 6 8 10 このDummy_listをas.data.frame()関数を使用して強制的にデータフレームに変換してみましょう。 as.data.frame(Dummy_list) ## X Y Z ## 1 1 10 2 ## 2 2 20 4 ## 3 3 30 6 ## 4 4 40 8 ## 5 5 50 10 Dummy_dfと同じものが出てきました。逆にDummy_dfを、as.list()を使用してリストに変換するとDummy_listと同じものが返されます。 as.list(Dummy_df) ## $X ## [1] 1 2 3 4 5 ## ## $Y ## [1] 10 20 30 40 50 ## ## $Z ## [1] 2 4 6 8 10 ここまで理解できれば、map_*()関数のデータがデータフレームの場合、内部ではリストとして扱われることが分かるでしょう。実際、Dummy_listをデータとして入れてもDummy_dfを入れた結果と同じものが得られます。 map_df(Dummy_list, mean) ## # A tibble: 1 x 3 ## X Y Z ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3 30 6 24.4.1 tibbleの話 ここまで「データフレーム」と「tibble」を区別せずに説明してきましたが、これからの話しではこの2つを区別する必要があります。tibbleは{tidyverse}のコアパッケージの一つである{tibble}が提供するデータ構造であり、データフレームの上位互換です。tibbleもデータフレーム同様、本質的にはリストですが、リストの構造をより的確に表すことが出来ます。 データフレームをリストとして考える場合、リストの各要素は必ずベクトルである必要があります。たとえば、Dummy_listには3つの要素があり、それぞれ長さ5のベクトルです。一方、リストの中にはリストを入れることも出来ます。たとえば、以下のようなDummy_list2について考えてみましょう。 Dummy_list2 &lt;- list(ID = 1:3, Data = list(Dummy_df, Dummy_df, Dummy_df)) Dummy_list2 ## $ID ## [1] 1 2 3 ## ## $Data ## $Data[[1]] ## X Y Z ## 1 1 10 2 ## 2 2 20 4 ## 3 3 30 6 ## 4 4 40 8 ## 5 5 50 10 ## ## $Data[[2]] ## X Y Z ## 1 1 10 2 ## 2 2 20 4 ## 3 3 30 6 ## 4 4 40 8 ## 5 5 50 10 ## ## $Data[[3]] ## X Y Z ## 1 1 10 2 ## 2 2 20 4 ## 3 3 30 6 ## 4 4 40 8 ## 5 5 50 10 Dummy_list2には2つの要素があり、最初の要素は長さ3のベクトル、2つ目の要素は長さ3のリストです。2つ目の要素がベクトルでないため、Dummy_list2をデータフレームに変換することはできません。 Dummy_df2 &lt;- as.data.frame(Dummy_list2) ## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 3, 5 一方、as_tibble()を使用してtibble型に変換することは可能です。 Dummy_tibble &lt;- as_tibble(Dummy_list2) Dummy_tibble ## # A tibble: 3 x 2 ## ID Data ## &lt;int&gt; &lt;list&gt; ## 1 1 &lt;df[,3] [5 × 3]&gt; ## 2 2 &lt;df[,3] [5 × 3]&gt; ## 3 3 &lt;df[,3] [5 × 3]&gt; 2列目の各セルには5行3列のデータフレーム（df）が格納されていることが分かります。たとえば、Dummy_tibbleのData列を抽出してみましょう。 Dummy_tibble$Data ## [[1]] ## X Y Z ## 1 1 10 2 ## 2 2 20 4 ## 3 3 30 6 ## 4 4 40 8 ## 5 5 50 10 ## ## [[2]] ## X Y Z ## 1 1 10 2 ## 2 2 20 4 ## 3 3 30 6 ## 4 4 40 8 ## 5 5 50 10 ## ## [[3]] ## X Y Z ## 1 1 10 2 ## 2 2 20 4 ## 3 3 30 6 ## 4 4 40 8 ## 5 5 50 10 長さ3のリスト出力されます。続いて、Dummy_tibble$Dataの2番目のセルを抽出してみましょう。 Dummy_tibble$Data[2] ## [[1]] ## X Y Z ## 1 1 10 2 ## 2 2 20 4 ## 3 3 30 6 ## 4 4 40 8 ## 5 5 50 10 データフレームが出力されました。簡単にまとめるとtibbleはデータフレームの中にデータフレームを入れることが出来るデータ構造です。むろん、これまでの通り、データフレームのように使うことも可能です4。これがtibbleの強みでもあり、{purrr}との相性も非常に高いです。たとえば、Data列をmap()関数のデータとして渡せば、複数のデータセットに対して同じモデルの推定が出来るようになります。以下ではその例を紹介します。 24.5 モデルの反復推定 Country_df &lt;- read_csv(&quot;Data/Countries.csv&quot;) 24.5.1 サンプルの分割とモデル推定（split()利用） Split_Data &lt;- split(Country_df, Country_df$Continent) サンプルが分割されたSplit_Dataのデータ構造はリスト型です。 class(Split_Data) ## [1] &quot;list&quot; 中身を見るとリストの各要素としてtibble（データフレーム）が格納されています。リストの中にはあらゆるデータ型、データ構造を入れることができることが分かります。 Split_Data ## $Africa ## # A tibble: 54 x 18 ## Country Population Area GDP PPP GDP_per_capita PPP_per_capita G7 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Algeria 43851044 2.38e6 1.70e5 4.97e5 3876. 11324. 0 ## 2 Angola 32866272 1.25e6 9.46e4 2.19e5 2879. 6649. 0 ## 3 Benin 12123200 1.13e5 1.44e4 3.72e4 1187. 3067. 0 ## 4 Botswa… 2351627 5.67e5 1.83e4 4.07e4 7799. 17311. 0 ## 5 Burkin… 20903273 2.74e5 1.57e4 3.76e4 753. 1800. 0 ## 6 Burundi 11890784 2.57e4 3.01e3 8.72e3 253. 733. 0 ## 7 Cabo V… 555987 4.03e3 1.98e3 3.84e3 3565. 6913. 0 ## 8 Camero… 26545863 4.73e5 3.88e4 9.31e4 1460. 3506. 0 ## 9 Centra… 4829767 6.23e5 2.22e3 4.46e3 460. 924. 0 ## 10 Chad 16425864 1.26e6 1.13e4 2.51e4 689. 1525. 0 ## # … with 44 more rows, and 10 more variables: G20 &lt;dbl&gt;, OECD &lt;dbl&gt;, ## # HDI_2018 &lt;dbl&gt;, Polity_Score &lt;dbl&gt;, Polity_Type &lt;chr&gt;, FH_PR &lt;dbl&gt;, ## # FH_CL &lt;dbl&gt;, FH_Total &lt;dbl&gt;, FH_Status &lt;chr&gt;, Continent &lt;chr&gt; ## ## $America ## # A tibble: 36 x 18 ## Country Population Area GDP PPP GDP_per_capita PPP_per_capita G7 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Antigu… 97929 4.40e2 1.73e3 2.08e3 17643. 21267. 0 ## 2 Argent… 45195774 2.74e6 4.50e5 1.04e6 9949. 22938. 0 ## 3 Bahamas 393244 1.00e4 1.28e4 1.40e4 32618. 35662. 0 ## 4 Barbad… 287375 4.30e2 5.21e3 4.62e3 18126. 16066. 0 ## 5 Belize 397628 2.28e4 1.88e3 2.82e3 4727. 7091. 0 ## 6 Bolivia 11673021 1.08e6 4.09e4 1.01e5 3503. 8623. 0 ## 7 Brazil 212559417 8.36e6 1.84e6 3.13e6 8655. 14734. 0 ## 8 Canada 37742154 9.09e6 1.74e6 1.85e6 46008. 49088. 1 ## 9 Chile 19116201 7.44e5 2.82e5 4.64e5 14769. 24262. 0 ## 10 Colomb… 50882891 1.11e6 3.24e5 7.37e5 6364. 14475. 0 ## # … with 26 more rows, and 10 more variables: G20 &lt;dbl&gt;, OECD &lt;dbl&gt;, ## # HDI_2018 &lt;dbl&gt;, Polity_Score &lt;dbl&gt;, Polity_Type &lt;chr&gt;, FH_PR &lt;dbl&gt;, ## # FH_CL &lt;dbl&gt;, FH_Total &lt;dbl&gt;, FH_Status &lt;chr&gt;, Continent &lt;chr&gt; ## ## $Asia ## # A tibble: 42 x 18 ## Country Population Area GDP PPP GDP_per_capita PPP_per_capita G7 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghan… 38928346 6.53e5 1.91e4 8.27e4 491. 2125. 0 ## 2 Bahrain 1701575 7.60e2 3.86e4 7.42e4 22670. 43624. 0 ## 3 Bangla… 164689383 1.30e5 3.03e5 7.34e5 1837. 4458. 0 ## 4 Bhutan 771608 3.81e4 2.45e3 8.77e3 3171. 11363. 0 ## 5 Brunei 437479 5.27e3 1.35e4 2.65e4 30789. 60656. 0 ## 6 Burma 54409800 6.53e5 7.61e4 2.68e5 1398. 4932. 0 ## 7 Cambod… 16718965 1.77e5 2.71e4 6.93e4 1620. 4142. 0 ## 8 China 1447470092 9.39e6 1.48e7 2.20e7 10199. 15177. 0 ## 9 India 1380004385 2.97e6 2.88e6 9.06e6 2083. 6564. 0 ## 10 Indone… 273523615 1.81e6 1.12e6 3.12e6 4092. 11397. 0 ## # … with 32 more rows, and 10 more variables: G20 &lt;dbl&gt;, OECD &lt;dbl&gt;, ## # HDI_2018 &lt;dbl&gt;, Polity_Score &lt;dbl&gt;, Polity_Type &lt;chr&gt;, FH_PR &lt;dbl&gt;, ## # FH_CL &lt;dbl&gt;, FH_Total &lt;dbl&gt;, FH_Status &lt;chr&gt;, Continent &lt;chr&gt; ## ## $Europe ## # A tibble: 50 x 18 ## Country Population Area GDP PPP GDP_per_capita PPP_per_capita G7 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Albania 2877797 27400 1.53e4 39658. 5309. 13781. 0 ## 2 Andorra 77265 470 3.15e3 NA 40821. NA 0 ## 3 Armenia 2963243 28470 1.37e4 38446. 4614. 12974. 0 ## 4 Austria 9006398 82409 4.46e5 502771. 49555. 55824. 0 ## 5 Azerba… 10139177 82658 4.80e4 144556. 4739. 14257. 0 ## 6 Belarus 9449323 202910 6.31e4 183461. 6676. 19415. 0 ## 7 Belgium 11589623 30280 5.30e5 597433. 45697. 51549. 0 ## 8 Bosnia… 3280819 51000 2.00e4 49733. 6111. 15159. 0 ## 9 Bulgar… 6948445 108560 6.79e4 156693. 9776. 22551. 0 ## 10 Croatia 4105267 55960 6.04e4 114932. 14717. 27996. 0 ## # … with 40 more rows, and 10 more variables: G20 &lt;dbl&gt;, OECD &lt;dbl&gt;, ## # HDI_2018 &lt;dbl&gt;, Polity_Score &lt;dbl&gt;, Polity_Type &lt;chr&gt;, FH_PR &lt;dbl&gt;, ## # FH_CL &lt;dbl&gt;, FH_Total &lt;dbl&gt;, FH_Status &lt;chr&gt;, Continent &lt;chr&gt; ## ## $Oceania ## # A tibble: 4 x 18 ## Country Population Area GDP PPP GDP_per_capita PPP_per_capita G7 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Austra… 25499884 7.68e6 1.39e6 1.28e6 54615. 50001. 0 ## 2 Fiji 896445 1.83e4 5.54e3 1.25e4 6175. 13940. 0 ## 3 New Ze… 4842780 2.64e5 2.07e5 2.04e5 42729. 42178. 0 ## 4 Papua … 8947024 4.53e5 2.50e4 3.73e4 2791. 4171. 0 ## # … with 10 more variables: G20 &lt;dbl&gt;, OECD &lt;dbl&gt;, HDI_2018 &lt;dbl&gt;, ## # Polity_Score &lt;dbl&gt;, Polity_Type &lt;chr&gt;, FH_PR &lt;dbl&gt;, FH_CL &lt;dbl&gt;, ## # FH_Total &lt;dbl&gt;, FH_Status &lt;chr&gt;, Continent &lt;chr&gt; それでは分割された各サンプルに対してPolity_ScoreとFH_Totalの相関係数を計算してみましょう。その前に相関分析の方法について調べてみましょう。Rには相関分析の関数が2つ用意されています。単純に相関係数のみを計算するならcor()、係数の不確実性（標準誤差、信頼区間など）まで計算し、検定を行うならcor.test()を使用します。ここではより汎用性の高いcor.test()の使い方について紹介します。 # 相関分析: 方法1 cor.test(~ 変数名1 + 変数名2, data = データ名) # 相関分析: 方法2 cor.test(データ名$変数名1, データ名$変数名2) それでは全サンプルに対して相関分析をしてみましょう。 Cor_fit1 &lt;- cor.test(~ Polity_Score + FH_Total, data = Country_df) Cor_fit1 ## ## Pearson&#39;s product-moment correlation ## ## data: Polity_Score and FH_Total ## t = 19.494, df = 156, p-value &lt; 2.2e-16 ## alternative hypothesis: true correlation is not equal to 0 ## 95 percent confidence interval: ## 0.7896829 0.8821647 ## sample estimates: ## cor ## 0.8420031 ここから相関係数（0.8420031）のみを抽出するにはどうすれば良いでしょうか。それを確認するためにはCor_fit1というオブジェクトの構造を調べる必要があります。ここではR内蔵関数であるstr()を使って確認してみましょう。 str(Cor_fit1) ## List of 9 ## $ statistic : Named num 19.5 ## ..- attr(*, &quot;names&quot;)= chr &quot;t&quot; ## $ parameter : Named int 156 ## ..- attr(*, &quot;names&quot;)= chr &quot;df&quot; ## $ p.value : num 1.16e-43 ## $ estimate : Named num 0.842 ## ..- attr(*, &quot;names&quot;)= chr &quot;cor&quot; ## $ null.value : Named num 0 ## ..- attr(*, &quot;names&quot;)= chr &quot;correlation&quot; ## $ alternative: chr &quot;two.sided&quot; ## $ method : chr &quot;Pearson&#39;s product-moment correlation&quot; ## $ data.name : chr &quot;Polity_Score and FH_Total&quot; ## $ conf.int : num [1:2] 0.79 0.882 ## ..- attr(*, &quot;conf.level&quot;)= num 0.95 ## - attr(*, &quot;class&quot;)= chr &quot;htest&quot; 相関係数は$estimateで抽出できそうですね。実際にCor_fit1から相関係数のみ抽出してみましょう。 Cor_fit1$estimate ## cor ## 0.8420031 それではmap()関数を利用して分割された各サンプルを対象にPolity_ScoreとFH_Totalの相関係数を計算してみましょう。map()のデータはSplit_Dataとし、関数はラムダ式を書いてみましょう。cor.test()内data引数の実引数は.x、または..1となります。最後にmap_dbl(\"estimate\")を利用し、相関係数を抽出、numeric (double) 型ベクトルとして出力します。 Cor_fit2 &lt;- Split_Data %&gt;% map(~cor.test(~ Polity_Score + FH_Total, data = .x)) map_dbl(Cor_fit2, &quot;estimate&quot;) ## Africa America Asia Europe Oceania ## 0.7612138 0.8356899 0.8338172 0.8419547 0.9960776 map_dbl(Cor_fit2, &quot;p.value&quot;) %&gt;% round(3) ## Africa America Asia Europe Oceania ## 0.000 0.000 0.000 0.000 0.004 24.5.2 サンプルの分割とモデル推定（nest()利用） Nested_Data &lt;- Country_df %&gt;% group_by(Continent) %&gt;% nest() Nested_Data Nested_Data %&gt;% mutate(Cor_test = map(data, ~cor.test(~ Polity_Score + FH_Total, data = .x)), Cor_coef = map(Cor_test, &quot;estimate&quot;)) %&gt;% unnest(cols = Cor_coef) ## # A tibble: 5 x 4 ## # Groups: Continent [5] ## Continent data Cor_test Cor_coef ## &lt;chr&gt; &lt;list&gt; &lt;list&gt; &lt;dbl&gt; ## 1 Asia &lt;tibble [42 × 17]&gt; &lt;htest&gt; 0.834 ## 2 Europe &lt;tibble [50 × 17]&gt; &lt;htest&gt; 0.842 ## 3 Africa &lt;tibble [54 × 17]&gt; &lt;htest&gt; 0.761 ## 4 America &lt;tibble [36 × 17]&gt; &lt;htest&gt; 0.836 ## 5 Oceania &lt;tibble [4 × 17]&gt; &lt;htest&gt; 0.996 Nested_Data %&gt;% mutate(Model = map(data, ~lm(PPP_per_capita ~ FH_Total, data = .x)), Model = map(Model, broom::tidy)) %&gt;% unnest(cols = Model) %&gt;% filter(term == &quot;FH_Total&quot;) %&gt;% select(-c(data, term)) 24.5.3 データの範囲を指定したモデル推定 RDDの例（バンド幅を変えながら推定） 24.5.4 説明・応答変数を指定したモデル推定 バランスチェックの例（応答変数を変えながら推定） 引数が2つなら.xと.yを使用します。もし3つ以上なら..1、..2、..3、…と表記します。↩︎ 実は今回の例のように要素を抽出する場合、`[`すら要りません。map_dbl(num_list, 3)だけで十分です。↩︎ paste()関数はsep =以外はすべて結合の対象となります。引数が4つ以上になることもあります。たとえば、paste(\"We\", \"love\", \"cats!\", sep = \" \")です。↩︎ ただしtibbleはtibble名[3, 2:4] &lt;- c(\"A\", \"B\", \"C\")のような、列をまたがった値の代入は出来ません。これによってtibbleに対応しない関数もまだあります。この場合、as.data.frame()を使って一旦データフレームに変換する必要があります。↩︎ "]]
