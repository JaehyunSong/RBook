[
["factor.html", "12. データハンドリング [基礎編: factor型] 12.1 名目変数を含むグラフを作成する際の注意点 12.2 forcatsパッケージについて 12.3 練習問題", " 12. データハンドリング [基礎編: factor型] 12.1 名目変数を含むグラフを作成する際の注意点 次章では楽しい可視化、つまりグラフの作成について解説します。ただし、その前に、名目変数の扱いについて話したいと思います。横軸、または縦軸が気温、成績、身長のような連続変数ではなく、都道府県や国、企業のような名目変数になる場合があります。たとえば、棒グラフの横軸は図12.1のように、一般的に名目変数になる場合が多いです。 図 12.1: 横軸が名目変数の棒グラフ ここでは横軸の順番に注目してください。京都府、埼玉県、神奈川県、…の順番になっていますね。「この順番で大満足だよ!」という方がいるかも知れませんが、そうでない方もおおいでしょう。普通考えられるものとしては、都道府県コードの順か、縦軸が高い順 (低い順)でしょう。都道府県コードの順だと、埼玉県、千葉県、東京都、神奈川県、京都府、大阪府、兵庫県、奈良県、和歌山県の順番になります。または、縦軸 (口コミ評価の平均値)が高い順なら和歌山県、奈良県、大阪府、…の順番になります。あるいは50音順も考えられるでしょう。アメリカの場合、州を並べる際、アルファベット順で並べます。 自分でこの順番をコントロールするには可視化の前の段階、つまりデータハンドリングの段階で順番を決めなくてはなりません。これを決めておかない場合、Rが勝手に順番を指定します。具体的にはロケール (locale)というパソコン内の空間に文字情報が含まれているわけですが、そこに保存されている文字の順番となります。たとえば、日本語ロケールには「京」が「埼」よりも先に保存されているわけです。 したがって、名目変数がグラフに含まれる場合は、名目変数の表示順番を決める必要があり、そこで必要なのがfactor型です。名目変数がcharacter型の場合、ロケールに保存されている順でソートされますが、factor型の場合、予め指定した順番でソートされます。 たとえば、前章で使用したデータを用いて、都道府県ごとの口コミ評価の平均値を計算し、その結果をScore_dfとして保存します。 # tidyverseパッケージの読み込み library(tidyverse) # データの読み込み df &lt;- read_csv(&quot;Data/Ramen.csv&quot;) Score_df &lt;- df %&gt;% group_by(Pref) %&gt;% summarise(Score = mean(Score, na.rm = TRUE), .groups = &quot;drop&quot;) Score_df ## # A tibble: 9 x 2 ## Pref Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 京都府 3.68 ## 2 埼玉県 3.64 ## 3 神奈川県 3.53 ## 4 千葉県 3.72 ## 5 大阪府 3.77 ## 6 東京都 3.67 ## 7 奈良県 3.85 ## 8 兵庫県 3.54 ## 9 和歌山県 3.97 この時点で勝手にロケール順になります。実際、表示されたScore_dfを見るとPrefの下に`&lt;chr&gt;と表記されており、Prefはcharacter型であることが分かります。これをこのまま棒グラフに出してみましょう。可視化の方法はこれから詳細に解説するので、ここでは結果だけに注目してください。 Score_df %&gt;% ggplot() + geom_bar(aes(x = Pref, y = Score), stat = &quot;identity&quot;) + labs(x = &quot;都府県&quot;, y = &quot;口コミ評価の平均値 (1~5)&quot;) + theme_gray(base_family = &quot;HiraKakuProN-W3&quot;) + theme(text = element_text(size = 12)) 図 12.2: Prefがcharacter型の場合 (1) 横軸の順番があまり直感的ではありませんね。それでは、Score_dfをScoreが高い順にソートし、Score_df2で保存してから、もう一回試してみます。 Score_df2 &lt;- Score_df %&gt;% arrange(desc(Score)) Score_df2 ## # A tibble: 9 x 2 ## Pref Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 和歌山県 3.97 ## 2 奈良県 3.85 ## 3 大阪府 3.77 ## 4 千葉県 3.72 ## 5 京都府 3.68 ## 6 東京都 3.67 ## 7 埼玉県 3.64 ## 8 兵庫県 3.54 ## 9 神奈川県 3.53 ここでもPrefはcharacter型ですが、とりあえず、これで図を出してみます。 Score_df2 %&gt;% ggplot() + geom_bar(aes(x = Pref, y = Score), stat = &quot;identity&quot;) + labs(x = &quot;都府県&quot;, y = &quot;口コミ評価の平均値 (1~5)&quot;) + theme_gray(base_family = &quot;HiraKakuProN-W3&quot;) + theme(text = element_text(size = 12)) 図 12.3: Prefがcharacter型の場合 (2) 結果は全く変わっておりません。それでは、Score_dfのPref列をfactor型に変換し、順番は口コミ評価の平均値が高い順番にしてみましょう。結果はScore_df_f1という名で保存します。 Score_df_f1 &lt;- Score_df %&gt;% mutate(Pref = factor(Pref, levels = c(&quot;和歌山県&quot;, &quot;奈良県&quot;, &quot;大阪府&quot;, &quot;千葉県&quot;, &quot;京都府&quot;, &quot;東京都&quot;, &quot;埼玉県&quot;, &quot;兵庫県&quot;, &quot;神奈川県&quot;))) Score_df_f1 ## # A tibble: 9 x 2 ## Pref Score ## &lt;fct&gt; &lt;dbl&gt; ## 1 京都府 3.68 ## 2 埼玉県 3.64 ## 3 神奈川県 3.53 ## 4 千葉県 3.72 ## 5 大阪府 3.77 ## 6 東京都 3.67 ## 7 奈良県 3.85 ## 8 兵庫県 3.54 ## 9 和歌山県 3.97 表示される順番はScore_dfとScore_df_f1も同じですが、Prefのデータ型が&lt;fct&gt;、つまりfactor型であることが分かります。実際、Pref列だけ抽出した場合、factor型として、和歌山県から神奈川県の順になっていることが確認できます。 Score_df_f1$Pref ## [1] 京都府 埼玉県 神奈川県 千葉県 大阪府 東京都 奈良県 兵庫県 和歌山県 ## Levels: 和歌山県 奈良県 大阪府 千葉県 京都府 東京都 埼玉県 兵庫県 神奈川県 このScore_df_f1データを使って、図12.2と全く同じコードを実行した結果が図12.4です。 図 12.4: Prefがfactor型の場合 (1) これまでの話をまとめるの以下の2点が分かります。 変数がcharacter型である場合、自動的にロケール順でソートされる。 変数がfactor型である場合、データ内の順番やロケール順と関係なく、指定されたレベル (水準)の順でソートされる。 とくに2番目の点についてですが、これは必ずしも順序付きfactorである必要はありません。順序付きfactor型でなくても、factor()内で指定した順にソートされます。むろん、順序付きfactor型なら指定された順序でソートされます。 これからはfactor型変換の際に便利な関数をいくつか紹介しますが、その前に数値として表現された名目変数について話します。たとえば、Score_df_f1に関東地域なら1を、その他の地域なら0を付けたKantoという変数があるとします。 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Kanto = ifelse(Pref %in% c(&quot;東京都&quot;, &quot;神奈川県&quot;, &quot;千葉県&quot;, &quot;埼玉県&quot;), 1, 0)) Score_df_f1 ## # A tibble: 9 x 3 ## Pref Score Kanto ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 京都府 3.68 0 ## 2 埼玉県 3.64 1 ## 3 神奈川県 3.53 1 ## 4 千葉県 3.72 1 ## 5 大阪府 3.77 0 ## 6 東京都 3.67 1 ## 7 奈良県 3.85 0 ## 8 兵庫県 3.54 0 ## 9 和歌山県 3.97 0 Kanto変数のデータ型は、&lt;dbl&gt;、つまりnumeric型です。しかし、これは明らかに名目変数ですね。これをこのままKantoを横軸にした図を出すと図12.5のようになります。 図 12.5: Kantoがnumeric型の場合 この場合、図の横軸はKantoの値が小さい順でソートされます。ただし、このような図は非常に見にくいため、1に\"関東\"、0に\"関西\"とラベルを付けたfactor型に変換した方が望ましいです。numeric型をラベル付きのfactor型にするためには、levels引数には元の数値を、labels引数にはそれぞれの数値に対応したラベルを指定します。また、関東の方を先に出したいので、factor()内のlevels引数はc(0, 1)でなく、c(1, 0)にします。 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Kanto = factor(Kanto, levels = c(1, 0), labels = c(&quot;関東&quot;, &quot;その他&quot;))) Score_df_f1 ## # A tibble: 9 x 3 ## Pref Score Kanto ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 京都府 3.68 その他 ## 2 埼玉県 3.64 関東 ## 3 神奈川県 3.53 関東 ## 4 千葉県 3.72 関東 ## 5 大阪府 3.77 その他 ## 6 東京都 3.67 関東 ## 7 奈良県 3.85 その他 ## 8 兵庫県 3.54 その他 ## 9 和歌山県 3.97 その他 Kanto変数がfactor型に変換されたことが分かります。 Score_df_f1$Kanto ## [1] その他 関東 関東 関東 その他 関東 その他 その他 その他 ## Levels: 関東 その他 また、\"関東\"、\"その他\"の順になっていますね。これを図として出力した結果が図12.6です。 図 12.6: Kantoがfactor型の場合 このように数値型名目変数でも、factor化することによって、自由に横軸の順番を変えることができます。それでは、factor化に使える便利な関数をいくつか紹介します。 12.2 forcatsパッケージについて 実はfactor型への変換や、順番に変更などは全てR内蔵のfactor()関数で対応可能ですが、ここではforcatsパッケージが提供しているfct_*()関数を使用します。forcatsパッケージはtidyverseを読み込む際、自動的に読み込まれるため、既にtidyverseを読み込んでいる場合、別途のコードは要りません。 12.2.1 fct_relevel(): 水準の順番を変更する Score_df_f1のf1はScoreが高い順になっています。これを50音順に変更する際、fct_relevel()関数を使います。 # 新しい変数名と元となる変数名が一致すると上書きになる データフレーム名 %&gt;% mutate(新しい変数名 = fct_releve(元となる変数名, &quot;水準1&quot;, &quot;水準2&quot;, &quot;水準3&quot;, ...)) ここでは、Pref変数を再調整したPref2変数を作ってみましょう。 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Pref2 = fct_relevel(Pref, &quot;大阪府&quot;, &quot;神奈川県&quot;, &quot;京都府&quot;, &quot;埼玉県&quot;, &quot;千葉県&quot;, &quot;東京都&quot;, &quot;奈良県&quot;, &quot;兵庫県&quot;, &quot;和歌山県&quot;)) Score_df_f1 ## # A tibble: 9 x 4 ## Pref Score Kanto Pref2 ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 京都府 3.68 その他 京都府 ## 2 埼玉県 3.64 関東 埼玉県 ## 3 神奈川県 3.53 関東 神奈川県 ## 4 千葉県 3.72 関東 千葉県 ## 5 大阪府 3.77 その他 大阪府 ## 6 東京都 3.67 関東 東京都 ## 7 奈良県 3.85 その他 奈良県 ## 8 兵庫県 3.54 その他 兵庫県 ## 9 和歌山県 3.97 その他 和歌山県 一見、PrefとPref2変数は同じように見えますが、水準はどうなっているでしょうか。 levels(Score_df_f1$Pref) # Prefの水準 ## [1] &quot;和歌山県&quot; &quot;奈良県&quot; &quot;大阪府&quot; &quot;千葉県&quot; &quot;京都府&quot; &quot;東京都&quot; &quot;埼玉県&quot; &quot;兵庫県&quot; ## [9] &quot;神奈川県&quot; levels(Score_df_f1$Pref2) # Pref2の水準 ## [1] &quot;大阪府&quot; &quot;神奈川県&quot; &quot;京都府&quot; &quot;埼玉県&quot; &quot;千葉県&quot; &quot;東京都&quot; &quot;奈良県&quot; &quot;兵庫県&quot; ## [9] &quot;和歌山県&quot; 問題なく50音順になっていることが分かります。他にもfct_relevel()には全ての水準名を指定する必要がありません。一部の水準名も可能です。たとえば、「関東が関西の先に来るなんでけしからん！」と思う読者もいるでしょう。この場合、関西の府県名を入れると、指定した水準が最初に位置するようになります。 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Pref3 = fct_relevel(Pref, &quot;京都府&quot;, &quot;大阪府&quot;, &quot;兵庫県&quot;, &quot;奈良県&quot;, &quot;和歌山県&quot;)) levels(Score_df_f1$Pref3) # Pref3の水準 ## [1] &quot;京都府&quot; &quot;大阪府&quot; &quot;兵庫県&quot; &quot;奈良県&quot; &quot;和歌山県&quot; &quot;千葉県&quot; &quot;東京都&quot; &quot;埼玉県&quot; ## [9] &quot;神奈川県&quot; 一部の水準名のみを指定するとその水準が最初に移動されますが、after引数を指定すると、位置を調整することも可能です。after = 2の場合、元となる変数の1、3番目の水準は維持され、3番目以降に指定した水準、それに続いて指定されていない水準の順番になります。Prefは和歌山、奈良、大阪の順ですが、ここで京都と東京を、奈良と大阪の間に移動するなら、 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Pref4 = fct_relevel(Pref, &quot;京都府&quot;, &quot;東京都&quot;, after = 2)) levels(Score_df_f1$Pref4) # Pref4の水準 ## [1] &quot;和歌山県&quot; &quot;奈良県&quot; &quot;京都府&quot; &quot;東京都&quot; &quot;大阪府&quot; &quot;千葉県&quot; &quot;埼玉県&quot; &quot;兵庫県&quot; ## [9] &quot;神奈川県&quot; のように書きます。afterを指定しない場合のデフォルト値は0であるため、最初に移動します。 12.2.2 fct_recode(): 水準のラベルを変更する fct_recode()は水準のラベルを変更する時に使う関数で、以下のように使います。 # 新しい変数名と元となる変数名が一致すると上書きになる データフレーム名 %&gt;% mutate(新しい変数名 = fct_recode(元となる変数名, 新しいラベル1 = &quot;既存のラベル1&quot;, 新しいラベル2 = &quot;既存のラベル2&quot;, 新しいラベル3 = &quot;既存のラベル3&quot;, ...)) 注意点としては新しいラベルは\"で囲まず、既存のラベルは\"で囲む点です。それでは、Prefのラベルをローマ字に変更してみましょう。 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Pref5 = fct_recode(Pref, Saitama = &quot;埼玉県&quot;, Wakayama = &quot;和歌山県&quot;, Kyoto = &quot;京都府&quot;, Osaka = &quot;大阪府&quot;, Tokyo = &quot;東京都&quot;, Nara = &quot;奈良県&quot;, Kanagawa = &quot;神奈川県&quot;, Hyogo = &quot;兵庫県&quot;, Chiba = &quot;千葉県&quot;)) Score_df_f1 ## # A tibble: 9 x 7 ## Pref Score Kanto Pref2 Pref3 Pref4 Pref5 ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 京都府 3.68 その他 京都府 京都府 京都府 Kyoto ## 2 埼玉県 3.64 関東 埼玉県 埼玉県 埼玉県 Saitama ## 3 神奈川県 3.53 関東 神奈川県 神奈川県 神奈川県 Kanagawa ## 4 千葉県 3.72 関東 千葉県 千葉県 千葉県 Chiba ## 5 大阪府 3.77 その他 大阪府 大阪府 大阪府 Osaka ## 6 東京都 3.67 関東 東京都 東京都 東京都 Tokyo ## 7 奈良県 3.85 その他 奈良県 奈良県 奈良県 Nara ## 8 兵庫県 3.54 その他 兵庫県 兵庫県 兵庫県 Hyogo ## 9 和歌山県 3.97 その他 和歌山県 和歌山県 和歌山県 Wakayama fct_recode()の中に指定する水準の順番は無視されます。つまり、水準の順番はそのまま維持されるため、好きな順番で結構です。また、全ての水準を指定せず、一部のみ変更することも可能です。それではPref5の順番がPrefの順番と同じかを確認してみましょう。 levels(Score_df_f1$Pref) # Prefの水準 ## [1] &quot;和歌山県&quot; &quot;奈良県&quot; &quot;大阪府&quot; &quot;千葉県&quot; &quot;京都府&quot; &quot;東京都&quot; &quot;埼玉県&quot; &quot;兵庫県&quot; ## [9] &quot;神奈川県&quot; levels(Score_df_f1$Pref5) # Pref5の水準 ## [1] &quot;Wakayama&quot; &quot;Nara&quot; &quot;Osaka&quot; &quot;Chiba&quot; &quot;Kyoto&quot; &quot;Tokyo&quot; &quot;Saitama&quot; &quot;Hyogo&quot; ## [9] &quot;Kanagawa&quot; 12.2.3 fct_rev(): 水準の順番を反転させる 水準の順番を反転することは非常によくあります。たとえば、グラフの読みやすさのために、左右または上下を反転するケースがあります。既に何回も強調しましたように、名目変数は基本的にfactor型にすべきであり、ここでfct_rev()関数が非常に便利です。たとえば、Pref2の水準は50音順でありますが、これを反転し、Pref6という名の列として追加してみましょう。 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Pref6 = fct_rev(Pref2)) levels(Score_df_f1$Pref6) ## [1] &quot;和歌山県&quot; &quot;兵庫県&quot; &quot;奈良県&quot; &quot;東京都&quot; &quot;千葉県&quot; &quot;埼玉県&quot; &quot;京都府&quot; &quot;神奈川県&quot; ## [9] &quot;大阪府&quot; 関数一つで水準の順番が反転されました。 12.2.4 fct_infreq(): 頻度順に順番を変更する 続いて、水準の順番を頻度順に合わせるfct_infreq()関数です。たとえば、Scoreが欠損でないケースのみで構成されたdf2を考えてみましょう。 df2 &lt;- df %&gt;% filter(!is.na(Score)) そして、都府県ごとのケース数を計算します。 table(df2$Pref) ## ## 京都府 埼玉県 神奈川県 千葉県 大阪府 東京都 奈良県 兵庫県 和歌山県 ## 79 118 219 108 175 298 28 85 24 ここでPrefをfactor化しますが、水準の順番を店舗数が多い方を先にするにはどうすれば良いでしょうか。fct_infreq()関数は指定された変数の各値の個数を計算し、多い順にfactorの水準を調整します。 df2 &lt;- df2 %&gt;% # 多く出現した値順でfactor化する mutate(Pref = fct_infreq(Pref)) levels(df2$Pref) # df2のPref変数の水準を出力 ## [1] &quot;東京都&quot; &quot;神奈川県&quot; &quot;大阪府&quot; &quot;埼玉県&quot; &quot;千葉県&quot; &quot;兵庫県&quot; &quot;京都府&quot; &quot;奈良県&quot; ## [9] &quot;和歌山県&quot; \"東京都\"、\"神奈川県\"、\"大阪府\"、…の順で水準の順番が調整され、これはtable(df$Pref2)の順位とも一致します。 12.2.5 fct_inorder(): データ内の出現順番に順番を変更する 続いて、fct_inorder()ですが、これは意外と頻繁に使われる関数です。たとえば、自分でデータフレームなどを作成し、ケースの順番も綺麗に整えたとします。しかし、既に指摘した通り、データフレーム (または、tibble)での順番とグラフにおける順番は一致するとは限りません。データフレームに格納された順番でfactorの水準が設定できれば非常に便利でしょう。そこで使うのがfct_inorder()です。 たとえば、dfのPrefは\"東京都\"が1000個並び、続いて\"神奈川県\"が1000個、\"千葉県\"が1000個、…の順番で格納されています。この順番をそのままfactorの順番にするには以下のように書きます。 df3 &lt;- df %&gt;% # Pref変数をfactor化し、水準は出現順とする # 変換後の結果はPrefに上書きする mutate(Pref = fct_inorder(Pref)) levels(df3$Pref) ## [1] &quot;東京都&quot; &quot;神奈川県&quot; &quot;千葉県&quot; &quot;埼玉県&quot; &quot;大阪府&quot; &quot;京都府&quot; &quot;兵庫県&quot; &quot;奈良県&quot; ## [9] &quot;和歌山県&quot; 12.2.6 fct_shift(): 水準の順番をずらす 続いて、水準の順番をずらすfct_shift()関数を紹介します。たとえば、「1:そう思う」〜「5:そう思わない」、「9:答えたくない」の6水準で構成された変数があるとします。 df4 &lt;- tibble( ID = 1:10, Q1 = c(1, 5, 3, 2, 9, 2, 4, 9, 5, 1) ) df4 &lt;- df4 %&gt;% mutate(Q1 = factor(Q1, levels = c(1:5, 9), labels = c(&quot;そう思う&quot;, &quot;どちらかと言えばそう思う&quot;, &quot;どちらとも言えない&quot;, &quot;どちらかと言えばそう思わない&quot;, &quot;そう思わない&quot;, &quot;答えたくない&quot;))) df4 ## # A tibble: 10 x 2 ## ID Q1 ## &lt;int&gt; &lt;fct&gt; ## 1 1 そう思う ## 2 2 そう思わない ## 3 3 どちらとも言えない ## 4 4 どちらかと言えばそう思う ## 5 5 答えたくない ## 6 6 どちらかと言えばそう思う ## 7 7 どちらかと言えばそう思わない ## 8 8 答えたくない ## 9 9 そう思わない ## 10 10 そう思う 水準の順番も「そう思う」〜「答えたくない」順で綺麗に整っています。この水準を反転するにはfct_rev()関数が便利です。Q1の水準を反転した変数をQ1_Rという新しい列として追加し、水準を確認してみましょう。 df4 &lt;- df4 %&gt;% mutate(Q1_R = fct_rev(Q1)) df4 ## # A tibble: 10 x 3 ## ID Q1 Q1_R ## &lt;int&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 そう思う そう思う ## 2 2 そう思わない そう思わない ## 3 3 どちらとも言えない どちらとも言えない ## 4 4 どちらかと言えばそう思う どちらかと言えばそう思う ## 5 5 答えたくない 答えたくない ## 6 6 どちらかと言えばそう思う どちらかと言えばそう思う ## 7 7 どちらかと言えばそう思わない どちらかと言えばそう思わない ## 8 8 答えたくない 答えたくない ## 9 9 そう思わない そう思わない ## 10 10 そう思う そう思う levels(df4$Q1_R) ## [1] &quot;答えたくない&quot; &quot;そう思わない&quot; &quot;どちらかと言えばそう思わない&quot; ## [4] &quot;どちらとも言えない&quot; &quot;どちらかと言えばそう思う&quot; &quot;そう思う&quot; 「答えたくない」が最初の順番に来ましてね。できれば、「そう思わない」〜「そう思う」、「答えたくない」の順番にしたいところです。ここで使うのがfct_shift()ですが、書き方がややこしいので、噛み砕いて解説します。 # fct_shift()の使い方 データ名 %&gt;% mutate(新しい変数名 = fct_shift(元の変数名, n = 左方向へずらす個数)) 問題はn =引数ですが、その挙動については以下の表を参照してください。 水準の順番 1 2 3 4 5 6 n = -2 E F A B C D n = -1 F A B C D E n = 0 A B C D E F n = 1 B C D E F A n = 2 C D E F A B 具体的には水準は左方向へn個移動します。元の水準がA, B, C, Dの順で、n = 1の場合、AがDの後ろへ移動し、B, C, Dが前の方へ移動します。逆に右側へ1つ移動したい場合はn = -1のように書きます。今回は最初の水準を最後に移動させたいので、n = 1と指定します。 df4 &lt;- df4 %&gt;% # Q1_Rの水準を左方向で1ずらす mutate(Q1_R = fct_shift(Q1_R, n = 1)) levels(df4$Q1_R) ## [1] &quot;そう思わない&quot; &quot;どちらかと言えばそう思わない&quot; &quot;どちらとも言えない&quot; ## [4] &quot;どちらかと言えばそう思う&quot; &quot;そう思う&quot; &quot;答えたくない&quot; これで水準の反転が完了しました。fct_shift()はこのように世論調査データの処理に便利ですが、他にも曜日の処理に使えます。例えば、1週間の始まりを月曜にするか日曜にするかによって、fct_shift()を使うケースがあります。 12.2.7 fct_shuffle(): 水準の順番をランダム化する あまり使わない機能ですが、水準の順番をランダム化することも可能です。使い方は非常に簡単で、fct_shuffle()に元の変数名を入れるだけです。たとえば、Score_dfのPrefの順番をランダム化し、Pref2として追加します。同じことをもう2回繰り返し、それぞれPref3とPref4という名前で追加してみましょう。 Score_df &lt;- Score_df %&gt;% mutate(Pref2 = fct_shuffle(Pref), Pref3 = fct_shuffle(Pref), Pref4 = fct_shuffle(Pref)) Score_df ## # A tibble: 9 x 5 ## Pref Score Pref2 Pref3 Pref4 ## &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 京都府 3.68 京都府 京都府 京都府 ## 2 埼玉県 3.64 埼玉県 埼玉県 埼玉県 ## 3 神奈川県 3.53 神奈川県 神奈川県 神奈川県 ## 4 千葉県 3.72 千葉県 千葉県 千葉県 ## 5 大阪府 3.77 大阪府 大阪府 大阪府 ## 6 東京都 3.67 東京都 東京都 東京都 ## 7 奈良県 3.85 奈良県 奈良県 奈良県 ## 8 兵庫県 3.54 兵庫県 兵庫県 兵庫県 ## 9 和歌山県 3.97 和歌山県 和歌山県 和歌山県 levels(Score_df$Pref2) ## [1] &quot;和歌山県&quot; &quot;神奈川県&quot; &quot;兵庫県&quot; &quot;奈良県&quot; &quot;大阪府&quot; &quot;京都府&quot; &quot;東京都&quot; &quot;埼玉県&quot; ## [9] &quot;千葉県&quot; levels(Score_df$Pref3) ## [1] &quot;京都府&quot; &quot;和歌山県&quot; &quot;神奈川県&quot; &quot;埼玉県&quot; &quot;大阪府&quot; &quot;奈良県&quot; &quot;千葉県&quot; &quot;東京都&quot; ## [9] &quot;兵庫県&quot; levels(Score_df$Pref4) ## [1] &quot;東京都&quot; &quot;京都府&quot; &quot;兵庫県&quot; &quot;神奈川県&quot; &quot;奈良県&quot; &quot;千葉県&quot; &quot;大阪府&quot; &quot;埼玉県&quot; ## [9] &quot;和歌山県&quot; PrefからPref4まで同じように見えますが、水準の順番が異なります (Prefはcharacter型だから水準がありません)。 12.2.8 fct_reorder(): 別の1変数の値を基準に水準の順番を変更する fct_infreq()は出現頻度順に並び替える関数でしたが、それと似たような関数としてfct_reorder()があります。ただし、これは出現頻度を基準にするのではなく、ある変数の平均値が低い順、中央値が高い順などでソートされます。まずは使い方から確認します。 データ名 %&gt;% mutate(新しい変数名 = fct_reorder(元の変数名, 基準となる変数, 関数, 関数の引数)) 必要な引数が多いですね。解説よりも実際の例を見ながら説明します。今回もPrefをfactor変数にし、Pref_Rという列で格納しますが、平均予算が安い順でfactorの水準を決めたいと思います。 df &lt;- df %&gt;% mutate(Pref_R = fct_reorder(Pref, Budget, mean, na.rm = TRUE)) levels(df$Pref_R) ## [1] &quot;千葉県&quot; &quot;埼玉県&quot; &quot;奈良県&quot; &quot;兵庫県&quot; &quot;大阪府&quot; &quot;神奈川県&quot; &quot;和歌山県&quot; &quot;東京都&quot; ## [9] &quot;京都府&quot; Pref_Rの水準は千葉県、埼玉県、奈良県、…の順ですが、本当にそうでしょうか。group_by()とsummarise()などを使って確認してみましょう。 df %&gt;% group_by(Pref) %&gt;% summarise(Budget = mean(Budget, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(Budget) ## # A tibble: 9 x 2 ## Pref Budget ## &lt;chr&gt; &lt;dbl&gt; ## 1 千葉県 1124. ## 2 埼玉県 1147. ## 3 奈良県 1169. ## 4 兵庫県 1197. ## 5 大阪府 1203. ## 6 神奈川県 1239. ## 7 和歌山県 1252 ## 8 東京都 1283. ## 9 京都府 1399. 問題なくソートされましたね。注意点としてはfct_reorder()内に関数名を書く際、()は不要という点です。関数名の次の引数としてはその関数に別途必要な引数を指定します。引数が省略可能、あるいは不要な関数を使う場合は、省略しても構いませんし、数に制限はありません。 また、低い順ではなく、高い順にすることも可能です。次はScoreの中央値が高い順に水準を設定したPref_R2を作ってみましょう。 df &lt;- df %&gt;% mutate(Pref_R2 = fct_reorder(Pref, Score, median, na.rm = TRUE, .desc = TRUE)) levels(df$Pref_R2) ## [1] &quot;和歌山県&quot; &quot;奈良県&quot; &quot;千葉県&quot; &quot;大阪府&quot; &quot;東京都&quot; &quot;埼玉県&quot; &quot;京都府&quot; &quot;神奈川県&quot; ## [9] &quot;兵庫県&quot; 変わったのはmeanの代わりにmedianを使ったこと、そして.desc引数が追加された点です。fct_reorder()には.desc = FALSEがデフォルトとして指定されており、省略した場合は昇順でfactorの水準が決まります。ここで.desc = TRUEを指定すると、降順となります。実際、Scoreの中央値順になっているかを確認してみましょう。 df %&gt;% group_by(Pref) %&gt;% summarise(Score = median(Score, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(desc(Score)) ## # A tibble: 9 x 2 ## Pref Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 和歌山県 4 ## 2 奈良県 3.88 ## 3 千葉県 3.75 ## 4 大阪府 3.75 ## 5 東京都 3.64 ## 6 埼玉県 3.61 ## 7 京都府 3.5 ## 8 神奈川県 3.5 ## 9 兵庫県 3.5 12.2.9 fct_reorder2(): 別の2変数の値を基準に水準の順番を変更する 12.2.10 fct_collapse(): 水準を統合する 水準数をより水準数に減らすためには、fct_recode()を使います。先ほど、fct_shift()で使ったdf4の例を考えてみましょう。df4のQ1の水準数は6つです。 levels(df4$Q1) ## [1] &quot;そう思う&quot; &quot;どちらかと言えばそう思う&quot; &quot;どちらとも言えない&quot; ## [4] &quot;どちらかと言えばそう思わない&quot; &quot;そう思わない&quot; &quot;答えたくない&quot; これを4つに減らして見ましょう。具体的には「そう思う」と「どちらかと言えばそう思う」を「そう思う」に、「そう思わない」と「どちらかと言えばそう思わない」を「そう思わない」に統合します。これをfct_recode()で処理したのが以下のコードです。 # fct_recode()を使った例 df4 &lt;- df4 %&gt;% mutate(Q1_R2 = fct_recode(Q1, そう思う = &quot;そう思う&quot;, そう思う = &quot;どちらかと言えばそう思う&quot;, どちらとも言えない = &quot;どちらとも言えない&quot;, そう思わない = &quot;どちらかと言えばそう思わない&quot;, そう思わない = &quot;そう思わない&quot;, 答えたくない = &quot;答えたくない&quot;)) df4 ## # A tibble: 10 x 4 ## ID Q1 Q1_R Q1_R2 ## &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 そう思う そう思う そう思う ## 2 2 そう思わない そう思わない そう思わない ## 3 3 どちらとも言えない どちらとも言えない どちらとも言えない ## 4 4 どちらかと言えばそう思う どちらかと言えばそう思う そう思う ## 5 5 答えたくない 答えたくない 答えたくない ## 6 6 どちらかと言えばそう思う どちらかと言えばそう思う そう思う ## 7 7 どちらかと言えばそう思わない どちらかと言えばそう思わない そう思わない ## 8 8 答えたくない 答えたくない 答えたくない ## 9 9 そう思わない そう思わない そう思わない ## 10 10 そう思う そう思う そう思う levels(df4$Q1_R2) ## [1] &quot;そう思う&quot; &quot;どちらとも言えない&quot; &quot;そう思わない&quot; &quot;答えたくない&quot; しかし、水準を統合するに特化したfct_collapse()を使えばより便利です。使い方は、fct_recode()に非常に似ているため省略しますが、=の右側をc()でまとめることが出来ます。 # fct_collapse()を使った例 df4 &lt;- df4 %&gt;% mutate(Q1_R3 = fct_collapse(Q1, そう思う = c(&quot;そう思う&quot;, &quot;どちらかと言えばそう思う&quot;), どちらとも言えない = &quot;どちらとも言えない&quot;, そう思わない = c( &quot;どちらかと言えばそう思わない&quot;, &quot;そう思わない&quot;), 答えたくない = &quot;答えたくない&quot;)) df4 ## # A tibble: 10 x 5 ## ID Q1 Q1_R Q1_R2 Q1_R3 ## &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 そう思う そう思う そう思う そう思う ## 2 2 そう思わない そう思わない そう思わない そう思わない ## 3 3 どちらとも言えない どちらとも言えない どちらとも言えない… どちらとも言えない… ## 4 4 どちらかと言えばそう思う どちらかと言えばそう思う そう思う そう思う ## 5 5 答えたくない 答えたくない 答えたくない 答えたくない ## 6 6 どちらかと言えばそう思う どちらかと言えばそう思う そう思う そう思う ## 7 7 どちらかと言えばそう思わない… どちらかと言えばそう思わない… そう思わない そう思わない ## 8 8 答えたくない 答えたくない 答えたくない 答えたくない ## 9 9 そう思わない そう思わない そう思わない そう思わない ## 10 10 そう思う そう思う そう思う そう思う levels(df4$Q1_R3) ## [1] &quot;そう思う&quot; &quot;どちらとも言えない&quot; &quot;そう思わない&quot; &quot;答えたくない&quot; fct_recode()の結果と同じ結果が得られました。元の水準数や、減らされる水準数などによっては書く手間があまり変わらないので、好きな方を使っても良いでしょう。 12.2.11 fct_drop(): 使われていない水準を除去する 水準としては存在するものの、データとしては存在しないケースもあります。たとえば、以下のコードはPrefをfactor化してからPref == \"奈良県\"のケースを落としたものです。 Score_df_f2 &lt;- df %&gt;% mutate(Pref = fct_inorder(Pref)) %&gt;% filter(Pref != &quot;奈良県&quot;) %&gt;% group_by(Pref) %&gt;% summarise(Score = mean(Score, na.rm = TRUE), .groups = &quot;drop&quot;) Score_df_f2 ## # A tibble: 8 x 2 ## Pref Score ## &lt;fct&gt; &lt;dbl&gt; ## 1 東京都 3.67 ## 2 神奈川県 3.53 ## 3 千葉県 3.72 ## 4 埼玉県 3.64 ## 5 大阪府 3.77 ## 6 京都府 3.68 ## 7 兵庫県 3.54 ## 8 和歌山県 3.97 このように結果としては、奈良県のデータを除外したため奈良県は表示されませんが、Pref変数はどうでしょうか。 levels(Score_df_f2$Pref) ## [1] &quot;東京都&quot; &quot;神奈川県&quot; &quot;千葉県&quot; &quot;埼玉県&quot; &quot;大阪府&quot; &quot;京都府&quot; &quot;兵庫県&quot; &quot;奈良県&quot; ## [9] &quot;和歌山県&quot; このように水準としては残っていることが分かります。使われていない水準が分析や可視化に影響を与えないケースもありますが、与えるケースもあります。これもこれまで勉強してきたfct_*()関数群で対応可能ですが、fct_drop()関数を使えば一発で終わります。実際にやってみましょう。 Score_df_f2 &lt;- Score_df_f2 %&gt;% mutate(Pref = fct_drop(Pref)) levels(Score_df_f2$Pref) ## [1] &quot;東京都&quot; &quot;神奈川県&quot; &quot;千葉県&quot; &quot;埼玉県&quot; &quot;大阪府&quot; &quot;京都府&quot; &quot;兵庫県&quot; &quot;和歌山県&quot; 水準から奈良県が消えました。 12.2.12 fct_expand(): 水準を追加する 一方、データとしては存在しない水準を追加することも可能です。fct_expand()関数には元の変数名に加え、追加する水準名を入れるだけです。たとえば、先ほど奈良県の水準を削除したPrefに奈良県と滋賀県の水準を追加してみましょう。 Score_df_f2 &lt;- Score_df_f2 %&gt;% mutate(Pref = fct_expand(Pref, &quot;奈良県&quot;, &quot;滋賀県&quot;)) Score_df_f2 ## # A tibble: 8 x 2 ## Pref Score ## &lt;fct&gt; &lt;dbl&gt; ## 1 東京都 3.67 ## 2 神奈川県 3.53 ## 3 千葉県 3.72 ## 4 埼玉県 3.64 ## 5 大阪府 3.77 ## 6 京都府 3.68 ## 7 兵庫県 3.54 ## 8 和歌山県 3.97 見た目は全く変わらず、奈良県の行が新しく出来たわけでもありません。それでは、Prefの水準を確認してみましょう。 levels(Score_df_f2$Pref) ## [1] &quot;東京都&quot; &quot;神奈川県&quot; &quot;千葉県&quot; &quot;埼玉県&quot; &quot;大阪府&quot; &quot;京都府&quot; &quot;兵庫県&quot; &quot;和歌山県&quot; ## [9] &quot;奈良県&quot; &quot;滋賀県&quot; \"奈良県\"と\"滋賀県\"という新しい水準が出来ましたね。ただし、新しく追加された水準は最後の順番になりますので、修正が必要な場合はfct_relevel()などを使って適宜修正してください。 12.2.13 fct_explicit_na(): 欠損値に水準を与える 12.3 練習問題 "]
]
