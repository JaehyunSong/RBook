[
["datahandling1.html", "10. データハンドリング[基礎編] 10.1 データハンドリングとtidyverse 10.2 パイプ演算子 (%&gt;%) 10.3 列の抽出 10.4 行の抽出 10.5 行の並び替え 10.6 要約統計量の計算 10.7 グルーピング 10.8 変数の計算", " 10. データハンドリング[基礎編] ここでは比較的綺麗に整形されているデータフレームを扱う方法について考えます。ここでいう「比較的綺麗なデータ」とは、すぐに分析に使えるレベルのデータを意味します。 10.1 データハンドリングとtidyverse library(tidyverse) 10.2 パイプ演算子 (%&gt;%) dplyrパッケージを利用する前にパイプ演算子について説明します。パイプ演算子はdplyrに含まれている演算子ではなく、magrittrという別のパッケージから提供される演算子ですが、tidyverseパッケージを読み込むと自動的に読み込まれます。パイプ演算子はx %&gt;% y()のような書き方となりますが、これは「xをy()の第一引数として渡す」ことを意味します。xの部分はベクトルやデータフレームのようなオブジェクトでも、関数でも構いません。なぜなら、関数から得られた結果もまたベクトルやデータフレームといったものになるからです。 たとえば、「paste(3, \"+\", 5, \"=\", 8)を実行し、その結果をrep()関数を使って3回複製し、それをprint()を使って出力する」コードを考えてみましょう。方法としては2つ考えられます。まずは、それぞれの処理を別途のオブジェクトに格納する方法です。そして二つ目は関数の中に関数を使う方法です。 # 方法1: 一関数一オブジェクト Result1 &lt;- paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) Result2 &lt;- rep(Result1, 3) print(Result2) ## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; # 方法2: 関数の中に関数の中に関数 print(rep(paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8), 3)) ## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; どれも結果は同じです。コードを書く手間を考えれば、後者の方が楽かも知れませんが、可読性があまりよくありません。一方、前者は可読性は良いものの、コードも長くなり、オブジェクトを2つも作ってしまうのでメモリの無駄遣いになります。 コードの可読性と書く手間、両方を満足する書き方がパイプ演算子%&gt;%です。まずは、例から見ましょう。 # %&gt;%を使う paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) %&gt;% rep(3) %&gt;% print() ## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; まず、結果は先ほどと同じです。それではコードの説明をしましょう。まずは、paste(3, \"+\", 5, \"=\", 8)を実行します。そしてその結果をそのままrep()関数の第一引数として渡されます。つまり、rep(paste(3, \"+\", 5, \"=\", 8), 3)になるわけです。ここではrep(3)と書きましたが、第一引数が渡されたため、3は第二引数扱いになります (パイプ演算子前のオブジェクトを第二、三引数として渡す方法は適宜説明します。)。そして、これをまたprint()関数に渡します。結果としてはprint(rep(paste(3, \"+\", 5, \"=\", 8), 3))となります。 関数を重ねると読む順番は「カッコの内側から外側へ」になりますが、パイプ演算子を使うと「左から右へ」といったより自然な読み方が可能になります。また、以下のコードのように、パイプ演算子後に改行を行うことでより読みやすいコードになります。これからはパイプ演算子の後は必ず改行をします。 # 改行 (+字下げ)したらもっと読みやすくなる paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) %&gt;% rep(3) %&gt;% print() データハンドリングは様々な作業を準じに行う必要があります。例えば、「(1) 列を選択して、(2) 欠損値を含む列を除去して、 (3) ある変数の値を100倍にして、(4) ある変数の値がが小さい行から大きい順へ並び替える」といった手順です。これらの作業はパイプ演算子を使えば、スムーズに行うことが可能です。 10.3 列の抽出 それでは今回の実習用データを読み込みましょう。Ramen.csvには「ぐるなび」から取得したラーメン屋6292店舗の情報が入っています。具体的には東京、神奈川、千葉、埼玉、大阪、京都、兵庫、奈良、和歌山それぞれ都府県にあるラーメン屋の中から最大1000店舗の情報を抽出したものです。東京都は、ぐるなびに登録したラーメン屋が3000店舗以上ですが、1000店舗の基準はぐるなびの「おすすめ」の順で上位1000店舗となります。また、店側またはぐるなびが登録したカテゴリを基準に抽出したため、実際はラーメン屋ではないにもかかわらずラーメン屋としてデータ内に含まれている可能性があります。 まず、このデータを読み込み、dfという名付けます。 df &lt;- read_csv(&quot;Data/Ramen.csv&quot;) ## Parsed with column specification: ## cols( ## ID = col_character(), ## Name = col_character(), ## Pref = col_character(), ## Zipcode = col_double(), ## Latitude = col_double(), ## Longitude = col_double(), ## Line = col_character(), ## Station = col_character(), ## Walk = col_double(), ## Bus = col_double(), ## Car = col_double(), ## Budget = col_double(), ## ScoreN = col_double(), ## Score = col_double() ## ) データの中身を確認してみましょう。 df ## # A tibble: 6,292 x 14 ## ID Name Pref Zipcode Latitude Longitude Line Station Walk Bus Car Budget ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 東京都… 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 ## 2 gfeb… 本格上海… 東京都… 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA NA 2000 ## 3 ggt5… 食べ飲み… 東京都… 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA NA 2980 ## 4 g181… 博多餃子… 東京都… 1920904 35.7 139. ＪＲ 八王子駅… 1 NA NA 2000 ## 5 ggww… まさ屋 … 東京都… 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA NA 380 ## 6 gdzk… 完全個室… 東京都… 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 ## 7 ga2g… 鶏そば … 東京都… 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA NA 850 ## 8 gg9m… 宴会個室… 東京都… 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA NA 2000 ## 9 gdvk… 中国料理… 東京都… 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA NA 1000 ## 10 gggb… 中国料理… 東京都… 1140002 35.8 140. 地下鉄南… 王子駅 2 NA NA 2000 ## # … with 6,282 more rows, and 2 more variables: ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; 1行目の# A tibble: 2,000 x 12から、ケース数 (店舗数)は2000、変数は12個あることが分かります。各変数の詳細は以下の通りです。 変数名 説明 ID ぐるなび上の店舗ID Name 店舗名 Pref 店舗の所在地 (都府県) Zipcode 店舗の郵便番号 Latitude 緯度 Longitude 経度 Line 最寄りの駅の路線 Station 最寄りの駅 Walk 最寄りの駅からの距離 (徒歩; 分) Bus 最寄りの駅からの距離 (バス; 分) Car 最寄りの駅からの距離 (車; 分) Budget 平均予算 (円) ScoreN 口コミの数 Score 口コミ評価の平均値 それではここからはdfを用いてdplyrの様々な機能を紹介していきます。 特定の列を抽出する まずは、データフレームから特定の列のみを残す、除去する方法について紹介します。たとえば、dfからID、Name、Pref、Scoreのみを残すとします。dplyrを使わない方法とdplyrのselect()関数を使った方法を紹介します。 # dplyrを使わない方法 df[, c(&quot;ID&quot;, &quot;Name&quot;, &quot;Pref&quot;, &quot;Score&quot;)] ## # A tibble: 6,292 x 4 ## ID Name Pref Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA ## 5 ggww100 まさ屋 渋谷店 東京都 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 東京都 NA ## 7 ga2g202 鶏そば きらり 東京都 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 3.33 ## 9 gdvk200 中国料理 宝龍 東京都 2.5 ## 10 gggb200 中国料理 天安門 東京都 NA ## # … with 6,282 more rows # dplyr::select()を使う方法 # select(df, ID, Name, Pref, Score)でもOK df %&gt;% select(ID, Name, Pref, Score) ## # A tibble: 6,292 x 4 ## ID Name Pref Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA ## 5 ggww100 まさ屋 渋谷店 東京都 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 東京都 NA ## 7 ga2g202 鶏そば きらり 東京都 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 3.33 ## 9 gdvk200 中国料理 宝龍 東京都 2.5 ## 10 gggb200 中国料理 天安門 東京都 NA ## # … with 6,282 more rows どれも結果は同じですが、select()関数を使った方がより読みやすいコードになっているでしょう。むろん、select()関数を使わない方がスッキリする方も知るかも知れません。実際、自分でパッケージなどを作成する際はselect()を使わない場合が多いです。ただし、一般的な分析の流れではselect()の方がコードも意味も明確となり、パイプ演算子でつなぐのも容易です。 select()関数の使い方は非常に簡単です。第一引数はデータフレームですが、パイプ演算子を使う場合は省略可能です。第二引数以降の引数はデータフレームの変数名です。つまり、ここには残す変数名のみを書くだけで十分です。 また、select()関数を使って列の順番を変えることもできます。たとえば、ID、Pref、Name、Scoreの順で列を残すなら、この順番で引数を書くだけです。 df %&gt;% select(ID, Pref, Name) ## # A tibble: 6,292 x 3 ## ID Pref Name ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 e539604 東京都 居酒屋 龍記 京橋店 ## 2 gfeb600 東京都 本格上海料理 新錦江 上野御徒町本店 ## 3 ggt5900 東京都 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） ## 4 g181340 東京都 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 ## 5 ggww100 東京都 まさ屋 渋谷店 ## 6 gdzk500 東京都 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 ## 7 ga2g202 東京都 鶏そば きらり ## 8 gg9m100 東京都 宴会個室×餃子酒場 北京飯店 秋葉原本店 ## 9 gdvk200 東京都 中国料理 宝龍 ## 10 gggb200 東京都 中国料理 天安門 ## # … with 6,282 more rows 特定の列を抽出し、列名を変更する また、特定の列を残す際、変数名を変更することも可能です。今回もID、Name、Pref、Scoreのみを残しますが、Pref列はPrefectureに変えてみましょう。 df %&gt;% select(ID, Name, Prefecture = Pref, Score) ## # A tibble: 6,292 x 4 ## ID Name Prefecture Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA ## 5 ggww100 まさ屋 渋谷店 東京都 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 東京都 NA ## 7 ga2g202 鶏そば きらり 東京都 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 3.33 ## 9 gdvk200 中国料理 宝龍 東京都 2.5 ## 10 gggb200 中国料理 天安門 東京都 NA ## # … with 6,282 more rows 抽出する際、変数を新しい変数名 = 既存の変数名にするだけで、変数名が簡単に変更できました。もし、特定の列は抽出しないものの、変数名を変えるにはどうすれば良いでしょうか。ここではdfのPrefをPrefectureに、WalkをDistanceに変更してみます。dplyrを使わない場合とdplyrのrename()関数を使う場合を両方紹介します。 まずは、name()関数についてですが、これはデータフレームの変数名をベクトルとして出力する関数です。 names(df) ## [1] &quot;ID&quot; &quot;Name&quot; &quot;Pref&quot; &quot;Zipcode&quot; &quot;Latitude&quot; &quot;Longitude&quot; &quot;Line&quot; ## [8] &quot;Station&quot; &quot;Walk&quot; &quot;Bus&quot; &quot;Car&quot; &quot;Budget&quot; &quot;ScoreN&quot; &quot;Score&quot; 察しの良い読者は気づいたかも知れませんが、names(データフレーム名)の結果はベクトルであり、上書きも可能です。つまり、names(df)の3番目と9番目の要素を\"Prefecture\"と\"Distance\"に上書きすることができるということです。 # dplyrを使わずに列名を変更する方法 names(df)[c(3, 9)] &lt;- c(&quot;Prefecture&quot;, &quot;Distance&quot;) # dfの中身を出力 df ## # A tibble: 6,292 x 14 ## ID Name Prefecture Zipcode Latitude Longitude Line Station Distance Bus Car ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 東京都 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA NA ## 2 gfeb… 本格上海… 東京都 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA NA ## 3 ggt5… 食べ飲み… 東京都 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA NA ## 4 g181… 博多餃子… 東京都 1920904 35.7 139. ＪＲ 八王子駅… 1 NA NA ## 5 ggww… まさ屋 … 東京都 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA NA ## 6 gdzk… 完全個室… 東京都 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA NA ## 7 ga2g… 鶏そば … 東京都 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA NA ## 8 gg9m… 宴会個室… 東京都 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA NA ## 9 gdvk… 中国料理… 東京都 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA NA ## 10 gggb… 中国料理… 東京都 1140002 35.8 140. 地下鉄南… 王子駅 2 NA NA ## # … with 6,282 more rows, and 3 more variables: Budget &lt;dbl&gt;, ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; 簡単に変数名の変更ができました。続いて、dplyrのrename()関数を使った方法です。今回は、PrefectureをPrefに、DistanceをWalkに戻して見ましょう。そして、出力するだけにとどまらず、dfに上書きしましょう。 # dfのPrefectureをPrefに、DistanceをWalkに変更し、上書きする df &lt;- df %&gt;% rename(Pref = Prefecture, Walk = Distance) これで終わりです。実はselect()関数と使い方がほぼ同じです。ただし、残す変数名を指定する必要がなく、名前を変更する変数名と新しい変数名を入れるだけです。変数が少ないデータならselect()でもあまり不便は感じないかも知れませんが、変数が多くなるとrename()関数は非常に便利です。 特定の列を除外する 逆に、一部の変数をデータフレームから除去したい場合もあるでしょう。たとえば、緯度 (Latitude)と経度 (Longitude)はラーメン屋の情報としては不要かもしれません。この2つの変数を除外するためにはどうすれば良いでしょうか。まず考えられるのは、この2つの変数を除いた変数を指定・抽出する方法です。 df %&gt;% select(ID, Name, Pref, Zipcode, Line, Station, Walk, Bus, Car, Budget, ScoreN, Score) ## # A tibble: 6,292 x 12 ## ID Name Pref Zipcode Line Station Walk Bus Car Budget ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e5396… 居酒屋 龍記 京橋店… 東京都… 1040031 地下鉄有楽… 銀座一丁目駅… 3 NA NA 3000 0 NA ## 2 gfeb6… 本格上海料理 新錦江 上… 東京都… 1100005 地下鉄日比… 仲御徒町駅… 1 NA NA 2000 2 4.5 ## 3 ggt59… 食べ飲み放題×中華ビスト… 東京都… 1250041 ＪＲ常磐線… 金町駅 2 NA NA 2980 0 NA ## 4 g1813… 博多餃子軒 八王子店 タ… 東京都… 1920904 ＪＲ 八王子駅… 1 NA NA 2000 0 NA ## 5 ggww1… まさ屋 渋谷店 東京都… 1500042 地下鉄半蔵… 渋谷駅 7 NA NA 380 0 NA ## 6 gdzk5… 完全個室 上海レストラン… 東京都… 1000013 地下鉄銀座… 虎ノ門駅… 3 NA NA 2980 0 NA ## 7 ga2g2… 鶏そば きらり 東京都… 1760006 西武池袋線… 江古田駅… 2 NA NA 850 0 NA ## 8 gg9m1… 宴会個室×餃子酒場 北京… 東京都… 1010021 ＪＲ 秋葉原駅… 4 NA NA 2000 3 3.33 ## 9 gdvk2… 中国料理 宝龍 東京都… 1000006 ＪＲ 有楽町駅… 1 NA NA 1000 2 2.5 ## 10 gggb2… 中国料理 天安門… 東京都… 1140002 地下鉄南北… 王子駅 2 NA NA 2000 0 NA ## # … with 6,282 more rows かなり長いコードになりましたね。しかし、もっと簡単な方法があります。それは-を使う方法です。 df %&gt;% select(-Latitude, -Longitude) # select(-c(Latitude, Longitude)) ## # A tibble: 6,292 x 12 ## ID Name Pref Zipcode Line Station Walk Bus Car Budget ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e5396… 居酒屋 龍記 京橋店… 東京都… 1040031 地下鉄有楽… 銀座一丁目駅… 3 NA NA 3000 0 NA ## 2 gfeb6… 本格上海料理 新錦江 上… 東京都… 1100005 地下鉄日比… 仲御徒町駅… 1 NA NA 2000 2 4.5 ## 3 ggt59… 食べ飲み放題×中華ビスト… 東京都… 1250041 ＪＲ常磐線… 金町駅 2 NA NA 2980 0 NA ## 4 g1813… 博多餃子軒 八王子店 タ… 東京都… 1920904 ＪＲ 八王子駅… 1 NA NA 2000 0 NA ## 5 ggww1… まさ屋 渋谷店 東京都… 1500042 地下鉄半蔵… 渋谷駅 7 NA NA 380 0 NA ## 6 gdzk5… 完全個室 上海レストラン… 東京都… 1000013 地下鉄銀座… 虎ノ門駅… 3 NA NA 2980 0 NA ## 7 ga2g2… 鶏そば きらり 東京都… 1760006 西武池袋線… 江古田駅… 2 NA NA 850 0 NA ## 8 gg9m1… 宴会個室×餃子酒場 北京… 東京都… 1010021 ＪＲ 秋葉原駅… 4 NA NA 2000 3 3.33 ## 9 gdvk2… 中国料理 宝龍 東京都… 1000006 ＪＲ 有楽町駅… 1 NA NA 1000 2 2.5 ## 10 gggb2… 中国料理 天安門… 東京都… 1140002 地下鉄南北… 王子駅 2 NA NA 2000 0 NA ## # … with 6,282 more rows 除外したい変数名の前に-を付けただけです。また、-Latitudeと-Longitudeをそれぞれ指定せず、-c(Latitude, Longitude)のようにc()でまとめるのも可能です。 隣接した列を指定する 先ほど、dfから緯度 (Latitude)と経度 (Longitude)を除外する例を考えてみましょう。-を使うと簡単ですが、場合によっては残す変数名を指定する必要もあります。 df %&gt;% select(ID, Name, Pref, Zipcode, Line, Station, Walk, Bus, Car, Budget, ScoreN, Score) よく考えてみれば、IDからZipcodeは隣接した列ですし、LineからScoreまでもそうです。これはnames()関数で確認できます。 names(df) ## [1] &quot;ID&quot; &quot;Name&quot; &quot;Pref&quot; &quot;Zipcode&quot; &quot;Latitude&quot; &quot;Longitude&quot; &quot;Line&quot; ## [8] &quot;Station&quot; &quot;Walk&quot; &quot;Bus&quot; &quot;Car&quot; &quot;Budget&quot; &quot;ScoreN&quot; &quot;Score&quot; ここで便利な演算子が:です。これまで、xからyまでの公差1の等差数列を作成する際にx:yを使って来ましたが、これに非常に似ています。データフレームの「x列からy列まで」の表記もselect()関数内では:と書くことができます。したがって、上記のコードは以下のように短縮化可能です。 df %&gt;% select(ID:Zipcode, Line:Score) 「dfのIDからZipcodeまで、そしてLineからScoreまでの列を選択する」という意味です。非常に便利な演算子ですので、-と合わせて覚えておきましょう。 select()の便利な機能 select()関数は他にも便利な機能がいくつかあります。ここではいくつの機能を紹介しますが、より詳しい内容は?dplyr::selectを参照してください。 まずは、特定の文字を含む変数名を指定する方法です。starts_with(\"X\")、ends_with(\"X\")、contains(\"X\")は変数名が\"X\"で始まるか、\"X\"で終わるか、\"X\"を含むかを判断し、条件に合う変数名を返す関数です。実際の例を見ましょう。 # ID、Nameに続いて、Scoreで始まる変数名を抽出 df %&gt;% select(ID, Name, starts_with(&quot;Score&quot;)) ## # A tibble: 6,292 x 4 ## ID Name ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 0 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 2 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 0 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 0 NA ## 5 ggww100 まさ屋 渋谷店 0 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 0 NA ## 7 ga2g202 鶏そば きらり 0 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 3 3.33 ## 9 gdvk200 中国料理 宝龍 2 2.5 ## 10 gggb200 中国料理 天安門 0 NA ## # … with 6,282 more rows # eで終わる変数名を除去 df %&gt;% select(-ends_with(&quot;e&quot;)) # !ends_with(&quot;e&quot;)も可能 ## # A tibble: 6,292 x 8 ## ID Pref Station Walk Bus Car Budget ScoreN ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 東京都 銀座一丁目駅 3 NA NA 3000 0 ## 2 gfeb600 東京都 仲御徒町駅 1 NA NA 2000 2 ## 3 ggt5900 東京都 金町駅 2 NA NA 2980 0 ## 4 g181340 東京都 八王子駅 1 NA NA 2000 0 ## 5 ggww100 東京都 渋谷駅 7 NA NA 380 0 ## 6 gdzk500 東京都 虎ノ門駅 3 NA NA 2980 0 ## 7 ga2g202 東京都 江古田駅 2 NA NA 850 0 ## 8 gg9m100 東京都 秋葉原駅 4 NA NA 2000 3 ## 9 gdvk200 東京都 有楽町駅 1 NA NA 1000 2 ## 10 gggb200 東京都 王子駅 2 NA NA 2000 0 ## # … with 6,282 more rows # reを含む変数名を抽出するが、ScoreNは除去する df %&gt;% select(contains(&quot;re&quot;), -ScoreN) ## # A tibble: 6,292 x 2 ## Pref Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 東京都 NA ## 2 東京都 4.5 ## 3 東京都 NA ## 4 東京都 NA ## 5 東京都 NA ## 6 東京都 NA ## 7 東京都 NA ## 8 東京都 3.33 ## 9 東京都 2.5 ## 10 東京都 NA ## # … with 6,282 more rows 他の使い方としてはX1、X2のような「文字+数字」の変数を選択する際、starts_with()が活躍します。たとえば、以下のようなmyDF1があるとします。 myDF1 &lt;- data.frame( ID = 1:5, X1 = c(2, 4, 6, 2, 7), Y1 = c(3, 5, 1, 1, 0), X1D = c(4, 2, 1, 6, 9), X2 = c(5, 5, 6, 0, 2), Y2 = c(3, 3, 2, 3, 1), X2D = c(8, 9, 5, 0, 1), X3 = c(3, 0, 3, 0, 2), Y3 = c(1, 5, 9, 1, 3), X3D = c(9, 1, 3, 3, 8) ) myDF1 ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D ## 1 1 2 3 4 5 3 8 3 1 9 ## 2 2 4 5 2 5 3 9 0 5 1 ## 3 3 6 1 1 6 2 5 3 9 3 ## 4 4 2 1 6 0 3 0 0 1 3 ## 5 5 7 0 9 2 1 1 2 3 8 このmyDF1からID、Y1、Y2、Y3を抽出するにはどうすれば良いでしょうか。これらの変数は隣接していないため、:も使えませんが、starts_with()を使えば簡単です。 myDF1 %&gt;% select(ID, starts_with(&quot;Y&quot;)) ## ID Y1 Y2 Y3 ## 1 1 3 3 1 ## 2 2 5 3 5 ## 3 3 1 2 9 ## 4 4 1 3 1 ## 5 5 0 1 3 それでは、ID、X1、X2、X3はどうでしょうか。starts_with(\"X\")だと、X1cなども選択されてしまいますね。ここで-ends_with()の出番です。つまり、「まずはstarts_with(\"X\")でXで始まる変数を選択し、続いて、Dで終わるものを除外すればいいじゃん？」です。それでは、やってみましょうか。 myDF1 %&gt;% select(ID, starts_with(&quot;X&quot;), -ends_with(&quot;D&quot;)) ## X1 X2 X3 ## 1 2 5 3 ## 2 4 5 0 ## 3 6 6 3 ## 4 2 0 0 ## 5 7 2 2 あらら、IDも同時になくなりましたね1。実はこのような時のために用意された関数があり、それがnum_range()です。num_range()の第一引数はstarts_with()関数と同じですが、第二引数も必要です。この第二引数にはnumeric型のベクトルが必要です。1:3でも、c(1, 2, 3)でも構いません。たとえば、ID、X1、X2、X3するには以下のように書きます。 myDF1 %&gt;% select(ID, num_range(&quot;X&quot;, 1:3)) ## ID X1 X2 X3 ## 1 1 2 5 3 ## 2 2 4 5 0 ## 3 3 6 6 3 ## 4 4 2 0 0 ## 5 5 7 2 2 ぱっぱらぱー！ all_of()とany_of()はselect()内の変数名として文字型ベクトルを使う際に用いる関数です。これは抽出したい列名が既にcharacter型ベクトルとして用意されている場合、便利な関数です。たとえば、以下のName_Vecを考えてみましょう。 Name_Vec &lt;- c(&quot;X1&quot;, &quot;X2&quot;, &quot;X3&quot;) このName_Vecの要素と同じ列名を持つ列とID列をmyDF1から抽出する方法は以下の2通りです。 myDF1[, c(&quot;ID&quot;, Name_Vec)] ## ID X1 X2 X3 ## 1 1 2 5 3 ## 2 2 4 5 0 ## 3 3 6 6 3 ## 4 4 2 0 0 ## 5 5 7 2 2 myDF1 %&gt;% select(ID, all_of(Name_Vec)) ## ID X1 X2 X3 ## 1 1 2 5 3 ## 2 2 4 5 0 ## 3 3 6 6 3 ## 4 4 2 0 0 ## 5 5 7 2 2 今の例だと、select()を使わない前者の方が便利かも知れませんが、select()内に外の変数名も指定する場合も多いので、後者の方が汎用性は高いです。私から見れば、今の例でも後者の方が読みやすく、使いやすいと思います。 それでは以下のようなName_Vecはどうでしょう。今回は、myDF1に含まれていないX4とX5もあります。 Name_Vec &lt;- c(&quot;X1&quot;, &quot;X2&quot;, &quot;X3&quot;, &quot;X4&quot;, &quot;X5&quot;) myDF1 %&gt;% select(all_of(Name_Vec)) ## Error: Can&#39;t subset columns that don&#39;t exist. ## [31mx[39m Columns `X4` and `X5` don&#39;t exist. このようにエラーが出てしまします。つまり、all_of()の場合、引数の要素全てがデータフレームに存在する必要があります。もし、ないものは無視して、合致する列だけ取り出したいはどうすれば良いでしょうか。そこで登場するのがany_of()です。 myDF1 %&gt;% select(any_of(Name_Vec)) ## X1 X2 X3 ## 1 2 5 3 ## 2 4 5 0 ## 3 6 6 3 ## 4 2 0 0 ## 5 7 2 2 any_of()の方がより使いやすいと思う方も多いでしょうが、必ずしもそうとは限りません。たとえば、Name_Vecに誤字などが含まれる場合、any_of()だと誤字が含まれている変数は取り出しません。この場合はむしろちゃんとエラーを表示してくれた方が嬉しいですね。 普段あまり使わない機能ですが、最後の列を選択するlast_col()という関数もあります。たとえば、last_col(0)にすると最後の列を選択し、last_col(1)なら最後から2番目の列を選択します。 matches() 10.4 行の抽出 10.5 行の並び替え 10.6 要約統計量の計算 10.7 グルーピング 10.8 変数の計算 実はselect(starts_with(\"X\"), -ends_with(\"D\"), ID)のように順番を変えるとIDは最後の列になりますが、とりあえず残ります。なぜなら、select()関数は左側から右側の方へコードを実行するからです。↩︎ "]
]
