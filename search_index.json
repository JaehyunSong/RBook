[
["datahandling1.html", "10. データハンドリング [基礎編1] 10.1 データハンドリングとtidyverse 10.2 パイプ演算子 (%&gt;%) 10.3 列の抽出 10.4 行の抽出 10.5 行のソート 10.6 練習問題", " 10. データハンドリング [基礎編1] ここでは比較的綺麗に整形されているデータフレームを扱う方法について考えます。ここでいう「比較的綺麗なデータ」とは、すぐに分析に使えるレベルのデータを意味します。したがって、ここではデータ内の値を変更するような作業は行いません。基本的に分析しやすくなるように列の順番を替えたり、特定の列や行のみを抽出したり、データの順番を並び替える作業に注目します。 本性では以下の3つの内容を中心に解説します。 パイプ演算子 (%&gt;%)に慣れる 特定の行と列の抽出 データのソート 本章で学習する内容でデータを加工した場合、得られる結果物は元のデータの一部 (subset)となります。データの中身の値を変えたり、新しい列を追加したり、平均値などの記述統計量をまとめたりする方法については次の第11章で解説します。 10.1 データハンドリングとtidyverse 作成中 library(tidyverse) 10.2 パイプ演算子 (%&gt;%) dplyrパッケージを利用する前にパイプ演算子について説明します。パイプ演算子はdplyrに含まれている演算子ではなく、magrittrという別のパッケージから提供される演算子ですが、tidyverseパッケージを読み込むと自動的に読み込まれます。パイプ演算子はx %&gt;% y()のような書き方となりますが、これは「xをy()の第一引数として渡す」ことを意味します。xの部分はベクトルやデータフレームのようなオブジェクトでも、関数でも構いません。なぜなら、関数から得られた結果もまたベクトルやデータフレームといったものになるからです。つまり、x() %&gt;% y()という使い方も可能です。そして、パイプは無限に繋ぐこともできます。「データdfを関数x()で処理をし、その結果をまた関数y()で処理する」ことは、パイプを使うとdf %&gt;% x() %&gt;% y()のような書き方となります。 たとえば、「paste(3, \"+\", 5, \"=\", 8)を実行し、その結果をrep()関数を使って3回複製し、それをprint()を使って出力する」コードを考えてみましょう。方法としては2つ考えられます。まずは、それぞれの処理を別途のオブジェクトに格納する方法です。そして二つ目は関数の中に関数を使う方法です。 # 方法1: 一関数一オブジェクト Result1 &lt;- paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) Result2 &lt;- rep(Result1, 3) print(Result2) ## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; # 方法2: 関数の中に関数の中に関数 print(rep(paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8), 3)) ## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; どれも結果は同じです。コードを書く手間を考えれば、後者の方が楽かも知れませんが、可読性があまりよくありません。一方、前者は可読性は良いものの、コードも長くなり、オブジェクトを2つも作ってしまうのでメモリの無駄遣いになります。 コードの可読性と書く手間、両方を満足する書き方がパイプ演算子%&gt;%です。まずは、例から見ましょう。 # %&gt;%を使う paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) %&gt;% rep(3) %&gt;% print() ## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; まず、結果は先ほどと同じです。それではコードの説明をしましょう。まずは、paste(3, \"+\", 5, \"=\", 8)を実行します。そしてその結果をそのままrep()関数の第一引数として渡されます。つまり、rep(paste(3, \"+\", 5, \"=\", 8), 3)になるわけです。ここではrep(3)と書きましたが、第一引数が渡されたため、3は第二引数扱いになります (パイプ演算子前のオブジェクトを第二、三引数として渡す方法は適宜説明します。)。そして、これをまたprint()関数に渡します。結果としてはprint(rep(paste(3, \"+\", 5, \"=\", 8), 3))となります。 関数を重ねると読む順番は「カッコの内側から外側へ」になりますが、パイプ演算子を使うと「左 (上)から右 (下)へ」といったより自然な読み方が可能になります。また、以下のコードのように、パイプ演算子後に改行を行うことでより読みやすいコードになります。これからはパイプ演算子の後は必ず改行をします。 # 改行 (+字下げ)したらもっと読みやすくなる paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) %&gt;% rep(3) %&gt;% print() データハンドリングは様々な作業を順に沿って行う必要があります。例えば、「(1) 列を選択して、(2) 欠損値を含む列を除去して、 (3) ある変数の値を100倍にして、(4) ある変数の値がが小さい行から大きい順へ並び替える」といった手順です。これらの作業はパイプ演算子を使えば、スムーズに行うことが可能です。 10.3 列の抽出 それでは今回の実習用データを読み込みましょう。Ramen.csvには「ぐるなび」から取得したラーメン屋6292店舗の情報が入っています。具体的には東京、神奈川、千葉、埼玉、大阪、京都、兵庫、奈良、和歌山それぞれ都府県にあるラーメン屋の中から最大1000店舗の情報を抽出したものです。東京都は、ぐるなびに登録したラーメン屋が3000店舗以上ですが、1000店舗の基準はぐるなびの「おすすめ」の順で上位1000店舗となります。また、店側またはぐるなびが登録したカテゴリを基準に抽出したため、実際はラーメン屋ではないにもかかわらずラーメン屋としてデータ内に含まれている可能性があります。 まず、このデータを読み込み、dfという名付けます。 df &lt;- read_csv(&quot;Data/Ramen.csv&quot;) ## Parsed with column specification: ## cols( ## ID = col_character(), ## Name = col_character(), ## Pref = col_character(), ## Zipcode = col_double(), ## Latitude = col_double(), ## Longitude = col_double(), ## Line = col_character(), ## Station = col_character(), ## Walk = col_double(), ## Bus = col_double(), ## Car = col_double(), ## Budget = col_double(), ## ScoreN = col_double(), ## Score = col_double() ## ) データの中身を確認してみましょう。 df ## # A tibble: 6,292 x 14 ## ID Name Pref Zipcode Latitude Longitude Line Station Walk Bus Car Budget ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 東京都… 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 ## 2 gfeb… 本格上海… 東京都… 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA NA 2000 ## 3 ggt5… 食べ飲み… 東京都… 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA NA 2980 ## 4 g181… 博多餃子… 東京都… 1920904 35.7 139. ＪＲ 八王子駅… 1 NA NA 2000 ## 5 ggww… まさ屋 … 東京都… 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA NA 380 ## 6 gdzk… 完全個室… 東京都… 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 ## 7 ga2g… 鶏そば … 東京都… 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA NA 850 ## 8 gg9m… 宴会個室… 東京都… 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA NA 2000 ## 9 gdvk… 中国料理… 東京都… 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA NA 1000 ## 10 gggb… 中国料理… 東京都… 1140002 35.8 140. 地下鉄南… 王子駅 2 NA NA 2000 ## # … with 6,282 more rows, and 2 more variables: ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; 1行目の# A tibble: 2,000 x 12から、ケース数 (店舗数)は2000、変数は12個あることが分かります。各変数の詳細は以下の通りです。 変数名 説明 ID ぐるなび上の店舗ID Name 店舗名 Pref 店舗の所在地 (都府県) Zipcode 店舗の郵便番号 Latitude 緯度 Longitude 経度 Line 最寄りの駅の路線 Station 最寄りの駅 Walk 最寄りの駅からの距離 (徒歩; 分) Bus 最寄りの駅からの距離 (バス; 分) Car 最寄りの駅からの距離 (車; 分) Budget 平均予算 (円) ScoreN 口コミの数 Score 口コミ評価の平均値 それではここからはdfを用いたdplyrの様々な機能を紹介していきます。 10.3.1 特定の列を抽出する まずは、データフレームから特定の列のみを残す、除去する方法について紹介します。たとえば、dfからID、Name、Pref、Scoreのみを残すとします。dplyrを使わない方法とdplyrのselect()関数を使った方法を紹介します。 # dplyrを使わない方法 df[, c(&quot;ID&quot;, &quot;Name&quot;, &quot;Pref&quot;, &quot;Score&quot;)] ## # A tibble: 6,292 x 4 ## ID Name Pref Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA ## 5 ggww100 まさ屋 渋谷店 東京都 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 東京都 NA ## 7 ga2g202 鶏そば きらり 東京都 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 3.33 ## 9 gdvk200 中国料理 宝龍 東京都 2.5 ## 10 gggb200 中国料理 天安門 東京都 NA ## # … with 6,282 more rows # dplyr::select()を使う方法 # select(df, ID, Name, Pref, Score)でもOK df %&gt;% select(ID, Name, Pref, Score) ## # A tibble: 6,292 x 4 ## ID Name Pref Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA ## 5 ggww100 まさ屋 渋谷店 東京都 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 東京都 NA ## 7 ga2g202 鶏そば きらり 東京都 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 3.33 ## 9 gdvk200 中国料理 宝龍 東京都 2.5 ## 10 gggb200 中国料理 天安門 東京都 NA ## # … with 6,282 more rows どれも結果は同じですが、select()関数を使った方がより読みやすいコードになっているでしょう。むろん、select()関数を使わない方がスッキリする方も知るかも知れません。実際、自分でパッケージなどを作成する際はselect()を使わない場合が多いです。ただし、一般的な分析の流れではselect()の方がコードも意味も明確となり、パイプ演算子でつなぐのも容易です。 select()関数の使い方は非常に簡単です。第一引数はデータフレームですが、パイプ演算子を使う場合は省略可能です。第二引数以降の引数はデータフレームの変数名です。つまり、ここには残す変数名のみを書くだけで十分です。 また、select()関数を使って列の順番を変えることもできます。たとえば、ID、Pref、Name、Scoreの順で列を残すなら、この順番で引数を書くだけです。 df %&gt;% select(ID, Pref, Name) ## # A tibble: 6,292 x 3 ## ID Pref Name ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 e539604 東京都 居酒屋 龍記 京橋店 ## 2 gfeb600 東京都 本格上海料理 新錦江 上野御徒町本店 ## 3 ggt5900 東京都 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） ## 4 g181340 東京都 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 ## 5 ggww100 東京都 まさ屋 渋谷店 ## 6 gdzk500 東京都 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 ## 7 ga2g202 東京都 鶏そば きらり ## 8 gg9m100 東京都 宴会個室×餃子酒場 北京飯店 秋葉原本店 ## 9 gdvk200 東京都 中国料理 宝龍 ## 10 gggb200 東京都 中国料理 天安門 ## # … with 6,282 more rows 10.3.2 特定の列を抽出し、列名を変更する また、特定の列を残す際、変数名を変更することも可能です。今回もID、Name、Pref、Scoreのみを残しますが、Pref列はPrefectureに変えてみましょう。 df %&gt;% select(ID, Name, Prefecture = Pref, Score) ## # A tibble: 6,292 x 4 ## ID Name Prefecture Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA ## 5 ggww100 まさ屋 渋谷店 東京都 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 東京都 NA ## 7 ga2g202 鶏そば きらり 東京都 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 3.33 ## 9 gdvk200 中国料理 宝龍 東京都 2.5 ## 10 gggb200 中国料理 天安門 東京都 NA ## # … with 6,282 more rows 抽出する際、変数を新しい変数名 = 既存の変数名にするだけで、変数名が簡単に変更できました。もし、特定の列は抽出しないものの、変数名を変えるにはどうすれば良いでしょうか。ここではdfのPrefをPrefectureに、WalkをDistanceに変更してみます。dplyrを使わない場合とdplyrのrename()関数を使う場合を両方紹介します。 まずは、name()関数についてですが、これはデータフレームの変数名をベクトルとして出力する関数です。 names(df) ## [1] &quot;ID&quot; &quot;Name&quot; &quot;Pref&quot; &quot;Zipcode&quot; &quot;Latitude&quot; &quot;Longitude&quot; ## [7] &quot;Line&quot; &quot;Station&quot; &quot;Walk&quot; &quot;Bus&quot; &quot;Car&quot; &quot;Budget&quot; ## [13] &quot;ScoreN&quot; &quot;Score&quot; 察しの良い読者は気づいたかも知れませんが、names(データフレーム名)の結果はベクトルであり、上書きも可能です。つまり、names(df)の3番目と9番目の要素を\"Prefecture\"と\"Distance\"に上書きすることができるということです。 # dplyrを使わずに列名を変更する方法 names(df)[c(3, 9)] &lt;- c(&quot;Prefecture&quot;, &quot;Distance&quot;) # dfの中身を出力 df ## # A tibble: 6,292 x 14 ## ID Name Prefecture Zipcode Latitude Longitude Line Station Distance Bus ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 東京都 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA ## 2 gfeb… 本格上海… 東京都 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA ## 3 ggt5… 食べ飲み… 東京都 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA ## 4 g181… 博多餃子… 東京都 1920904 35.7 139. ＪＲ 八王子駅… 1 NA ## 5 ggww… まさ屋 … 東京都 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA ## 6 gdzk… 完全個室… 東京都 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA ## 7 ga2g… 鶏そば … 東京都 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA ## 8 gg9m… 宴会個室… 東京都 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA ## 9 gdvk… 中国料理… 東京都 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA ## 10 gggb… 中国料理… 東京都 1140002 35.8 140. 地下鉄南… 王子駅 2 NA ## # … with 6,282 more rows, and 4 more variables: Car &lt;dbl&gt;, Budget &lt;dbl&gt;, ## # ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; 簡単に変数名の変更ができました。続いて、dplyrのrename()関数を使った方法です。今回は、PrefectureをPrefに、DistanceをWalkに戻して見ましょう。そして、出力するだけにとどまらず、dfに上書きしましょう。 # dfのPrefectureをPrefに、DistanceをWalkに変更し、上書きする df &lt;- df %&gt;% rename(Pref = Prefecture, Walk = Distance) これで終わりです。実はselect()関数と使い方がほぼ同じです。ただし、残す変数名を指定する必要がなく、名前を変更する変数名と新しい変数名を入れるだけです。変数が少ないデータならselect()でもあまり不便は感じないかも知れませんが、変数が多くなるとrename()関数は非常に便利です。 10.3.3 特定の列を除外する 逆に、一部の変数をデータフレームから除去したい場合もあるでしょう。たとえば、緯度 (Latitude)と経度 (Longitude)はラーメン屋の情報としては不要かもしれません。この2つの変数を除外するためにはどうすれば良いでしょうか。まず考えられるのは、この2つの変数を除いた変数を指定・抽出する方法です。 df %&gt;% select(ID, Name, Pref, Zipcode, Line, Station, Walk, Bus, Car, Budget, ScoreN, Score) ## # A tibble: 6,292 x 12 ## ID Name Pref Zipcode Line Station Walk Bus Car Budget ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e5396… 居酒屋 龍記 京橋… 東京都… 1040031 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 0 NA ## 2 gfeb6… 本格上海料理 新錦… 東京都… 1100005 地下鉄日… 仲御徒町駅… 1 NA NA 2000 2 4.5 ## 3 ggt59… 食べ飲み放題×中華… 東京都… 1250041 ＪＲ常磐… 金町駅 2 NA NA 2980 0 NA ## 4 g1813… 博多餃子軒 八王子… 東京都… 1920904 ＪＲ 八王子駅… 1 NA NA 2000 0 NA ## 5 ggww1… まさ屋 渋谷店… 東京都… 1500042 地下鉄半… 渋谷駅 7 NA NA 380 0 NA ## 6 gdzk5… 完全個室 上海レス… 東京都… 1000013 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 0 NA ## 7 ga2g2… 鶏そば きらり… 東京都… 1760006 西武池袋… 江古田駅… 2 NA NA 850 0 NA ## 8 gg9m1… 宴会個室×餃子酒場… 東京都… 1010021 ＪＲ 秋葉原駅… 4 NA NA 2000 3 3.33 ## 9 gdvk2… 中国料理 宝龍… 東京都… 1000006 ＪＲ 有楽町駅… 1 NA NA 1000 2 2.5 ## 10 gggb2… 中国料理 天安門… 東京都… 1140002 地下鉄南… 王子駅 2 NA NA 2000 0 NA ## # … with 6,282 more rows かなり長いコードになりましたね。しかし、もっと簡単な方法があります。それは-を使う方法です。 df %&gt;% select(-Latitude, -Longitude) # select(-c(Latitude, Longitude)) ## # A tibble: 6,292 x 12 ## ID Name Pref Zipcode Line Station Walk Bus Car Budget ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e5396… 居酒屋 龍記 京橋… 東京都… 1040031 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 0 NA ## 2 gfeb6… 本格上海料理 新錦… 東京都… 1100005 地下鉄日… 仲御徒町駅… 1 NA NA 2000 2 4.5 ## 3 ggt59… 食べ飲み放題×中華… 東京都… 1250041 ＪＲ常磐… 金町駅 2 NA NA 2980 0 NA ## 4 g1813… 博多餃子軒 八王子… 東京都… 1920904 ＪＲ 八王子駅… 1 NA NA 2000 0 NA ## 5 ggww1… まさ屋 渋谷店… 東京都… 1500042 地下鉄半… 渋谷駅 7 NA NA 380 0 NA ## 6 gdzk5… 完全個室 上海レス… 東京都… 1000013 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 0 NA ## 7 ga2g2… 鶏そば きらり… 東京都… 1760006 西武池袋… 江古田駅… 2 NA NA 850 0 NA ## 8 gg9m1… 宴会個室×餃子酒場… 東京都… 1010021 ＪＲ 秋葉原駅… 4 NA NA 2000 3 3.33 ## 9 gdvk2… 中国料理 宝龍… 東京都… 1000006 ＪＲ 有楽町駅… 1 NA NA 1000 2 2.5 ## 10 gggb2… 中国料理 天安門… 東京都… 1140002 地下鉄南… 王子駅 2 NA NA 2000 0 NA ## # … with 6,282 more rows 除外したい変数名の前に-を付けただけです。また、-Latitudeと-Longitudeをそれぞれ指定せず、-c(Latitude, Longitude)のようにc()でまとめるのも可能です。 10.3.4 隣接した列を指定する 先ほど、dfから緯度 (Latitude)と経度 (Longitude)を除外する例を考えてみましょう。-を使うと簡単ですが、場合によっては残す変数名を指定する必要もあります。 df %&gt;% select(ID, Name, Pref, Zipcode, Line, Station, Walk, Bus, Car, Budget, ScoreN, Score) よく考えてみれば、IDからZipcodeは隣接した列ですし、LineからScoreまでもそうです。これはnames()関数で確認できます。 names(df) ## [1] &quot;ID&quot; &quot;Name&quot; &quot;Pref&quot; &quot;Zipcode&quot; &quot;Latitude&quot; &quot;Longitude&quot; ## [7] &quot;Line&quot; &quot;Station&quot; &quot;Walk&quot; &quot;Bus&quot; &quot;Car&quot; &quot;Budget&quot; ## [13] &quot;ScoreN&quot; &quot;Score&quot; ここで便利な演算子が:です。これまで、xからyまでの公差1の等差数列を作成する際にx:yを使って来ましたが、これに非常に似ています。データフレームの「x列からy列まで」の表記もselect()関数内では:と書くことができます。したがって、上記のコードは以下のように短縮化可能です。 df %&gt;% select(ID:Zipcode, Line:Score) 「dfのIDからZipcodeまで、そしてLineからScoreまでの列を選択する」という意味です。非常に便利な演算子ですので、-と合わせて覚えておきましょう。 10.3.5 一部の列の順番だけを変える ある列の位置を替えたいとします。たとえば、ScoreとScoreNをそれぞれ1列目、2列目にしたい場合、どうすれば良いでしょうか。これまで勉強したことを考えると、以下のようなコードで問題ないでしょう。 df %&gt;% select(Score, ScoreN, ID:Budget) ## # A tibble: 6,292 x 14 ## Score ScoreN ID Name Pref Zipcode Latitude Longitude Line Station Walk Bus ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NA 0 e539… 居酒屋 … 東京都… 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA ## 2 4.5 2 gfeb… 本格上海… 東京都… 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA ## 3 NA 0 ggt5… 食べ飲み… 東京都… 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA ## 4 NA 0 g181… 博多餃子… 東京都… 1920904 35.7 139. ＪＲ 八王子駅… 1 NA ## 5 NA 0 ggww… まさ屋 … 東京都… 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA ## 6 NA 0 gdzk… 完全個室… 東京都… 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA ## 7 NA 0 ga2g… 鶏そば … 東京都… 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA ## 8 3.33 3 gg9m… 宴会個室… 東京都… 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA ## 9 2.5 2 gdvk… 中国料理… 東京都… 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA ## 10 NA 0 gggb… 中国料理… 東京都… 1140002 35.8 140. 地下鉄南… 王子駅 2 NA ## # … with 6,282 more rows, and 2 more variables: Car &lt;dbl&gt;, Budget &lt;dbl&gt; しかし、dplyrにはrelocate()というより便利な専用関数を提供しています。relocate()には変数名を指定するだけですが、ここで指定した変数がデータフレームの最初列の方に移動します。 df %&gt;% relocate(Score, ScoreN) ## # A tibble: 6,292 x 14 ## Score ScoreN ID Name Pref Zipcode Latitude Longitude Line Station Walk Bus ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NA 0 e539… 居酒屋 … 東京都… 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA ## 2 4.5 2 gfeb… 本格上海… 東京都… 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA ## 3 NA 0 ggt5… 食べ飲み… 東京都… 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA ## 4 NA 0 g181… 博多餃子… 東京都… 1920904 35.7 139. ＪＲ 八王子駅… 1 NA ## 5 NA 0 ggww… まさ屋 … 東京都… 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA ## 6 NA 0 gdzk… 完全個室… 東京都… 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA ## 7 NA 0 ga2g… 鶏そば … 東京都… 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA ## 8 3.33 3 gg9m… 宴会個室… 東京都… 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA ## 9 2.5 2 gdvk… 中国料理… 東京都… 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA ## 10 NA 0 gggb… 中国料理… 東京都… 1140002 35.8 140. 地下鉄南… 王子駅 2 NA ## # … with 6,282 more rows, and 2 more variables: Car &lt;dbl&gt;, Budget &lt;dbl&gt; relocate()を使うとID:Budgetが省略可能となり、より短いコードになります。もう一つの例は、最初に持ってくるのではなく、「ある変数の前」または「ある変数の後」に移動させるケースです。これもrelocate()で可能ですが、もう一つの引数が必要です。PrefとZipcdoeの順番を変えるなら、まずは以下のような方法が考えられます。 df %&gt;% select(ID:Name, Zipcode, Pref, Latitude:Score) ## # A tibble: 6,292 x 14 ## ID Name Zipcode Pref Latitude Longitude Line Station Walk Bus Car Budget ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 1040031 東京都… 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 ## 2 gfeb… 本格上海… 1100005 東京都… 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA NA 2000 ## 3 ggt5… 食べ飲み… 1250041 東京都… 35.8 140. ＪＲ常磐… 金町駅 2 NA NA 2980 ## 4 g181… 博多餃子… 1920904 東京都… 35.7 139. ＪＲ 八王子駅… 1 NA NA 2000 ## 5 ggww… まさ屋 … 1500042 東京都… 35.7 140. 地下鉄半… 渋谷駅 7 NA NA 380 ## 6 gdzk… 完全個室… 1000013 東京都… 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 ## 7 ga2g… 鶏そば … 1760006 東京都… 35.7 140. 西武池袋… 江古田駅… 2 NA NA 850 ## 8 gg9m… 宴会個室… 1010021 東京都… 35.7 140. ＪＲ 秋葉原駅… 4 NA NA 2000 ## 9 gdvk… 中国料理… 1000006 東京都… 35.7 140. ＪＲ 有楽町駅… 1 NA NA 1000 ## 10 gggb… 中国料理… 1140002 東京都… 35.8 140. 地下鉄南… 王子駅 2 NA NA 2000 ## # … with 6,282 more rows, and 2 more variables: ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; これをrelocate()で書き換えるなら、.afterまたは.before引数が必要になります。relocate(変数名1, .after = 変数名2)は「変数1を変数2の直後に移動させる」 ことを意味します。 df %&gt;% relocate(Pref, .after = Zipcode) ## # A tibble: 6,292 x 14 ## ID Name Zipcode Pref Latitude Longitude Line Station Walk Bus Car Budget ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 1040031 東京都… 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 ## 2 gfeb… 本格上海… 1100005 東京都… 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA NA 2000 ## 3 ggt5… 食べ飲み… 1250041 東京都… 35.8 140. ＪＲ常磐… 金町駅 2 NA NA 2980 ## 4 g181… 博多餃子… 1920904 東京都… 35.7 139. ＪＲ 八王子駅… 1 NA NA 2000 ## 5 ggww… まさ屋 … 1500042 東京都… 35.7 140. 地下鉄半… 渋谷駅 7 NA NA 380 ## 6 gdzk… 完全個室… 1000013 東京都… 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 ## 7 ga2g… 鶏そば … 1760006 東京都… 35.7 140. 西武池袋… 江古田駅… 2 NA NA 850 ## 8 gg9m… 宴会個室… 1010021 東京都… 35.7 140. ＪＲ 秋葉原駅… 4 NA NA 2000 ## 9 gdvk… 中国料理… 1000006 東京都… 35.7 140. ＪＲ 有楽町駅… 1 NA NA 1000 ## 10 gggb… 中国料理… 1140002 東京都… 35.8 140. 地下鉄南… 王子駅 2 NA NA 2000 ## # … with 6,282 more rows, and 2 more variables: ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; .beforeを使うことできます。この場合は「ZipcodeをPrefの直前に移動させる」 ことを指定する必要があります。結果は省略しますが、自分でコードを走らせ、上と同じ結果が得られるかを確認してみてください。 df %&gt;% relocate(Zipcode, .before = Pref) 10.3.6 select()の便利な機能 select()関数は他にも便利な機能がいくつかあります。ここではいくつの機能を紹介しますが、より詳しい内容は?dplyr::selectを参照してください。 starts_with()とends_with()、contains()、num_range(): 特定の文字を含む変数を選択する まずは、特定の文字を含む変数名を指定する方法です。starts_with(\"X\")、ends_with(\"X\")、contains(\"X\")は変数名が\"X\"で始まるか、\"X\"で終わるか、\"X\"を含むかを判断し、条件に合う変数名を返す関数です。実際の例を見ましょう。 # ID、Nameに続いて、Scoreで始まる変数名を抽出 df %&gt;% select(ID, Name, starts_with(&quot;Score&quot;)) ## # A tibble: 6,292 x 4 ## ID Name ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 0 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 2 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 0 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 0 NA ## 5 ggww100 まさ屋 渋谷店 0 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 0 NA ## 7 ga2g202 鶏そば きらり 0 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 3 3.33 ## 9 gdvk200 中国料理 宝龍 2 2.5 ## 10 gggb200 中国料理 天安門 0 NA ## # … with 6,282 more rows # eで終わる変数名を除去 df %&gt;% select(-ends_with(&quot;e&quot;)) # !ends_with(&quot;e&quot;)も可能 ## # A tibble: 6,292 x 8 ## ID Pref Station Walk Bus Car Budget ScoreN ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 東京都 銀座一丁目駅 3 NA NA 3000 0 ## 2 gfeb600 東京都 仲御徒町駅 1 NA NA 2000 2 ## 3 ggt5900 東京都 金町駅 2 NA NA 2980 0 ## 4 g181340 東京都 八王子駅 1 NA NA 2000 0 ## 5 ggww100 東京都 渋谷駅 7 NA NA 380 0 ## 6 gdzk500 東京都 虎ノ門駅 3 NA NA 2980 0 ## 7 ga2g202 東京都 江古田駅 2 NA NA 850 0 ## 8 gg9m100 東京都 秋葉原駅 4 NA NA 2000 3 ## 9 gdvk200 東京都 有楽町駅 1 NA NA 1000 2 ## 10 gggb200 東京都 王子駅 2 NA NA 2000 0 ## # … with 6,282 more rows # reを含む変数名を抽出するが、ScoreNは除去する df %&gt;% select(contains(&quot;re&quot;), -ScoreN) ## # A tibble: 6,292 x 2 ## Pref Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 東京都 NA ## 2 東京都 4.5 ## 3 東京都 NA ## 4 東京都 NA ## 5 東京都 NA ## 6 東京都 NA ## 7 東京都 NA ## 8 東京都 3.33 ## 9 東京都 2.5 ## 10 東京都 NA ## # … with 6,282 more rows 他の使い方としてはX1、X2のような「文字+数字」の変数を選択する際、starts_with()が活躍します。たとえば、以下のようなmyDF1があるとします。 # tibble()でなく、data.frame()も使用可能です。 myDF1 &lt;- tibble( ID = 1:5, X1 = c(2, 4, 6, 2, 7), Y1 = c(3, 5, 1, 1, 0), X1D = c(4, 2, 1, 6, 9), X2 = c(5, 5, 6, 0, 2), Y2 = c(3, 3, 2, 3, 1), X2D = c(8, 9, 5, 0, 1), X3 = c(3, 0, 3, 0, 2), Y3 = c(1, 5, 9, 1, 3), X3D = c(9, 1, 3, 3, 8) ) myDF1 ## # A tibble: 5 x 10 ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 3 4 5 3 8 3 1 9 ## 2 2 4 5 2 5 3 9 0 5 1 ## 3 3 6 1 1 6 2 5 3 9 3 ## 4 4 2 1 6 0 3 0 0 1 3 ## 5 5 7 0 9 2 1 1 2 3 8 このmyDF1からID、Y1、Y2、Y3を抽出するにはどうすれば良いでしょうか。これらの変数は隣接していないため、:も使えませんが、starts_with()を使えば簡単です。 myDF1 %&gt;% select(ID, starts_with(&quot;Y&quot;)) ## # A tibble: 5 x 4 ## ID Y1 Y2 Y3 ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 3 3 1 ## 2 2 5 3 5 ## 3 3 1 2 9 ## 4 4 1 3 1 ## 5 5 0 1 3 それでは、ID、X1、X2、X3はどうでしょうか。starts_with(\"X\")だと、X1cなども選択されてしまいますね。ここで-ends_with()の出番です。つまり、「まずはstarts_with(\"X\")でXで始まる変数を選択し、続いて、Dで終わるものを除外すればいいじゃん？」です。それでは、やってみましょうか。 myDF1 %&gt;% select(ID, starts_with(&quot;X&quot;), -ends_with(&quot;D&quot;)) ## # A tibble: 5 x 3 ## X1 X2 X3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 5 3 ## 2 4 5 0 ## 3 6 6 3 ## 4 2 0 0 ## 5 7 2 2 あらら、IDも同時になくなりましたね1。実はこのような時のために用意された関数があり、それがnum_range()です。num_range()の第一引数はstarts_with()関数と同じですが、第二引数も必要です。この第二引数にはnumeric型のベクトルが必要です。1:3でも、c(1, 2, 3)でも構いません。たとえば、ID、X1、X2、X3するには以下のように書きます。 myDF1 %&gt;% select(ID, num_range(&quot;X&quot;, 1:3)) ## # A tibble: 5 x 4 ## ID X1 X2 X3 ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 5 3 ## 2 2 4 5 0 ## 3 3 6 6 3 ## 4 4 2 0 0 ## 5 5 7 2 2 ぱっぱらぱー！ all_of()とany_of(): 文字型ベクトルを用いた変数の選択 all_of()とany_of()はselect()内の変数名として文字型ベクトルを使う際に用いる関数です。これは抽出したい列名が既にcharacter型ベクトルとして用意されている場合、便利な関数です。たとえば、以下のName_Vecを考えてみましょう。 Name_Vec &lt;- c(&quot;X1&quot;, &quot;X2&quot;, &quot;X3&quot;) このName_Vecの要素と同じ列名を持つ列とID列をmyDF1から抽出する方法は以下の2通りです。 myDF1[, c(&quot;ID&quot;, Name_Vec)] ## # A tibble: 5 x 4 ## ID X1 X2 X3 ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 5 3 ## 2 2 4 5 0 ## 3 3 6 6 3 ## 4 4 2 0 0 ## 5 5 7 2 2 myDF1 %&gt;% select(ID, all_of(Name_Vec)) ## # A tibble: 5 x 4 ## ID X1 X2 X3 ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 5 3 ## 2 2 4 5 0 ## 3 3 6 6 3 ## 4 4 2 0 0 ## 5 5 7 2 2 今の例だと、select()を使わない前者の方が便利かも知れませんが、select()内に外の変数名も指定する場合も多いので、後者の方が汎用性は高いです。私から見れば、今の例でも後者の方が読みやすく、使いやすいと思います。 それでは以下のようなName_Vecはどうでしょう。今回は、myDF1に含まれていないX4とX5もあります。 Name_Vec &lt;- c(&quot;X1&quot;, &quot;X2&quot;, &quot;X3&quot;, &quot;X4&quot;, &quot;X5&quot;) myDF1 %&gt;% select(all_of(Name_Vec)) ## Error: Can&#39;t subset columns that don&#39;t exist. ## [31mx[39m Columns `X4` and `X5` don&#39;t exist. このようにエラーが出てしまします。つまり、all_of()の場合、引数の要素全てがデータフレームに存在する必要があります。もし、ないものは無視して、合致する列だけ取り出したいはどうすれば良いでしょうか。そこで登場するのがany_of()です。 myDF1 %&gt;% select(any_of(Name_Vec)) ## # A tibble: 5 x 3 ## X1 X2 X3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 5 3 ## 2 4 5 0 ## 3 6 6 3 ## 4 2 0 0 ## 5 7 2 2 any_of()の方がより使いやすいと思う方も多いでしょうが、必ずしもそうとは限りません。たとえば、Name_Vecに誤字などが含まれる場合、any_of()だと誤字が含まれている変数は取り出しません。この場合はむしろちゃんとエラーを表示してくれた方が嬉しいですね。 last_col(): 最後の列を選択する 普段あまり使わない機能ですが、最後の列を選択するlast_col()という関数もあります。たとえば、last_col(0)にすると最後の列を選択し、last_col(1)なら最後から2番目の列を選択します。たとえば、dfからIDと最後の列を取り出してみましょう。 # IDと最後の列のみを抽出 df %&gt;% select(ID, last_col(0)) ## # A tibble: 6,292 x 2 ## ID Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 NA ## 2 gfeb600 4.5 ## 3 ggt5900 NA ## 4 g181340 NA ## 5 ggww100 NA ## 6 gdzk500 NA ## 7 ga2g202 NA ## 8 gg9m100 3.33 ## 9 gdvk200 2.5 ## 10 gggb200 NA ## # … with 6,282 more rows 最後の2行分を取り出すことも可能です。この場合はlast_col()の引数を長さ1ベクトルでなく、長さ2以上のベクトルにします。最後の行が0、その手前の行が1ですから、中の引数は1:0となります。0:1でも可能ですが、結果が若干異なります。 # IDと最後の2列分を抽出 (引数を1:0と設定) df %&gt;% select(ID, last_col(1:0)) ## # A tibble: 6,292 x 3 ## ID ScoreN Score ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 0 NA ## 2 gfeb600 2 4.5 ## 3 ggt5900 0 NA ## 4 g181340 0 NA ## 5 ggww100 0 NA ## 6 gdzk500 0 NA ## 7 ga2g202 0 NA ## 8 gg9m100 3 3.33 ## 9 gdvk200 2 2.5 ## 10 gggb200 0 NA ## # … with 6,282 more rows # IDと最後の2列分を抽出 (引数を0:1と設定) df %&gt;% select(ID, last_col(0:1)) ## # A tibble: 6,292 x 3 ## ID Score ScoreN ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 NA 0 ## 2 gfeb600 4.5 2 ## 3 ggt5900 NA 0 ## 4 g181340 NA 0 ## 5 ggww100 NA 0 ## 6 gdzk500 NA 0 ## 7 ga2g202 NA 0 ## 8 gg9m100 3.33 3 ## 9 gdvk200 2.5 2 ## 10 gggb200 NA 0 ## # … with 6,282 more rows last_col()の引数を1:0にするか0:1にするかによって抽出される順番が異なります。1:0はc(1, 0)、0:1はc(0, 1)と同じであることを考えると理由は簡単です。c(1, 0)の場合、last_col(1), last_col(0)の順番で処理をし、c(0, 1)はlast_col(0)、last_col(1)の順番で処理を行うからです。 このlast_col()の引数を空っぽにするとそれは最後の列を意味します。これを利用すれば、「ある変数の最後の列へ移動させる」こともできます。たとえば、IDを最後の列に移動させたい場合、relocate(ID, .after = last_col())のように書きます。 where(): データ型から変数を選択する 最後に、「numeric型の列のみ抽出したい」、「character型の列だけほしい」場合に便利なwhere()関数を紹介します。where()の中に入る引数は一つだけであり、データ型を判定する関数名が入ります。たとえば、numeric型か否かを判断する関数はis.numericです。dfからnumeric型の変数のみを抽出したい場合は以下のように書きます。 # numeric型の列を抽出する df %&gt;% select(where(is.numeric)) ## # A tibble: 6,292 x 9 ## Zipcode Latitude Longitude Walk Bus Car Budget ScoreN Score ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1040031 35.7 140. 3 NA NA 3000 0 NA ## 2 1100005 35.7 140. 1 NA NA 2000 2 4.5 ## 3 1250041 35.8 140. 2 NA NA 2980 0 NA ## 4 1920904 35.7 139. 1 NA NA 2000 0 NA ## 5 1500042 35.7 140. 7 NA NA 380 0 NA ## 6 1000013 35.7 140. 3 NA NA 2980 0 NA ## 7 1760006 35.7 140. 2 NA NA 850 0 NA ## 8 1010021 35.7 140. 4 NA NA 2000 3 3.33 ## 9 1000006 35.7 140. 1 NA NA 1000 2 2.5 ## 10 1140002 35.8 140. 2 NA NA 2000 0 NA ## # … with 6,282 more rows !を使って条件に合致する列を除外することも可能です。もし、character型の列を除外する場合は以下のように!where(is.character)を指定します。 # character型でない列を抽出する df %&gt;% select(!where(is.character)) ## # A tibble: 6,292 x 9 ## Zipcode Latitude Longitude Walk Bus Car Budget ScoreN Score ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1040031 35.7 140. 3 NA NA 3000 0 NA ## 2 1100005 35.7 140. 1 NA NA 2000 2 4.5 ## 3 1250041 35.8 140. 2 NA NA 2980 0 NA ## 4 1920904 35.7 139. 1 NA NA 2000 0 NA ## 5 1500042 35.7 140. 7 NA NA 380 0 NA ## 6 1000013 35.7 140. 3 NA NA 2980 0 NA ## 7 1760006 35.7 140. 2 NA NA 850 0 NA ## 8 1010021 35.7 140. 4 NA NA 2000 3 3.33 ## 9 1000006 35.7 140. 1 NA NA 1000 2 2.5 ## 10 1140002 35.8 140. 2 NA NA 2000 0 NA ## # … with 6,282 more rows &amp;を使って複数の条件を使うことも可能です。たとえば、ID変数に加えて「\"L\"で始まる変数の中でnumeric型の列を抽出」するコードは以下のようになります。 # IDと、Lで始まるnumeric型の列を抽出する df %&gt;% select(ID, starts_with(&quot;L&quot;) &amp; where(is.numeric)) ## # A tibble: 6,292 x 3 ## ID Latitude Longitude ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 35.7 140. ## 2 gfeb600 35.7 140. ## 3 ggt5900 35.8 140. ## 4 g181340 35.7 139. ## 5 ggww100 35.7 140. ## 6 gdzk500 35.7 140. ## 7 ga2g202 35.7 140. ## 8 gg9m100 35.7 140. ## 9 gdvk200 35.7 140. ## 10 gggb200 35.8 140. ## # … with 6,282 more rows 10.4 行の抽出 他にも特定の行を抽出する場合があります。多くの場合、「何かの条件と合致するケースのみ抽出する」または、「何かの条件と合致しないケースのみを抽出する」やこれらの組み合わせで行の抽出を行います。そこで登場するのがdplyr()パッケージのfilter()関数です。filter()関数の使い方は以下の通りです。 # dplyr::filter()の使い方 filter(データフレーム名, 条件1, 条件2, ...) むろん、第一引数がデータですから、%&gt;%を使うことも可能です。 # dplyr::filter()の使い方 (パイプを使う方法) データフレーム名 %&gt;% filter(条件1, 条件2, ...) まずは、条件が一つの場合を考えてみましょう。ここでは「Prefが\"京都府\"であるケースのみに絞り、NameとStation、Score列のみを出力する」ケースを考えてみましょう。まず、filter()関数で行を抽出し、続いてselect()関数で抽出する列を指定します。むろん、今回の場合、filter()とselect()の順番は替えても構いません。 # dfからPrefが&quot;京都府&quot;であるケースのみ残し、df2という名で保存 df2 &lt;- df %&gt;% filter(Pref == &quot;京都府&quot;) # df2からName, Station, Score列を抽出 df2 %&gt;% select(Name, Station, Score) ## # A tibble: 414 x 3 ## Name Station Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 中国料理 鳳麟 くいな橋駅 NA ## 2 黒毛和牛一頭買い焼肉と 炊き立て土鍋ご飯 市場小路 烏丸店 四条駅 3.19 ## 3 京の中華 ハマムラ みやこみち店 京都駅 NA ## 4 焼肉処 真 桂店 桂駅 NA ## 5 祇園京都ラーメン 祇園四条駅 NA ## 6 創作料理 串カツ トンカツ jiro 新田辺駅 NA ## 7 祇園 晩餐のあと 祇園四条駅 NA ## 8 DETAIL 東山駅 NA ## 9 めんや龍神 北大路駅 NA ## 10 無尽蔵 京都八条家 京都駅 3.5 ## # … with 404 more rows これはdfからPref == \"京都府\"のケースのみ残したものをdf2として格納し、それをまたselect()関数を使って列を抽出するコードです。これでも問題ありませんが、これだとパイプ演算子の便利さが分かりません。パイプ演算子は複数使うことが可能です。 df %&gt;% filter(Pref == &quot;京都府&quot;) %&gt;% select(Name, Station, Score) ## # A tibble: 414 x 3 ## Name Station Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 中国料理 鳳麟 くいな橋駅 NA ## 2 黒毛和牛一頭買い焼肉と 炊き立て土鍋ご飯 市場小路 烏丸店 四条駅 3.19 ## 3 京の中華 ハマムラ みやこみち店 京都駅 NA ## 4 焼肉処 真 桂店 桂駅 NA ## 5 祇園京都ラーメン 祇園四条駅 NA ## 6 創作料理 串カツ トンカツ jiro 新田辺駅 NA ## 7 祇園 晩餐のあと 祇園四条駅 NA ## 8 DETAIL 東山駅 NA ## 9 めんや龍神 北大路駅 NA ## 10 無尽蔵 京都八条家 京都駅 3.5 ## # … with 404 more rows 全く同じ結果ですが、無駄にdf2というデータフレームを作らず済むので、メモリの観点からも嬉しいですし、何よりコードが短く、しかも可読性も上がりました。 今回は==を使って合致するものに絞りましたが、!=を使って合致しないものに絞ることも可能です。または、比較演算子 (&lt;、&gt;、&gt;=、&lt;=など)を使うことも可能です。それでは、組み込み数 (ScoreN)が0ではないケースを取り出し、Name、Station、ScoreN、Score列を出力させてみましょう。 df %&gt;% filter(ScoreN != 0) %&gt;% select(Name, Station, starts_with(&quot;Score&quot;)) ## # A tibble: 1,344 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 本格上海料理 新錦江 上野御徒町本店 仲御徒町駅 2 4.5 ## 2 宴会個室×餃子酒場 北京飯店 秋葉原本店 秋葉原駅 3 3.33 ## 3 中国料理 宝龍 有楽町駅 2 2.5 ## 4 麺達 うま家 高田馬場駅 2 3 ## 5 刀削麺・火鍋・西安料理 XI’AN（シーアン） 後楽園店 後楽園駅 1 NA ## 6 七志らーめん 渋谷道玄坂店 渋谷駅 7 4.5 ## 7 永楽 京成小岩駅 6 4.42 ## 8 よってこや お台場店 お台場海浜公園駅 1 4 ## 9 ラーメン武藤製麺所 竹ノ塚駅 4 3.5 ## 10 桂花ラーメン 新宿末広店 新宿三丁目駅 8 3 ## # … with 1,334 more rows これで口コミ数が1以上の店舗のみに絞ることができました。ただし、店によっては口コミはあっても、評価 (Score)が付いていないところもあります。たとえば、「刀削麺・火鍋・西安料理 XI’AN（シーアン） 後楽園店」の場合、口コミはありますが、評価はありません。したがって、今回は評価が付いている店舗に絞ってみましょう。 df %&gt;% filter(Score != NA) %&gt;% select(Name, Station, starts_with(&quot;Score&quot;)) ## # A tibble: 0 x 4 ## # … with 4 variables: Name &lt;chr&gt;, Station &lt;chr&gt;, ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; あらら、何の結果も表示されませんでした。これはfilter()内の条件に合致するケースが存在しないことを意味します。しかし、先ほどの結果を見ても、評価が付いている店はいっぱいありましたね。これはなぜでしょう。 察しの良い読者さんは気づいているかと思いますが、第7.8章で説明した通り、NAか否かを判定する際は==や!=は使えません。is.na()を使います。filter(is.na(Score))なら「ScoreがNAであるケースに絞る」ことを意味しますが、今回は「ScoreがNAでないケースに絞る」ことが目的ですので、is.na()の前に!を付けます。 df %&gt;% filter(!is.na(Score)) %&gt;% select(Name, Station, starts_with(&quot;Score&quot;)) ## # A tibble: 1,134 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 本格上海料理 新錦江 上野御徒町本店 仲御徒町駅 2 4.5 ## 2 宴会個室×餃子酒場 北京飯店 秋葉原本店 秋葉原駅 3 3.33 ## 3 中国料理 宝龍 有楽町駅 2 2.5 ## 4 麺達 うま家 高田馬場駅 2 3 ## 5 七志らーめん 渋谷道玄坂店 渋谷駅 7 4.5 ## 6 永楽 京成小岩駅 6 4.42 ## 7 よってこや お台場店 お台場海浜公園駅 1 4 ## 8 ラーメン武藤製麺所 竹ノ塚駅 4 3.5 ## 9 桂花ラーメン 新宿末広店 新宿三丁目駅 8 3 ## 10 北斗 新橋店 新橋駅 4 2.5 ## # … with 1,124 more rows これで口コミ評価が登録された店舗に絞ることができました。 続いて、複数の条件を持つケースを考えてみましょう。例えば、「京都府内の店舗で、口コミ評価が3.5以上の店舗」を出力したい場合、以下のようなコードとなります。 df %&gt;% filter(Pref == &quot;京都府&quot;, Score &gt;= 3.5) %&gt;% select(Name, Station, ScoreN, Score) ## # A tibble: 53 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 無尽蔵 京都八条家 京都駅 2 3.5 ## 2 一蘭 京都河原町店 河原町駅 2 3.75 ## 3 ミスター・ギョーザ 西大路駅 8 4.06 ## 4 一蘭 京都八幡店 樟葉駅 3 4 ## 5 中華料理 清華園 京都駅 3 5 ## 6 まがり &lt;NA&gt; 2 4 ## 7 魁力屋 北山店 北大路駅 2 4.25 ## 8 大中BAL横店 &lt;NA&gt; 7 4.1 ## 9 こうちゃん 西舞鶴駅 1 5 ## 10 大黒ラーメン 伏見桃山駅 4 4.25 ## # … with 43 more rows 条件をfilter()内に追加するだけです。今回は!is.na(Score)は不要です。なぜなら、Score &gt;= 3.5という条件で既に欠損値は対象外になるからです。条件文が複数ある場合、ANDかORかを指定する必要があります。つまり、条件文AとBがある場合、「AとB両方満たすものを出力する」か「AとBどちらかを満たすものを出力するか」を指定する必要があります。今の結果ってANDでしたよね。filter()関数は、別途の指定がない場合、全てAND扱いになります。RのAND演算子は&amp;ですので、以上のコードは以下のコードと同じです。 df %&gt;% filter(Pref == &quot;京都府&quot; &amp; Score &gt;= 3.5) %&gt;% select(Name, Station, ScoreN, Score) ## # A tibble: 53 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 無尽蔵 京都八条家 京都駅 2 3.5 ## 2 一蘭 京都河原町店 河原町駅 2 3.75 ## 3 ミスター・ギョーザ 西大路駅 8 4.06 ## 4 一蘭 京都八幡店 樟葉駅 3 4 ## 5 中華料理 清華園 京都駅 3 5 ## 6 まがり &lt;NA&gt; 2 4 ## 7 魁力屋 北山店 北大路駅 2 4.25 ## 8 大中BAL横店 &lt;NA&gt; 7 4.1 ## 9 こうちゃん 西舞鶴駅 1 5 ## 10 大黒ラーメン 伏見桃山駅 4 4.25 ## # … with 43 more rows AND演算子 (&amp;)が使えるということはOR演算子 (|)も使えることを意味します。たとえば、Stationが\"高田馬場駅\"か\"三田駅\"の条件を指定したい場合、 df %&gt;% filter(Station == &quot;高田馬場駅&quot; | Station == &quot;三田駅&quot;) %&gt;% select(Name, Station, ScoreN, Score) ## # A tibble: 14 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 麺達 うま家 高田馬場駅 2 3 ## 2 らぁ麺 やまぐち 高田馬場駅 7 4.08 ## 3 博多一瑞亭 三田店 三田駅 0 NA ## 4 つけ麺屋 ひまわり 高田馬場駅 4 2.75 ## 5 石器ラーメン 高田馬場 高田馬場駅 0 NA ## 6 旨辛らーめん 表裏 高田馬場駅 0 NA ## 7 三歩一 高田馬場駅 8 4.56 ## 8 えぞ菊 戸塚店 高田馬場駅 4 3.62 ## 9 麺屋 宗 高田馬場駅 5 4.2 ## 10 とんこつラーメン 博多風龍 高田馬場店 高田馬場駅 2 3 ## 11 横浜家系ラーメン 馬場壱家 高田馬場駅 0 NA ## 12 らーめん よし丸 高田馬場駅 1 5 ## 13 札幌ラーメン どさん子 三田店 三田駅 0 NA ## 14 天下一品 三田店 三田駅 0 NA のように書きます（ちなみに高田馬場の「やまぐち」は本当に美味しいです）。むろん、複数の変数を用いたORも可能です。たとえば、「Prefが\"京都府\"かScoreが3以上」のような条件も可能ですが (Pref == \"京都府\" | Score &gt;= 3)、実際、このような例はあまりありません。よく使うのは「変数Xがaかbかcか」のような例です。ただし、この場合は|を使わないもっと簡単な方法があります。それは第9.4章で紹介した%in%演算子です。以下のコードは上のコードと同じものです。 df %&gt;% filter(Station %in% c(&quot;高田馬場駅&quot;, &quot;三田駅&quot;)) %&gt;% select(Name, Station, ScoreN, Score) ## # A tibble: 14 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 麺達 うま家 高田馬場駅 2 3 ## 2 らぁ麺 やまぐち 高田馬場駅 7 4.08 ## 3 博多一瑞亭 三田店 三田駅 0 NA ## 4 つけ麺屋 ひまわり 高田馬場駅 4 2.75 ## 5 石器ラーメン 高田馬場 高田馬場駅 0 NA ## 6 旨辛らーめん 表裏 高田馬場駅 0 NA ## 7 三歩一 高田馬場駅 8 4.56 ## 8 えぞ菊 戸塚店 高田馬場駅 4 3.62 ## 9 麺屋 宗 高田馬場駅 5 4.2 ## 10 とんこつラーメン 博多風龍 高田馬場店 高田馬場駅 2 3 ## 11 横浜家系ラーメン 馬場壱家 高田馬場駅 0 NA ## 12 らーめん よし丸 高田馬場駅 1 5 ## 13 札幌ラーメン どさん子 三田店 三田駅 0 NA ## 14 天下一品 三田店 三田駅 0 NA 結局、|が使われるケースがかなり限定されます。あるとすれば、「変数Xがa以下か、b以上か」のようなケースですね。ただし、&amp;と|を同時に使うケースは考えられます。たとえば、大阪駅と京都駅周辺のうまいラーメン屋を調べるとします。問題は美味しさの基準ですが、3.5点以上としましょう。ただし、京都府民はラーメンに非常に厳しく、3点以上なら美味しいと仮定します。この場合、「(Stationが\"大阪駅\"かつScore &gt;= 3.5)、または(Stationが\"京都駅\"かつScore &gt;= 3)」のような条件が必要になります。()は「()の中から判定せよ」という、普通の算数での使い方と同じです。それでは、実際に検索してみましょう。 df %&gt;% filter((Station == &quot;大阪駅&quot; &amp; Score &gt;= 3.5) | (Station == &quot;京都駅&quot; &amp; Score &gt;= 3)) %&gt;% select(Name, Station, Walk, ScoreN, Score) ## # A tibble: 6 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Lei can ting 大阪ルクア店 大阪駅 3 3 4 ## 2 神座 ルクア大阪店 大阪駅 1 10 3.94 ## 3 みつか坊主 醸 大阪駅 10 4 5 ## 4 無尽蔵 京都八条家 京都駅 5 2 3.5 ## 5 中華料理 清華園 京都駅 10 3 5 ## 6 ますたに 京都拉麺小路店 京都駅 9 3 3.67 Songが大好きな神座がヒットして嬉しいです。 10.5 行のソート 続いて、行のソートについて解説します。「食べログ」などのレビューサービスを利用する場合、口コミ評価が高い順で見るのが一般的でしょう2。また、サッカーのランキングも多くは1位から下の順位で掲載されるのが一般的です。ここではこのようにある変数の値順に行を並び替える方法について説明します。 ソートにはdplyrパッケージのarrange()関数を使います。引数は変数名のみです。たとえば、奈良県のラーメン屋を検索してみましょう。並び替える順は駅から近い店舗を上位に、遠い店舗を下位に並べます。このような順は昇順 (ascending)と呼ばれ、ランキング表などでよく見ます。駅から近い順にソートするので、まず最寄りの駅情報が欠損でないことが必要です。また、ラーメン屋の評価も気になるので口コミが1つ以上付いている店舗に絞りましょう。表示する列は店舗名、最寄りの駅、徒歩距離、口コミ数、点数です。 df %&gt;% filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;% select(Name, Station, Walk, ScoreN, Score) %&gt;% arrange(Walk) %&gt;% print(n = Inf) ## # A tibble: 24 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 麺屋 あまのじゃく 本店 富雄駅 2 2 4.5 ## 2 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅 4 1 4 ## 3 ラーメン家 みつ葉 富雄駅 4 1 3.5 ## 4 天下一品 新大宮店 新大宮駅 6 1 3 ## 5 麺屋 一徳 天理駅 7 1 3 ## 6 丸源ラーメン 橿原店 金橋駅 8 1 3.5 ## 7 らーめん食堂 よってこや 平群店 元山上口駅 10 1 4 ## 8 天理スタミナラーメン本店 櫟本駅 11 2 3.25 ## 9 博多長浜らーめん夢街道 奈良土橋店 真菅駅 11 1 3.5 ## 10 ぶ～け 奈良駅 11 1 5 ## 11 つけめん らーめん元喜神 押熊店 学研奈良登美ヶ丘駅 12 4 4.12 ## 12 彩華ラーメン 本店 前栽駅 12 5 3.6 ## 13 力皇 天理駅 13 1 3.5 ## 14 らーめん きみちゃん 京終駅 14 2 4.5 ## 15 無鉄砲がむしゃら 帯解駅 15 2 4 ## 16 彩華ラーメン 田原本店 石見駅 15 1 4 ## 17 神座 大和高田店 大和高田駅 17 2 3.75 ## 18 彩華ラーメン 奈良店 尼ヶ辻駅 17 3 4.33 ## 19 彩華ラーメン 桜井店 大福駅 18 1 3 ## 20 天下一品 東生駒店 東生駒駅 19 1 3.5 ## 21 まりお流ラーメン 新大宮駅 20 1 5 ## 22 どうとんぼり神座 奈良柏木店 西ノ京駅 22 1 3 ## 23 河童ラーメン本舗 押熊店 学研奈良登美ヶ丘駅 28 1 4 ## 24 博多長浜らーめん 夢街道 四条大路店 新大宮駅 29 4 2.88 3行まではこれまで習ってきたもので、4行目がソートの関数、arrange()です。引数はソートの基準となる変数で、今回は最寄りの駅からの徒歩距離を表すWalkです。5行目は省略可能ですが、tibbleクラスの場合、10行までしか出力されないので、print(n = Inf)で「すべての行を表示」させます。nを指定することで出力される行数が調整可能です。奈良県のラーメン屋の中で最寄りの駅から最も近い店は「麺屋 あまのじゃく 本店」で徒歩2分でした。京田辺店も駅から約2分ですし、近いですね。ちなみにSongはここの塩とんこつが好きです。世界一こってりなラーメンとも言われる「チョモランマ」で有名な「まりお流ラーメン」は新大宮駅から徒歩20分でかなり遠いことが分かります。 続いて、駅からの距離ではなく、評価が高い順にしてみましょう。評価が高いほど上に来るので、今回は昇順でなく、降順 (descending)でソートする必要があります。arrange()関数は基本的に、指定された変数を基準に昇順でソートします。降順にするためにはdesc()関数を更に用います。たとえば、arrange(desc(変数名))のようにです。それでは実際にやってみましょう。上のコードの4行目をarange(Walk)からarrange(desc(Score))にちょっと修正するだけです。 df %&gt;% filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;% select(Name, Station, Walk, ScoreN, Score) %&gt;% arrange(desc(Score)) %&gt;% print(n = Inf) ## # A tibble: 24 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 まりお流ラーメン 新大宮駅 20 1 5 ## 2 ぶ～け 奈良駅 11 1 5 ## 3 麺屋 あまのじゃく 本店 富雄駅 2 2 4.5 ## 4 らーめん きみちゃん 京終駅 14 2 4.5 ## 5 彩華ラーメン 奈良店 尼ヶ辻駅 17 3 4.33 ## 6 つけめん らーめん元喜神 押熊店 学研奈良登美ヶ丘駅 12 4 4.12 ## 7 河童ラーメン本舗 押熊店 学研奈良登美ヶ丘駅 28 1 4 ## 8 無鉄砲がむしゃら 帯解駅 15 2 4 ## 9 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅 4 1 4 ## 10 彩華ラーメン 田原本店 石見駅 15 1 4 ## 11 らーめん食堂 よってこや 平群店 元山上口駅 10 1 4 ## 12 神座 大和高田店 大和高田駅 17 2 3.75 ## 13 彩華ラーメン 本店 前栽駅 12 5 3.6 ## 14 天下一品 東生駒店 東生駒駅 19 1 3.5 ## 15 力皇 天理駅 13 1 3.5 ## 16 博多長浜らーめん夢街道 奈良土橋店 真菅駅 11 1 3.5 ## 17 ラーメン家 みつ葉 富雄駅 4 1 3.5 ## 18 丸源ラーメン 橿原店 金橋駅 8 1 3.5 ## 19 天理スタミナラーメン本店 櫟本駅 11 2 3.25 ## 20 麺屋 一徳 天理駅 7 1 3 ## 21 どうとんぼり神座 奈良柏木店 西ノ京駅 22 1 3 ## 22 彩華ラーメン 桜井店 大福駅 18 1 3 ## 23 天下一品 新大宮店 新大宮駅 6 1 3 ## 24 博多長浜らーめん 夢街道 四条大路店 新大宮駅 29 4 2.88 よく考えてみれば、「評価が同点の場合、どうなるの?」と疑問を抱く方がいるかも知れません。たとえば、7行目の「河童ラーメン本舗 押熊店」と8行目の「無鉄砲がむしゃら」はどれも評価が4点ですが、「河童ラーメン本舗 押熊店」が先に表示されます。そのこれは簡単です。同点の場合、データセット内で上に位置する行が先に表示されます。これを確認するにはwhich()関数を使います。()内に条件文を指定することで、この条件に合致する要素の位置を返します。もし、条件に合致するものが複数あった場合は全ての位置を返します3。 which(df$Name == &quot;河童ラーメン本舗 押熊店&quot;) ## [1] 6021 which(df$Name == &quot;無鉄砲がむしゃら&quot;) ## [1] 6040 データ内に「河童ラーメン本舗 押熊店」がより上に位置することが分かります。「もし同点なら口コミ評価数が多いところにしたい」場合はどうすれば良いでしょうか。これはarrange()内に変数名を足すだけで十分です。 df %&gt;% filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;% select(Name, Station, Walk, ScoreN, Score) %&gt;% arrange(desc(Score), desc(ScoreN)) %&gt;% print(n = Inf) ## # A tibble: 24 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 まりお流ラーメン 新大宮駅 20 1 5 ## 2 ぶ～け 奈良駅 11 1 5 ## 3 麺屋 あまのじゃく 本店 富雄駅 2 2 4.5 ## 4 らーめん きみちゃん 京終駅 14 2 4.5 ## 5 彩華ラーメン 奈良店 尼ヶ辻駅 17 3 4.33 ## 6 つけめん らーめん元喜神 押熊店 学研奈良登美ヶ丘駅 12 4 4.12 ## 7 無鉄砲がむしゃら 帯解駅 15 2 4 ## 8 河童ラーメン本舗 押熊店 学研奈良登美ヶ丘駅 28 1 4 ## 9 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅 4 1 4 ## 10 彩華ラーメン 田原本店 石見駅 15 1 4 ## 11 らーめん食堂 よってこや 平群店 元山上口駅 10 1 4 ## 12 神座 大和高田店 大和高田駅 17 2 3.75 ## 13 彩華ラーメン 本店 前栽駅 12 5 3.6 ## 14 天下一品 東生駒店 東生駒駅 19 1 3.5 ## 15 力皇 天理駅 13 1 3.5 ## 16 博多長浜らーめん夢街道 奈良土橋店 真菅駅 11 1 3.5 ## 17 ラーメン家 みつ葉 富雄駅 4 1 3.5 ## 18 丸源ラーメン 橿原店 金橋駅 8 1 3.5 ## 19 天理スタミナラーメン本店 櫟本駅 11 2 3.25 ## 20 麺屋 一徳 天理駅 7 1 3 ## 21 どうとんぼり神座 奈良柏木店 西ノ京駅 22 1 3 ## 22 彩華ラーメン 桜井店 大福駅 18 1 3 ## 23 天下一品 新大宮店 新大宮駅 6 1 3 ## 24 博多長浜らーめん 夢街道 四条大路店 新大宮駅 29 4 2.88 ソートの基準はarrange()内において先に指定された変数の順番となります。「口コミ評価も評価数も同じなら、駅から近いところにしたい」場合は変数が3つとなり、Score、ScoreN、Walkの順で入れます。 df %&gt;% filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;% select(Name, Station, Walk, ScoreN, Score) %&gt;% arrange(desc(Score), desc(ScoreN), Walk) %&gt;% print(n = Inf) ## # A tibble: 24 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ぶ～け 奈良駅 11 1 5 ## 2 まりお流ラーメン 新大宮駅 20 1 5 ## 3 麺屋 あまのじゃく 本店 富雄駅 2 2 4.5 ## 4 らーめん きみちゃん 京終駅 14 2 4.5 ## 5 彩華ラーメン 奈良店 尼ヶ辻駅 17 3 4.33 ## 6 つけめん らーめん元喜神 押熊店 学研奈良登美ヶ丘駅 12 4 4.12 ## 7 無鉄砲がむしゃら 帯解駅 15 2 4 ## 8 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅 4 1 4 ## 9 らーめん食堂 よってこや 平群店 元山上口駅 10 1 4 ## 10 彩華ラーメン 田原本店 石見駅 15 1 4 ## 11 河童ラーメン本舗 押熊店 学研奈良登美ヶ丘駅 28 1 4 ## 12 神座 大和高田店 大和高田駅 17 2 3.75 ## 13 彩華ラーメン 本店 前栽駅 12 5 3.6 ## 14 ラーメン家 みつ葉 富雄駅 4 1 3.5 ## 15 丸源ラーメン 橿原店 金橋駅 8 1 3.5 ## 16 博多長浜らーめん夢街道 奈良土橋店 真菅駅 11 1 3.5 ## 17 力皇 天理駅 13 1 3.5 ## 18 天下一品 東生駒店 東生駒駅 19 1 3.5 ## 19 天理スタミナラーメン本店 櫟本駅 11 2 3.25 ## 20 天下一品 新大宮店 新大宮駅 6 1 3 ## 21 麺屋 一徳 天理駅 7 1 3 ## 22 彩華ラーメン 桜井店 大福駅 18 1 3 ## 23 どうとんぼり神座 奈良柏木店 西ノ京駅 22 1 3 ## 24 博多長浜らーめん 夢街道 四条大路店 新大宮駅 29 4 2.88 10.6 練習問題 実はselect(starts_with(\"X\"), -ends_with(\"D\"), ID)のように順番を変えるとIDは最後の列になりますが、とりあえず残ります。なぜなら、select()関数は左側から右側の方へコードを実行するからです。↩︎ サービスによってはこの機能が有料になっていたりもしますね。↩︎ たとえば、データ内に「ラーメンショップ」という店舗は3店舗あり、この場合、長さ3のベクトルが返されます。↩︎ "]
]
