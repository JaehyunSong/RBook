[["monte.html", "29. モンテカルロシミュレーション 29.1 モンテカルロシミュレーションとは 29.2 乱数生成 29.3 例: 誕生日問題 29.4 応用: 円周率 29.5 応用: ブートストラッピング法による標準誤差の推定", " 29. モンテカルロシミュレーション 29.1 モンテカルロシミュレーションとは pacman::p_load(tidyverse, ggforce) 29.2 乱数生成 29.2.1 sample()によるサンプリング 無作為に値を抽出する方法には2つが考えられます。一つは値の集合から無作為に値を抽出する方法、もう一つは正規分布などの確率分布から値を抽出する方法です。ここではまずsample()関数を用い、値の集合から無作為に値を抽出する方法について説明します。 sample(x = 値の集合ベクトル, size = 抽出の回数, replace = 復元抽出の有無, prob = 各要素が抽出される確率) replaceは復元抽出の有無を指定する引数であり、既定値はFALSE、つまり非復元抽出がデフォルトとなっています。これは一度抽出された要素は、二度と抽出されないことを意味します。値の集合が{0, 1}で、5個の値を抽出する（=sizeがxの長さより大きい）ならば、replaceは必ずTRUEに設定する必要があります。抽選などは非復元抽出であるため、replace引数は省略可能です。しかし、対数の法則やブートストラップなどは復元抽出を仮定している場合が多く、意識的にreplace関数は指定することを推奨します。probは各要素が抽出される確率を意味し、xの実引数と同じ長さのnumeric型ベクトルを指定します。probの実引数の総和は1であることが望ましいですが、総和が1でない場合、自動的に総和が1になるよう正則化を行います。つまり、c(1, 3)はc(0.25, 0.75)と同じことを意味します。 サイコロを3回振るコードを書くなら、値の集合（x）はc(1, 2, 3, 4, 5, 6)、または1:6で、抽出の回数（size）は3となります。また、一回出た目も抽出される可能性があるため、復元抽出を行う必要があります（replace = TRUE）。そして各目が出る確率は1/6ですが、各値が抽出される確率が等しい場合、省略可能です。 # この場合、prob引数は省略可能 sample(1:6, 3, replace = TRUE, prob = rep(1/6, 6)) ## [1] 1 6 3 今回はサイコロを1万回振り、それぞれの目が出た回数を棒グラフとして示してみます。無作為に抽出された値であれば、各目が出る回数は等しいはずです。ベクトルに対してtable()関数を使うと、各要素が出現した回数が出力され、このオブジェクトをbarplot()関数に渡すと棒グラフを作成することができます。 Dice_vec &lt;- sample(1:6, 10^4, replace = TRUE) table(Dice_vec) %&gt;% barplot() 1から6までの目が出た回数がほぼ同じであることが確認できます。この6つの棒の高さがすべて同じになることはありえませんが（そもそも1万を6で割ったら余りが出ますね）、ほぼ同じ割合であることから、疑似乱数とは言え、シミュレーション用としては十分でしょう。 29.2.2 確率分布からの乱数制制 関数名 確率分布 パラメーター rbeta() ベータ分布 n, shape1, shape2 rbinom() 二項分布 n, size, prob rcauchy() コーシー分布 n, location, scale rchisq() \\(\\chi^2\\)分布 n, df rexp() 指数分布 n, rate rf() \\(F\\)分布 n, df1, df2 rgamma() ガンマ分布 n, shape, scale rgeom() 幾何分布 n, prob rhyper() 超幾何分布 nn, m, n, k rlnorm() 対数正規分布 n, meanlog, sdlog rmultinom() 多項分布 n, size, prob rnbinom() 負の二項分布 n, size, prob rnorm() 正規分布 n, mean, sd rpois() ポアソン分布 n, lambda rt() t分布 n, df runif() 一様分布 n, min, max rweibull() ワイブル分布 n, shape, scale mvtnorm::rmvnorm() 多変量正規分布 n, mean, sigma 以上の表に掲載されているパラメーター以外にも指定可能なパラメーターがあるため、詳細は各関数のヘルプを参照してください。たとえば、ガンマ分布の場合、rateで、負の二項分布の場合、muで分布の形状を指定することができます。また、多変量正規分布の乱数を抽出するには{mvtnorm}パッケージのrmvnorm()を使いますが、ここでのmeanは数値型ベクトル、sigmaは行列構造の分散共分散行列を使います1。 29.2.3 シードについて 特定の分布から乱数を抽出する場合、当たり前ですが、抽出の度に値が変わります。たとえば、平均0、標準偏差1の正規分布（標準正規分布）から5つの値を抽出し、小数点3桁に丸める作業を3回繰り返しみましょう。 rnorm(5) %&gt;% round(3) ## [1] -1.411 -0.728 -0.109 0.153 0.424 rnorm(5) %&gt;% round(3) ## [1] -1.668 0.087 0.031 1.153 -0.540 rnorm(5) %&gt;% round(3) ## [1] -0.211 -1.642 0.305 -1.064 0.423 このように、抽出の度に結果が変わります。1回きりのシミュレーションではこれで問題ないでしょうが、同じシミュレーションから同じ結果を得るためには、乱数を固定する必要があります。そこで使うのがシード（seed）です。シードが同じなら抽出される乱数は同じ値を取ります。シードの指定はset.seed(numeric型スカラー)です。たとえば、シードを19861009にし、同じ作業をやってみましょう。 set.seed(19861008) rnorm(5) %&gt;% round(3) ## [1] -0.086 0.396 -1.330 0.574 0.152 rnorm(5) %&gt;% round(3) ## [1] 0.555 0.620 -1.133 0.572 0.900 シードを指定しても2つのベクトルは異なる値を取りますが、もう一度シードを指定してから乱数抽出をしてみましょう。 set.seed(19861008) rnorm(5) %&gt;% round(3) ## [1] -0.086 0.396 -1.330 0.574 0.152 先ほどのコードでシードを指定した直後に抽出した乱数と同じ乱数が得られました。モンテカルロ・シミュレーションにおいて乱数は非常に重要ですが、これはシミュレーションの度に異なる結果が得られることを意味します。つまり、自分が書いたコードから100%同じ結果が得られないだけでなく、自分も同じ結果を再現できないことを意味します。この場合、シードを指定すると乱数が固定され、シミュレーション結果の再現ができるようになります。 一つ注意すべき点は乱数を固定した後、複数回抽出を繰り返す場合、その順番も固定されるという点です。たとえば、シードを固定せずにもう一回5つの値を抽出してみましょう。 rnorm(5) %&gt;% round(3) ## [1] 0.555 0.620 -1.133 0.572 0.900 この結果は先ほどシード指定後、2回目の抽出結果と同じ結果となります。結果を再現するという点では大きな問題はないはずですが、仕様を理解しておくことは重要でしょう。 29.3 例: 誕生日問題 n_student &lt;- 30 Birth_vec &lt;- sample(1:365, n_student, replace = TRUE) any(duplicated(Birth_vec)) ## [1] TRUE n_student &lt;- 30 n_trials &lt;- 10000 Result_vec &lt;- rep(NA, n_trials) for (i in 1:n_trials) { Birth_vec &lt;- sample(1:365, n_student, replace = TRUE) Result_vec[i] &lt;- any(duplicated(Birth_vec)) } mean(Result_vec) ## [1] 0.6996 n_trials &lt;- 100 Prob_df &lt;- tibble(Students = 2:100, Probs = NA) for (i in 1:nrow(Prob_df)) { Result_vec &lt;- rep(NA, n_trials) for (j in 1:n_trials) { Birth_vec &lt;- sample(1:365, Prob_df$Students[i], replace = TRUE) Result_vec[j] &lt;- any(duplicated(Birth_vec)) } Prob_df$Probs[i] &lt;- mean(Result_vec) } Prob_df ## # A tibble: 99 × 2 ## Students Probs ## &lt;int&gt; &lt;dbl&gt; ## 1 2 0 ## 2 3 0.03 ## 3 4 0.01 ## 4 5 0.05 ## 5 6 0.07 ## 6 7 0.1 ## 7 8 0.08 ## 8 9 0.08 ## 9 10 0.15 ## 10 11 0.17 ## # … with 89 more rows Prob_df %&gt;% ggplot() + geom_line(aes(x = Students, y = Probs), size = 1) + labs(x = &quot;Number of Students&quot;, y = &quot;Probability two students have the same birthday&quot;) + theme_bw() 1 - (factorial(365) / (factorial(365 - 30) * 365^(30))) ## [1] NaN 1 - (choose(365, 365 - 30) * factorial(30) / 365^30) ## [1] 0.7063162 Prob_df$Expectation &lt;- 1 - (choose(365, 365 - Prob_df$Students) * factorial(Prob_df$Students) / 365^Prob_df$Students) Prob_df %&gt;% pivot_longer(cols = Probs:Expectation, names_to = &quot;Type&quot;, values_to = &quot;Prob&quot;) %&gt;% mutate(Type = ifelse(Type == &quot;Probs&quot;, &quot;Simulation&quot;, &quot;Theoretical&quot;)) %&gt;% ggplot() + geom_line(aes(x = Students, y = Prob, color = Type), size = 1) + labs(x = &quot;Number of Students&quot;, y = &quot;Probability two students have the same birthday&quot;) + theme_bw() n_trials &lt;- 10000 Prob_df &lt;- tibble(Students = 2:100, Probs = NA) for (i in 1:nrow(Prob_df)) { Result_vec &lt;- rep(NA, n_trials) for (j in 1:n_trials) { Birth_vec &lt;- sample(1:365, Prob_df$Students[i], replace = TRUE) Result_vec[j] &lt;- any(duplicated(Birth_vec)) } Prob_df$Probs[i] &lt;- mean(Result_vec) } Prob_df$Expectation &lt;- 1 - (choose(365, 365 - Prob_df$Students) * factorial(Prob_df$Students) / 365^Prob_df$Students) Prob_df %&gt;% pivot_longer(cols = Probs:Expectation, names_to = &quot;Type&quot;, values_to = &quot;Prob&quot;) %&gt;% mutate(Type = ifelse(Type == &quot;Probs&quot;, &quot;Simulation&quot;, &quot;Theoretical&quot;)) %&gt;% ggplot() + geom_line(aes(x = Students, y = Prob, color = Type), size = 1) + labs(x = &quot;Number of Students&quot;, y = &quot;Probability two students have the same birthday&quot;) + theme_bw() 29.4 応用: 円周率 set.seed(19861009) pi_df &lt;- tibble(x = runif(100, -1, 1), y = runif(100, -1, 1)) pi_df &lt;- pi_df %&gt;% mutate(in_circle = if_else(x^2 + y^2 &lt; 1, &quot;In Circle&quot;, &quot;Out of Circle&quot;)) pi_df %&gt;% ggplot() + geom_point(aes(x = x, y = y, color = in_circle)) + geom_circle(aes(x0 = 0, y0 = 0, r = 1), inherit.aes = FALSE) + labs(x = &quot;X&quot;, y = &quot;Y&quot;, color = &quot;&quot;) + coord_fixed(ratio = 1) + theme_bw(base_size = 12) pi_df %&gt;% group_by(in_circle) %&gt;% summarise(N = n()) ## # A tibble: 2 × 2 ## in_circle N ## &lt;chr&gt; &lt;int&gt; ## 1 In Circle 82 ## 2 Out of Circle 18 # 円の面積は4 * 0.82 = 3.28 # 円の面積は半径^2 * piなので、piは 3.28 / (1^2) ## [1] 3.28 set.seed(19861009) pi_df2 &lt;- tibble(x = runif(10000, -1, 1), y = runif(10000, -1, 1)) pi_df2 &lt;- pi_df2 %&gt;% mutate(in_circle = if_else(x^2 + y^2 &lt; 1, &quot;In Circle&quot;, &quot;Out of Circle&quot;)) pi_df2 %&gt;% ggplot() + geom_point(aes(x = x, y = y, color = in_circle)) + geom_circle(aes(x0 = 0, y0 = 0, r = 1), inherit.aes = FALSE) + labs(x = &quot;X&quot;, y = &quot;Y&quot;, color = &quot;&quot;) + coord_fixed(ratio = 1) + theme_bw(base_size = 12) pi_df2 %&gt;% group_by(in_circle) %&gt;% summarise(N = n()) ## # A tibble: 2 × 2 ## in_circle N ## &lt;chr&gt; &lt;int&gt; ## 1 In Circle 7859 ## 2 Out of Circle 2141 # 円の面積は4 * 0.7859 = 3.1436 # 円の面積は半径^2 * piなので、piは 3.1436 / 1^2 ## [1] 3.1436 # 実際の円周率は3.141593... 29.5 応用: ブートストラッピング法による標準誤差の推定 sigmaは数値型ベクトル（meanの実引数の長さと同じ長さ）で指定することも可能ですが、この場合、共分散は0になります。↩︎ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
