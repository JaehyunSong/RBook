[["index.html", "私たちのR: ベストプラクティスの探究 1. 紹介 1.1 進捗状況 1.2 本書の目的と対象 1.3 著者紹介 1.4 データのダウンロード 1.5 本書における表記法 1.6 著作権", " 私たちのR: ベストプラクティスの探究 宋財泫 (Jaehyun Song)・矢内勇生 (Yuki Yanai) 最終修正: 2021-01-11 1. 紹介 1.1 進捗状況 章立ては未定。著者が書きたいものから書く予定。 全部で30~35章くらいになる見込み。 章 タイトル 進捗状況 (%) 備考 1 紹介 0 2 R? 75 3 Rのインストール 0 再執筆予定 4 IDEの導入 0 再執筆予定 5 分析環境のカスタマイズ 0 6 分析の手順 0 7 基本的な操作 80 8 データの入出力 70 9 データ型 90 10 データ構造 80 11 Rプログラミングの基礎 85 12 関数の自作 50 13 データハンドリング [基礎編: 抽出] 95 14 データハンドリング [基礎編: 拡張] 95 15 データハンドリング [基礎編: factor型] 90 16 整然データ構造 85 17 可視化[理論] 85 18 可視化[基礎] 85 19 可視化[応用] 85 20 可視化[発展] 0 21 データハンドリング [応用編] 0 22 文字列の処理 0 23 スクレイピング 0 24 反復処理 40 25 R Markdown [基礎] 85 26 R Markdown [応用] 0 99 モデルの可視化 0 99 API 0 99 線形代数 5 99 最適化 5 99 モンテカルロシミュレーション 5 99 MCMC 0 99 オブジェクト指向プログラミング 0 1.2 本書の目的と対象 『私たちのR』はSONG Jaehyun と 矢内勇生 が共同で執筆するRプログラミングの「入門書」である。統計学の本ではない。 また、本書はデータ分析の手法の解説書でもない。Rを用いたデータ分析については他の本を参照されたい。私たちが専門とする政治学におけるデータ分析については、以下の本を勧める。 浅野正彦, 矢内勇生. 2018. 『Rによる計量政治学』オーム社. 飯田健. 2013.『計量政治分析』共立出版. 今井耕介（粕谷裕子, 原田勝孝, 久保浩樹 訳）2018.『社会科学のためのデータ分析入門（上）（下）』岩波書店. 本書が想定するのは、次のような希望をもつ読者である。 分析に入るまでの段階、つまりデータの入手やクリーニング方法が知りたい 分析結果を自分の思いどおりに可視化したい 複数のモデルを効率的に分析したい Rでシミュレーションがしたい Rと友達になりたい 本書を読んでも統計学やデータ分析を理解することはできない。本書の目的は、統計学やデータ分析についての知識を持った方々と、Rを使ってもっと効率的にデータ分析をする方法を共有することである。また、統計学やデータ分析を勉強する際に、プログラミングについての副読本として読むことも想定している。 本書を読み終える頃には、Rなしでは生活できなくなっていることだろう。 本書の執筆環境については第28 節を参照されたい。 1.3 著者紹介 図 1.1: 事例研究をこよなく愛する著者 (Portland, OR. 2016年2月) Song Jaehyun（宋 財泫 [ソン ジェヒョン]; 写真左）はR黒帯の大学教員。猫好き。 主な著書：真に驚くべき業績を残しているが、この余白はそれを書くには狭すぎる。 公開したRパッケージ: BalanceR, PRcalc, SimpleConjoint など Email: jasong@mail.doshisha.ac.jp Webpage: https://www.jaysong.net Twitter: @Tintstyle GitHub: https://github.com/JaehyunSong 矢内勇生（やない ゆうき; 写真右）はR歴15年の大学教員。猫好き。主な著書：『Rによる計量政治学』（共著, オーム社, 2018年）, 『政治経済学』（共著, 有斐閣, 2020年） 公開したRパッケージ：rgamer Email: yanai.yuki@kochi-tech.ac.jp Webpage: https://yukiyanai.github.io Twitter: @yuki871 GitHub: https://github.com/yukiyanai 1.4 データのダウンロード 本書のデータは全て筆者の GitHub レポジトリーから入手可能である。データは以下の手順でダウンロードできる。 本書のGitHubレポジトリー にアクセスする。 レポジトリーURL: https://github.com/JaehyunSong/RBook dataフォルダーを選択する。 ダウンロードするファイル名を選択する。 「Raw」を右クリックし、「Save Linked Contents As…」を選択する。 保存するフォルダーを指定して、ダウンロードする。 1.5 本書における表記法 コードは以下のように網掛けになっている箇所である。 print(&quot;Hello!&quot;) コードの中で#で始まる内容はコメントであり、分析に影響を与えない。ただし、\"や'で囲まれた#はコメントではない。また、行の途中から#が入る場合、#以降は実行されない。 # Hello!を出力するコード print(&quot;Hello!&quot;) # &quot;や&#39;内の#はコメントではない print(&quot;この#はコメントではありません&quot;) print(&quot;Hello World!&quot;) # Hellow World!を出力 出力結果は網掛け、かつ##で始まる箇所である。 ## [1] &quot;Hello!&quot; オブジェクト名は変数名や関数名()のように文中の網掛け領域である。 パッケージ名は{}で囲む。tidyverseパッケージの場合、{tidyverse}と表記する。 1.6 著作権 本著作物は クリエイティブ・コモンズ 表示-非営利-改変禁止 4.0国際ライセンスの下に提供されています。 "],["aboutR.html", "2. R? 2.1 Rとは 2.2 Why R? 2.3 GUIとIDE", " 2. R? 2.1 Rとは 図 2.1: R Logo Rは統計、データ分析、作図のためのインタープリタープログラミング言語である。Rという名前は二人の開発者 Ross Ihaka と Robert Clifford Gentleman のイニシャルに由来する。R言語は完全にゼロベースから開発されたものではなく、1976年に開発されたS言語に起源をもつ。S言語もR言語同様、統計やデータ分析に特化した言語であり、S言語の開発が中止された現在、RはSの正当な後継者であると言ってよいだろう。 R以外にも、統計分析、データ分析が可能なソフトウェアは星の数ほどある。社会科学で定量分析の講義を履修したことがあれば、SPSS や Stata という名前をきいたことがあるだろう。工学系ならMATLAB が有名かもしれない。企業ではSAS という高価なソフトもよく使われる1。 これらのソフト（アプリ）は基本的に有料だが、お金がないとデータ分析のソフトウェアが使えないわけではない。無料でありながら優れたソフトウェアも多く公開されている。以下にその一部を示す。 ソフト・言語名 備考 PSPP SPSSにとてもよく似た無料ソフトウェア。 JASP/jamovi 裏で動いているのはR。詳細は本章の後半で gretl 時系列分析など、計量経済学で利用される手法に特化したソフト。 GNU Octave MATLAB とほぼ同じ文法をもつ無料言語 HAD 清水裕士 先生が開発しているExcelベースのデータ分析マクロ 統計分析に特化したプログラミング言語としてRの競合相手になるのは Julia と Python だろう。Julia言語は一見Rによく似ているが、計算速度が Rより速いと言われている2。ただし、比較的新しい言語であるため、パッケージと解説書がRよりも少ないという難点がある。Pythonは現在のデータサイエンス界隈において、Rとともに最も広く使われている言語である3。Pythonは統計・データ分析に特化した言語ではないが、統計・データ分析のライブラリが非常に充実しており、機械学習（とくに、コンピュータービジョン）ではRよりも広く使われている。Python以外の言語、たとえば C や Java、Ruby、Fortranでも統計・データ分析は可能ある。実際、RやPythonのパッケージの一部はCやJavaで作成されている。ただし、RやPythonに比べると、データ分析の方法を解説したマニュアル・参考書があまりないのがつらいところだ。 2.2 Why R? 私たちRユーザにとっての神であるHadley Wickham（羽鳥先生）は Advanced R (2nd Ed.) で次のように仰せられた。 It’s free, open source, and available on every major platform. As a result, if you do your analysis in R, anyone can easily replicate it, regardless of where they live or how much money they earn. Rは無料で、オープンソースで、多くのプラットフォーム（訳注: macOS, Linux, Windowsなど）で利用できます。よって、あなたがRを使って分析すれば、どこに住んでいるか、いくらお金を稼いでいるかに関係なく、誰でも簡単にその分析を再現できることができます。 R has a diverse and welcoming community, both online (e.g. the #rstats twitter community) and in person (like the many R meetups). Two particularly inspiring community groups are rweekly newsletter which makes it easy to keep up to date with R, and R-Ladies which has made a wonderfully welcoming community for women and other minority genders. オンライン (twitterの#rstatなど)、オフライン (訳注：日本では Tokyo.R が有名。筆者たちが開催している KUT.R もある) の両方で、多様なRコミュニティがあります。他にも最新のRをキャッチアップするためのニュースレターであるrweeklyや、女性や性的マイノリティーにやさしい R-Ladies も活発に活動しています。 A massive set of packages for statistical modelling, machine learning, visualisation, and importing and manipulating data. Whatever model or graphic you’re trying to do, chances are that someone has already tried to do it and you can learn from their efforts. 統計モデリング、機械学習、可視化、データ読み込みおよびハンドリングのための膨大なパッケージが用意されています。どのようなモデルやグラフでも、既に誰かが必ずその実装を試みた可能性が高く、先人らの努力に学ことができます。 Powerful tools for communicating your results. R Markdown makes it easy to turn your results into HTML files, PDFs, Word documents, PowerPoint presentations, dashboards and more. Shiny allows you to make beautiful interactive apps without any knowledge of HTML or javascript. 分析結果を伝達する強力なツールを提供しています。R Makrdownは分析結果をHTML、PDF、Word、PowerPoint、Dashboard 形式に変換してくれます。HTMLや JavaScript の知識がなくても、Shinyを使って美しい対話側のアプリケーションを開発することができます。 RStudio, the IDE, provides an integrated development environment, tailored to the needs of data science, interactive data analysis, and statistical programming. 代表的な統合開発環境であるRStudioはデータサイエンス、対話型のデータ分析、そして統計的プログラミングが必要とするものに最適化されています。 Cutting edge tools. Researchers in statistics and machine learning will often publish an R package to accompany their articles. This means immediate access to the very latest statistical techniques and implementations. Rは最先端のツールです。多くの統計学や機械学習の研究者は自分の研究成果とRパッケージを同時に公開しています。これは最先端の方法を誰よりも早く実施可能にします。 Deep-seated language support for data analysis. This includes features like missing values, data frames, and vectorisation. データ分析を根強くサポートする言語です。欠損値、データフレーム、ベクトル化などがその例です。 A strong foundation of functional programming. The ideas of functional programming are well suited to the challenges of data science, and the R language is functional at heart, and provides many primitives needed for effective functional programming. Rはデータサイエンスに非常に有効である関数型プログラミングのための最適な環境を提供しています。 RStudio, the company, which makes money by selling professional products to teams of R users, and turns around and invests much of that money back into the open source community (over 50% of software engineers at RStudio work on open source projects). I work for RStudio because I fundamentally believe in its mission. 営利企業であるRStudio社ですが、その収益の多くをオープンソースコミュニティーに投資しています。 Powerful metaprogramming facilities. R’s metaprogramming capabilities allow you to write magically succinct and concise functions and provide an excellent environment for designing domain-specific languages like ggplot2, dplyr, data.table, and more. メタプログラミングが強力です。Rが持つメタプログラミング能力はあなたのコードを劇的に簡潔にするだけでなく、統計/データ分析に特化したggplot2、dplyr、data.tableなどの開発も可能にしました。 The ease with which R can connect to high-performance programming languages like C, Fortran, and C++. RはC、C++、Fortranのようなハイパフォーマンス言語と容易に結合できるように設計されています。 しかし、他のプログラミング言語と同様、Rは完璧な言語ではありません。以下はR言語の短所の一部です。その多くはRそのものの問題というよりも、(プログラマーではなく)データ分析の研究者が中心となっているRユーザーから起因する問題です。 Much of the R code you’ll see in the wild is written in haste to solve a pressing problem. As a result, code is not very elegant, fast, or easy to understand. Most users do not revise their code to address these shortcomings. あなたが普段見る多くのRコードは「今の」問題を解決するために迅速に書かれたものです。この場合、コードはあまりエレガントでも、速くも、読みやすくありません。ほとんどのユーザーはこの短所を克服するためのコード修正を行っておりません。 Compared to other programming languages, the R community is more focussed on results than processes. Knowledge of software engineering best practices is patchy. For example, not enough R programmers use source code control or automated testing. 他のプログラミング言語に比べ、Rコミュニティーは過程よりも結果に注目する傾向があります。多くのユーザーにおいて、ソフトウェアエンジニアリングの知識を蓄えるための方法が不完全です。たとえば、(GitHubなどの) コード管理システムや自動化された検証を使用するRプログラマーは多くありません。 Metaprogramming is a double-edged sword. Too many R functions use tricks to reduce the amount of typing at the cost of making code that is hard to understand and that can fail in unexpected ways. Rの長所でもあるメタプログラミングは諸刃の剣です。あまりにも多くのR関数はコーディングのコストを減らすようなトリックを使用しており、その代償としてコードの理解が難しく、予期せぬ失敗の可能性があります。 Inconsistency is rife across contributed packages, and even within base R. You are confronted with over 25 years of evolution every time you use R, and this can make learning R tough because there are so many special cases to remember. 開発されたパッケージは、R内蔵のパッケージさえも一貫性が乏しいです。あなたはRを使う度にこの25年を超えるRの進化に直面することになります。また、Rには覚えておくべきの特殊なケースが多く、これはR学習の妨げとなっています。 R is not a particularly fast programming language, and poorly written R code can be terribly slow. R is also a profligate user of memory. Rは格別に速い言語ではありません。下手に書かれたコードは驚くほど遅いです。また、Rはメモリの浪費が激しい言語と知られています。 2.3 GUIとIDE 2.3.1 GUI CUIとGUI 現在、多くのソフトウェアはGUIを採用している。GUI とは Graphical User Interface の略で、ソフトウェア上の入力および出力にグラフィックを利用する。単純にいうと「マウスでポチポチするだけで操作できる環境」のことだ。一方、Rでは基本的にCUI (Character User Interface) を利用する4。これは全ての操作を文字列ベースで行う、つまりキーボードで行うことを意味する5。 身近な例として、あるラーメン屋での注文（呪文）システムを考えてみよう。無料トッピングを指定するときに「決まった言い方」で指定するのがCUI方式である。一文字でも間違うとオーダーは通りらない。たとえば、「野菜マッシマッシ!」とか「野菜MashMash!」と言ってしまうと、店長さんに「は？」と言われ、周りの客から白い目で見られる6。他方、食券の自動発売機でトッピングを指定できるのがGUI方式だ7。この場合、そもそも間違いは起きない。誰でも簡単に注文できるのがGUI式のメリットだが、自分で注文するものが決まっていて、注文の仕方を知っているなら CUI式のほうが早い。毎回同じ注文をするなら、注文内容を録音しておいて、次回はそれを再生することも可能である。GUI方式では、注文方法を再現するのは難しい。 図 2.2: CUIとGUIの比較 CUIとGUIを比べたとき、一見するとGUIのほうが優れているように見える。マウスでポチポチするだけで操作できるほうが楽に見えるし、間違いの心配もなさそうな気がする。キーボードで長いコマンドを打つCUIよりも、ボタンをクリックしたほうが手早く済みそうにも思える8。そして、CUIのコマンドを覚えるのはしんどい9。 しかし、CUIはCUIなりの長所がある。まず、コードが記録できる。マウスでポチポチした操作は、パソコンの画面全体を録画しない限り記録できない。よって、GUIでは自分の分析プロセスを記録することが難しい。他方、すべてコマンドで操作した場合、入力したコマンドを文字列として記録することは容易である。また、CUIはGUIよりも柔軟である。先ほどのラーメン屋の例で考えると、CUIでは「一応」野菜ちょいマシのような注文（呪文）のカスタマイズもできる10。しかし、GUI（券売機）だと注文の自由なカスタマイズはできない。店が用意したボタンしか押せない（ソフトがメニューに表示しているコマンドしか実行できない）。また、コマンドの入力の時間や暗記も、それほど難しくはない。後で説明するように、Rユーザにとっての超有能な秘書であるRStudio (IDEの1種) がコマンド入力を助けてくれる。スペルが間違っていたり、うろ覚えのコマンドなどがあっても、RStudio （あるいはその他のIDE）が瞬時に正解に導いてくれる。 本書はCUIとしてのRについて解説する。Rは統計ソフトでありながら、言語でもある。外国語の勉強に例えるなら、CUIを使うのは単語を熟語を覚え、文法やよく使う表現を学習して自分で考えて話すことであるのに対し、GUIを使うのは AI に翻訳を頼み、外国語については自分で一切考えないことに似ている。たいして興味のない国になぜか旅行で訪れることになった場合にはGUI方式で済ますのも良いだろう。しかし、それでその言語を「勉強した」とか「理解した」などという人はいないはずだ。Rを「理解」したいなら、CUI以外の選択肢はない11。 それでもやはりGUIのほうがとっつきやすいという頑固なあなたのために代表的なRの GUI を紹介するので、以下のリストを確認したらこの本は閉じて頂きたい。またいつかどこかでお会いしましょう。CUIを使う覚悟ができたあなたは、以下のリストを読みとばし、引き続き一緒にRの世界を楽しみましょう！ R Commander 図 2.3: R Commander RKWard 図 2.4: RKWard JASP 図 2.5: JASP jamovi 図 2.6: jamovi R AnalyticFlow 図 2.7: RAnalyticFlow (画像は公式ホームページから) 2.3.2 IDE プログラミングは基本的にコードを書く作業の連続だが、コードを書く他にも様々な作業を行うことになる。たとえば、自分が書いたコードの結果が正しく動作するかの確認作業や、なにか問題がある場合の対処（デバッグ）などがある。また、コードを書く際、誤字やミスなどがないかも確認する必要がある。他にもプログラムで使用されるファイルを管理しなければならない。これらの仕事を手助けしてくれるのが統合開発環境 (integrated development environment; IDE) と呼ばれるものである。 プログラマにとって優れたIDEを使うということは、優れた秘書を雇用するようなものだ。ファイルの管理、うろ覚えのコマンドのプロンプト、コードの色分けなどを自動的に行ってくれる。さらに、コードの実行結果の画面をコードと同時に表示してくれたり、これまでの作業を記録してくれるなど、多くの作業を手助けしてくれる。Rにはいくつかの優れたIDEが用意されている。本書では代表的なIDEである RStudio を使うことにする。ただし、プログラミングにIDEは必須ではない。IDEをインストールしなくても、本書を読む上で特に問題はない（ただし、RStudioに関する説明の部分を除く）が、Rの実行環境に特にこだわりがないなら RStudioの導入を強く推奨する。 図 2.8: RStudio RStudio以外にもRのIDEはある。Windowsという異世界のOSを使用しているなら、R Tools for Visual Studio がRStudioの代替候補として有力だ。 図 2.9: R Tools for Visual Studio 自分が使い慣れたテキストエディタをIDEとして使うことも可能である。Sublime Text や Atom はむろん、伝統のある Emacs や Vim を使うこともできる。 最近、アカデミック版が無料で使えるようになった。↩︎ Rもコードの書き方によってパフォーマンス向上ができる。↩︎ Pythonは統計分析以外でも利用されるので、Python自体のユーザはRのユーザより多いだろう。↩︎ CLI (Command Line Interface) とも呼ばれる。↩︎ 多くの人が片手に5本もつ指を有効に利用できないマウスという不便な機器から解放される。↩︎ すべての「ラーメン◯郎」がそうだというわけではない。↩︎ たとえば、「◯蘭」の注文システムのように。↩︎ これらはすべて錯覚である。↩︎ これは錯覚ではない。↩︎ 通るかどうかは別だが…↩︎ macOS にRをインストールする場合は、途中で「GUIをインストールする」というチェックを外すことができるので、外しておこう。RのGUIは完全に不要であると断言できる。あっても困りはしないが。↩︎ "],["installation.html", "3. Rのインストール 3.1 パッケージのインストール", " 3. Rのインストール 本章の内容は今後、以下の資料に基づき、再作成する予定である。 矢内による資料 (macOS編、Linux (Ubuntu)編、Windows編) 3.1 パッケージのインストール 3.1.1 パッケージのインストール Rの環境は何かを作るための作業台に似ている。作業台にはモノを作るために材料だけでなく、工具・道具セットなども置いたりもする。この作業台がRにおける「環境 (environment) 」であり、材料がベクトルや行列、データフレームなどのデータ、工具セットがパッケージになる。データについては後で説明するとし、ここではパッケージについて考えたい。 モノを作るためには素材・材料だけでは不十分だろう。多くの場合、なんらかの道具セットが必要となる。Rには既にいくつかの必須道具セットを用意されているが、他にも様々な道具セットがある。そして、これら道具セットには、一般的に複数の道具が含まれている。一つ一つの道具のことを、ここでは「関数 (function) 」と呼ぶ。これらの道具セットを購入し、作業台の収納に入れておくことがパッケージをインストールすることである。 install.packages(&quot;パッケージ名&quot;) これらのパッケージは基本的にCRANという道具屋からダウンロード・インストールされる。もう一つの大きな道具屋としてはGitHubがある12。GitHubは個人経営の道具屋が集まっているモールのようなものである。GitHub道具屋を使用するためには予めCRANから{devtools}というパッケージをインストールしておく必要がある。 もし、CRANに登録されていないパッケージをGitHubからインストールするなら、{devtools}パッケージのinstall_github()関数を使う。 install.packages(&quot;devtools&quot;) devtools::install_github(&quot;作成者のGitHubのID/パッケージ名&quot;) たとえば、筆者 (Song) が作成しました{BalanceR}パッケージがインストールしたいなら、以下のように打つ。 devtools::install_github(&quot;JaehyunSong/BalanceR&quot;) #または library(devtools) # library()関数については後述 install_github(&quot;JaehyunSong/BalanceR&quot;) ここでJaehyunSongはSongのGitHub IDであり、BalanceRはパッケージ名である。 3.1.2 パッケージの読み込み 先ほど述べたように、パッケージのインストールは道具セットの購入と収納に似ている。ただし、実際に道具セットを使うためには、それを自分の作業台上に載せた方が効率がいいだろう13。この作業がパッケージの読み込み (load) である。インストールしたパッケージを読み込むにはlibrary()またはrequire()関数を使う。require()は関数内に使う目的で設計された関数だが、パッケージを読み込むという点では全く同じである。 library(&quot;パッケージ名&quot;) #または require(&quot;パッケージ名&quot;) 読み込まれたパッケージはセッションが開かれている時のみに有効である。一通りの作業が終わり、作業部屋から退出すると、作業台上の道具セットは収納に自動的に戻される。つまり、RまたはRStudioを閉じると読み込まれたパッケージは自動的に取り外されるということである。しかし、作業の途中に読み込んだパッケージをセッションから取り外したい時があるかも知れない。この場合、detach()関数を使う。 detach(&quot;パッケージ名&quot;) 図 3.1: 無料イメージほしい 3.1.3 必須パッケージのインストール ここでは現在のRにおいて必須パッケージである、{tidyverse}をインストールする。{tidyverse}は{dplyr}、{ggplot2}、{tidyr}など、Rにおいて不可欠なパッケージを含むパッケージ「群」である。また、前節で紹介しました{devtools}も今のうちにインストールしておこう。前節ですでに導入済みの読者は2行目は不要である。 install.packages(&quot;tidyverse&quot;) install.packages(&quot;devtools&quot;) 他にもGitLab、Bitbucketなどがある。↩︎ 作業台上に載せずに、収納から必要な時だけ道具を取り出して使うことも可能である。この場合、パッケージ名::関数名()のように関数を使う。よく使うパッケージなら読み込んだ方が効率的だが、1、2回くらいしか使わないパッケージなら、このような使い方も良いだろう。↩︎ "],["ide.html", "4. IDEの導入", " 4. IDEの導入 本章の内容は今後、以下の資料に基づき、再作成する予定である。 矢内による資料 (macOS編、Linux (Ubuntu)編、Windows編) "],["R-Customize.html", "5. 分析環境のカスタマイズ", " 5. 分析環境のカスタマイズ "],["process.html", "6. 分析の手順", " 6. 分析の手順 "],["rbasic.html", "7. 基本的な操作 目次 7.1 コンピュータの基礎知識 7.2 「プロジェクト」のすゝめ 7.3 電卓としてのR 7.4 格納とオブジェクトの作成 7.5 要素の抽出 7.6 演習問題", " 7. 基本的な操作 目次 7.1 「コンピュータの基礎知識」 7.2 「プロジェクト」のすゝめ 7.3 電卓としてのR 7.4 格納（代入） 7.5 要素の抽出 7.6 練習問題 この章で使うパッケージを読み込む。 pacman::p_load(tidyverse, xlsx) 7.1 コンピュータの基礎知識 Rを使い始める前に、コンピュータについて最低限知っておいてほしい基礎知識について説明する。 7.1.1 ファイル名 まず、コンピュータ上のファイル名について説明する。 7.1.1.1 ファイル名拡張子 コンピュータの中には、様々な種類のファイルが含まれている。例えば、多くの人は Microsoft Word や Microsoft Excel のファイルを作ったことがあるだろう。Word や Excel で作ったファイルは、基本的にはそれぞれ専用のソフトウェア（アプリ）で開く必要がある。Word で作ったファイルをExcel で開くことや、Excel で作ったファイルを Wordで開くことなどはできない。 ユーザが特に意識しなくても、Word で作ったファイルを [ダブル] クリックすれば Word が起動してそのファイルを開くし、Excel で作ったファイルを [ダブル] クリックすれば Excel が起動して開きたいファイルが開かれる。仮に、Word のファイルとExcelファイルのファイル名が同じ kadai01 だとしても、パソコンは正しいアプリを選んでくれる。パソコンがファイルを区別し、正しいアプリを起動してくれるのはなぜだろうか。 実は、各アプリで作ったファイル名は、自分で名前を付けた部分（上の例では kadai01）の後に続きがある。 Word で作ったファイルには自動的に “.docx” が付けられ、Excel の場合には “.xlsx” が同様に付けられている。 したがって、自分では両方のファイルにまったく同じ kadai01 という名前を付けたつもりでも、実際には、kadai01.docx と kadai01.xlsx という別のファイル名が付いている。 この仕組みにより、パソコンは正しいアプリを選択することができる。ファイル名の末尾に .docx があるファイルがクリックされれば Word を、.xlsx があるファイルが選択されれば Excel を開くのである。 ファイル名の末尾にあってファイルの種類を区別する部分のことをファイル名拡張子 (filename extension) と呼ぶ。上の例からわかるとおり、ファイル名拡張子はファイルの種類を区別する重要情報である。プログラミングをしないパソコンユーザにとっては、ファイルの種類の違いを気にせずにパソコンを使えたほうが便利なので、パソコン購入時の初期設定ではファイル名拡張子が非表示になっている場合がある。しかし、プログラミングをする場合（つまり、この本を読んでいるあなた）は、ファイル名拡張子が見えないと困る。 例えば、Rは様々な形式で保存されたデータファイルを扱うことができるが、種類に応じてデータを読み込む方法（読み込みに使う関数）が異なる。ファイル名拡張子でファイルの種類を区別し、どの方法を使うかを決めるので、拡張子が表示されていないと不便である（MacのFinderやWindows のエクスプローラーで「ファイルの種類」を確認できるので、絶対無理というわけではないが、面倒くさい）。よく使うデータファイルのファイル名拡張子として、次のものがある。 .csv .tsv .txt .dat .dta .RData .Rds 後の章で説明するが、この他にも種類がある。ファイルの種類がわからないと、様々な方法を試行錯誤することになってしまい、効率が悪い。ファイル名拡張子があればファイルの種類がわかるので、正しい方法を選んで作業を進めることができる。 よって、Rユーザ（あるいはその他のプログラミングをする者）にとって、ファイル名拡張子の表示は必須である。自分のパソコンでファイル名拡張子が表示されていないなら、ファイル名拡張子を表示する設定に変えよう。macOS では、Finder の 環境設定 (Preferences) で、詳細設定 (Advanced) タブを開き、「すべてのファイル名拡張子を表示する (Show all filename extensions)」にチェックマークを付ける。 Windows では、エクスプローラー (Explorer) （注意：インターネットエクスプローラーではない。画面下部のタスクバーに表示されている、黄色のフォルダのアイコン）を開き、上部の [表示]タブをクリックする。すると、「ファイル名拡張子」という項目があるので、チェックマークを付ける。チェックマークを付けたら、Word ファイルに .docx （または .doc）、Excelファイルに .xlsx （または .xls）、PDFファイルに .pdf などが付いていることを確認しよう。 7.1.1.2 ファイル名の付け方 ファイル名は、ファイルの中身がわかるように付けるのが基本である。例えば、日記を書いて保存するなら、diary_20200701.txt, diary_20200702.txt のように名前を付ければ、特定の日付の日記であることがすぐにわかる。 また、他人にファイルを渡す必要があるときは、相手の立場になってファイル名を付けるのが望ましい。例えば、比較政治学 (Comparative Politics) の授業のレポートをWord で書く場合を考えよう。レポートを書いている本人にとっては、cp_report.docx というファイル名で中身がわかるので問題ないだろう。しかし、これをメールに添付して担当教員に提出する場合はどうだろうか。受講生が100人いて、全員がこの名前でレポートを提出してきたら、担当教員の元には同じ名前のファイルが100個届く。これでは、担当教員は困ってしまう。つまり、cp_report.docx というファイル名は、受け取る相手のことを考えていない、思いやりのないファイル名である。代わりに、学籍番号（例：123456789）を使い、cp_report_123456789.docx のようにすると、ファイル名の重複がないので、受け取る相手（私たちのことだが）は喜ぶだろう。自分が1つのファイル名を変えるのは大した手間ではないのに対し、相手が全員分のファイル名を変えるの大変な手間だということを理解しよう。 加えて、ファイル名の付け方には形式的なルールがある。ファイル名は、英数字と特定の記号（_ [「アンダースコア」、「アンスコ」、「アンダーバー」などと読む] と - [ハイフン]）のみで付けるべきだ。 ファイル名に日本語（または韓国語、中国語などのマルチバイト文字）を使うのは愚かなのでやめよう。日本語のファイル名でも問題ない場合が多いのは確かだが、問題がある場合もあるので使用を回避するのが賢い。日本語のファイル名だと、次のような問題が起こりうる。 日本語（マルチバイト文字）を扱えないプログラムが停止する。 さらに悪いと、日本語（マルチバイト文字）を扱えないプログラムが想定外の動作をする。 文字コードの違いにより、ファイル名が文字化けする 例えば、日本語のファイル名がついたファイルを Windows で圧縮 (zip) して macOS で展開すると、日本語部分が謎の暗号になるので、どのファイルを開いていいのかわからず、超絶面倒くさい。本当にやめてほしい。お願いだからやめてください。 日本語のなかでも特に凶悪なのが「全角スペース」である。そもそも、スペースは存在に気付きにくい。万が一末尾にスペースがあると、スペースがない場合との区別が難しい。日本語（マルチバイト文字）を扱えないプログラムでは、半角スペースなら問題ないが、全角でスペースだと問題が起きることがある。しかし、目視で半角スペースと全角スペースの区別をするのは非常に困難である。よって、スペースは使うべきではないし、全角スペースは絶対に使ってはいけない。 また、ファイル名の最初の1文字はアルファベットにすることが望ましい。ファイルを並べ替えるときに、数字だとややわかりにくいところがある。例えば、1.txt, 12.txt, 110.txt という3つのファイルをファイル名で並べ替えると、1.txt, 110.txt, 12.txt という順番になる。多くの場合、これはユーザが期待する順番ではない。中身がわかるようにという大原則にしたがえば、アルファベットから始まるファイル名が自然に選ばれるだろう。 ファイル名の付け方をまとめると、次のようになる。 ファイル名は、英数字 (A-Z, a-z, 0-9) と_, - のみで付ける。 ただし、ハイフンがあると動かないプログラムもあるので、できればハイフンも避ける。 ファイル名の1文字目はアルファベットにする（数字を1文字目にすることを避ける）。 .（ドット; ピリオド）は使わない（ファイル名拡張子との混同を避けるため）。 ファイル名にスペースを使わない。全角スペースはもちろん、半角スペースも避けるべき。 - 例えば、my diary.txt というファイル名の代わりに、my_diary.txt または myDiary.txt、MyDiary.txt などのファイル名を使う。 ちなみに、my_diary.txt のように単語をアンスコで繋ぐ書き方をスネークケース (snake case) [_ が地を這うヘビである]、myDiary.txt のように単語の1文字目を大文字にして前の単語と区別する書き方をキャメルケース (camel case) [大文字部分がラクダのコブである] と呼ぶ。 ただし、次のような例外もある。 隠しファイル（Windows 以外では通常は非表示のファイル）の1文字目は . である。 Rユーザが作る隠しファイルとして、.Rprofile と .Renviron がある。 自分で作るファイル以外には、_ や # などの記号からファイル名が始まるものもある。 次の節で説明するフォルダ（ディレクトリ）の名前を付ける際も、基本的にはファイル名と同じルールに従うことが望ましい。 7.1.2 ファイルシステムとパス 次に、ファイルシステムについて解説する。私たちが使用しているコンピュータには、数千〜数万（あるいはそれ以上）のファイルが含まれている。これらのファイルは基本的には1つのドライブ (ハードディスクドライブ [Hard Disk Drive; HDD] またはソリッドステートドライブ [Solid State Drive; SSD]） に保存されているが、ドライブの中にあるファイルはグループ化・階層化されて保存されている。 下の図はファイルシステムの例を示している。矢印の左側には、ドライブ内にあるファイル（の一部）が示されている。通常、これらのファイルは矢印の右側に示されているように、階層化されている。 図 7.1: ファイルシステムの例 図の左側にある Diary_YYYYMMDD.txt がYYYY年MM月DD日の日記を保存したテキストファイルだとしよう14。 3年間毎日日記を書くと、それだけでファイル数は1000個以上になる。また、Analysis_blahblah.R はRスクリプトである15。Rスクリプトファイルも複数ある。さらに、上の図には表示されていないが、自分で作ったファイル以外に、OSやソフトウェア（アプリ）を構成するファイルもドライブ内に保存されているだろう。これらのファイルが整理されずに1つの場所にまとめて置いてあるとしよう（上の図の左側の状態）。そうすると、特定のファイルを開いたり、それぞれのファイルがどのような目的で存在するのかを把握したりするのに少なからぬ労を要する。 単に面倒なだけならいい（私たちは面倒なことが大嫌いなので良くないと考える）が、ファイルの置き場が1つだけだと解決できない問題がある。それは、ファイル名の重複が許されないということだ。世の中には、特定の目的のために使われる「お決まりのファイル名」というものがある。例えば、GitHubにレポジトリを追加するときは、そのレポジトリについて説明する README.md というファイルを作ることになっている。しかし、名前が同じだとファイルが区別できないので、同じ場所にまったく同じ名前のファイルを2つ置くことはできない。したがって、ドライブ内にファイル置き場が1つしかないとなると、1つのパソコンで作れる README.md は1つだけということになってしまい、困ってしまう。 そこで、多くのOSではファイルをグループ化して管理するという方法が採用されている。このグループのことを「フォルダ (folder)」または「ディレクトリ (directory)」と呼ぶ16。 上の図の右側は、ファイルをフォルダに分けた様子を表している。 日記のテキストファイルに注目すると、まず、“Diary” という名前のフォルダがあり、Diary フォルダの中に年ごとのフォルダ “2018”, “2019”, “2020” というフォルダがある。それぞれの年のフォルダの中には、“January”, “February”, \\(\\dots\\), “December” という月ごとのフォルダがある。そして、それぞれの月のフォルダの中に、日付がファイル名になったテキストファイルd_01.txt, d_02.txt, \\(\\dots\\) が保存されている。この例からわかるように、フォルダの中にフォルダを作り、そのフォルダの中にフォルダを作り \\(\\cdots\\) ということができるので、フォルダを入れ子にした階層構造を利用してファイルを管理することができる。 ファイルを階層化して管理する場合、フォルダの構造と場所を把握することが必要になる。そのために使われるのがパス (path) である。パスは、コンピュータ内の住所のようなものだと考えればよい。例えば、“Diary” フォルダ内の “2018” フォルダ内の “January” フォルダ内の “d_01.txt” というファイルのパスは、Diary/2018/January/d_01.txt である。この例からわかるように、パスにはフォルダ名やファイル名がそのまま使われる。そして、フォルダの「中」であることは、/ （スラッシュ）記号によって表される。例えば、Diary/ の部分が、Diary フォルダの中であることを示す。ただし、Windows では / の代わりに \\（バックスラッシュ）または ￥（円記号; 日本語環境の場合）が使われる17。 Diary/2018/January/d_01.txt と Diary/2018/February/d_01.txt は、ファイル名だけを見れば同じ d_01.txt だが、パスが異なるので異なるファイルとして認識され、1つのドライブ内に共存することができる。 しかし、上に書いたパスは、“Diary” フォルダがどこにあるかを指定していないので完全ではない。パソコンがファイルの場所を正しく把握するには、“Diary” フォルダの置き場所がどこかという情報も必要である。 パソコン内でパスの起点になる場所は、OSによって異なる。Linux やmacOSでは、パスの起点となる最上位フォルダは / であり、多くのWindows機では C:\\ （Cドライブと呼ばれる）である18。また、多くのOSでは、ドライブ内に「ホーム (HOME)」と呼ばれる特別なフォルダがあらかじめ用意されており、通常はホームフォルダの中に自分で作ったファイルを保存する。ただし、ホームフォルダの名前は “HOME” ではないので注意が必要である。例えば、macOSではユーザ名がホームフォルダの名前である。例えば、ユーザ名が yukiなら /Users/yuki/ が、ユーザ名が jaehyunsong なら /Users/jaehyunsong/ がホームフォルダのパスである。パスの先頭に / がついており、最上位フォルダの中の “Users” フォルダの中にユーザ名でホームフォルダが作られれている。 ホームフォルダの中に Diary フォルダがあるとすると、2018年1月1日の日記までのパスは、 /Users/jaehyunsong/Diary/2018/January/d_01.txt である。このように、ドライブ内の起点から書いた完全なパスを 絶対パス (absolute path) または フルパス (full path) と呼ぶ。絶対パスを使えば、コンピュータ内の特定のファイルを一意に示すことができる。 絶対パスにホームディレクトリが含まれている場合には、ホームディレクトリまでのパスを省略して ${HOME}/ または ~/ と書くことができる。よって、上の絶対パスは、~/Diary/2018/January/d_01.txt と書くことができる。この書き方を使えば、パスを書き換えることなく共同研究者とファイルを共有することが可能になる（もちろん、ホームフォルダ以下の構造を揃える必要がある）。 自分が作業・操作の対象としているフォルダは、作業フォルダ (working directory; current directory) と呼ばれる19。絶対パスの代わりに、作業フォルダから見た相対パス (relative path)を使うこともできる。例えば、現在の作業フォルダが ~/Diary/2018/ だとすると、2018年1月1日の日記への相対パスは、Januaray/d_01.txt と書ける。 作業フォルダを指定していることを明示したい場合（プログラムを実行する場合にはこれが必要なことがある）には、 ./Januaray/d_01.txt と書く。つまり、./ が作業フォルダを示す。 また、作業フォルダよりも階層が1つ上のフォルダ（親 [parent] フォルダと呼ぶ）には、../ でアクセスでききる。例えば、、現在の作業フォルダが ~/Diary/2018/ だとすると、../ は ~/Diary/ なので、 2020年1月1日の日記への相対パスは ../2020/Januaray/d_01.txt と書くことができる。 相対パスの利点は、 絶対パスより短い 同じ構造を再利用できる ということである。1は自明だろう。2は、例えば日記の一覧を作るためのプログラムを書き、それを「年」を表すフォルダに保存すれば、1つひとつの日記に毎年同じ相対パスでアクセスできる（ただし、2月29日は除く）ので、毎年同じプログラムを利用できて便利である。絶対パスを使うと、「年」の部分を毎年書き換えなければいけない。 絶対パスと相対パスは、目的に応じて使い分けることが必要である。 7.2 「プロジェクト」のすゝめ Rを使ったプログラミングやデータ分析を進めていくと、自分が書いたRスクリプトや作成した図表だけでなく、 Rが自動的に生成するファイルもどんどん溜まる。そう遠くない将来、ドライブ内のファイル数が数万に達しても不思議ではない。効率よくプログラミングを行うために、ファイルの管理方法を明確にしておいたほうが良い。そのためには、フォルダの階層化を利用してファイルを管理することが必要である。 しかし、フォルダによる階層化を導入すればファイルの管理が楽になるかというと、必ずしもそうとは限らない。かえって不便になる部分もある。前の節で見たとおり、フォルダを階層化すると、絶対パスが長く（複雑に）なる。ファイルを階層化によって整理したとしても、ファイルを利用するたびに長い絶対パスの入力が必要なら、ファイル管理の効率が上がったとは言えないだろう。 Rを使う場合にファイル管理の効率化を助けてくれるのが、RStudio の「プロジェクト」機能である。 7.2.1 プロジェクト Rの既定（デフォルト）の作業フォルダはホームフォルダある。分析に使うデータが、ホームフォルダの中の Documents フォルダの中の R フォルダの中の Analysis1 フォルダ内の Data フォルダにある data.csv だとしたら、このファイルにアクセスするためには、\"Documents/R/Analysis1/Data/data.csv\"と入力する必要がある20 \\(^,\\)21。新たに作った図を “histogram.pdf” という名前でホームフォルダの中の Documents フォルダの中の R フォルダの中の Analysis1 フォルダ内の Figures というフォルダに保存するためには、\"Documents/R/Analysis1/Figures/historam.pdf\"と入力する必要がある。どちらもかなり面倒で、効率が悪い。 しかし、作業フォルダが、~/Documents/R/Analysis1/ だとすれば、相対パスにより、\"Data/data.csv\" や\"Figures/historam.pdf\" だけで済む。よって、作業フォルダを明示的に指定すればいいわけだが、作業フォルダを毎回指定するのも面倒だ。 そこで利用できるのが、RStudio のプロジェクト機能である。 プロジェクトとは、特定のフォルダを作業フォルダに設定し、すべての作業をそのフォルダと下位フォルダのみに限定してくれる機能である22。プロジェクト機能さえ使えば、ユーザが意識しなくても、ユーザが書いたコード、保存したデータ、作成した図などが作業フォルダ内に集約され、管理が楽になる。 では、ここからプロジェクトの作り方を説明しよう。 まずはRStudio を起動する。 RStudio が起動したら、“File” から “New Project” を選択する。 図 7.2: FileからNew Project… 下の画面が表示されたら、 “New Directory” を選択する。ただし、既存のフォルダを利用したい場合は、 “Existing Directory” を選ぶ。 図 7.3: New Directoryを選択 下の画面が表示されたら、“New Project” を選択する。 前の手順で “Existing Directory” を選択した場合、この画面は表示されない。 図 7.4: New Projectを選択 下の画面が表示されたら、“Directory name:” にプロジェクト名を入力する。これがフォルダ名になるので、半角英数字のみの 名前を付ける。ここでは第4章のコードということで、“Ch04” にした。統計学の授業用プロジェクトなら “statistics”、計量政治学の授業なら “quant_methods_ps” などの名前を付ければ良いだろう。英語が嫌なら “tokeigaku” のようにすれば良い。また、“Create project as subdirectory of:” では、プロジェクトのフォルダをどのフォルダの中に設置するかを指定する。 “Browse…” をクリックし、親フォルダを選ぶ。ここでは ~/Dropbox/RStudy にプロジェクトのフォルダを入れることにする。ここまでできたら、“Create Project” をクリックする。 手順3で “Existing Directory” を選んだ場合、プロジェクトのフォルダとして使う既存フォルダを選択する画面が表示される。 図 7.5: プロジェクト名と保存場所の指定 以上の手順でプロジェクトができる。RStudio 右上に、プロジェクト名が表示されているはずだ。 また、Console に getwd() と入力すると、プロジェクトまでの絶対パスが表示される。 念のため、Finder（Macの場合）やエクスプローラー （Windows の場合）で、指定した場所にプロジェクトのフォルダ（上の例では Ch04）が生成されていることを確認しよう。 プロジェクトフォルダを開いてみると、Ch04.Rproj というファイルが生成されていることがわかる（下の図）。 図 7.6: プロジェクトの確認 Ch04 プロジェクトを開くには、このCh04.Rproj ファイルをダブルクリックすれば良い。RStudio が起動していない場合でも、指定のプロジェクトを開いた状態でRStudio が起ち上がる。 RStudio 右上の表示が “Project: (None)” となっているときは、プロジェクトが開かれていない。 RStudio を使う場合には、必ず右上の表示を見て、プロジェクトが開かれていることを確認しよう。 プロジェクトが開かれていない場合には、既存のプロジェクトを開くか、新たばプロジェクトを作ろう。 7.3 電卓としてのR 前置きが長かったが、ここからはRを使っていこう。まず、新しい R Script を開くために、Cmd/Ctrl + Shift + N を入力する23（“File” メニューから “New File” - “R Script” を選んでも良い）。すると、 左上の Source Pane に “Untitled1” というタブが登場し、その pane 上でコードが入力できるようになる。ここで 3 + 3 と入力し、その行にカーソルを留めたまま command + return（Mac）または Ctrl + Enter を押してみよう。command + return というのは、command キーを押したまま、return キーも押すという意味である。 図 7.7: コード入力の例 Source ペイン (Untitled1) に入力したコードが Console（本書の説明どおりにカスタマイズしていれば、RStudio 内の右上画面）に転送され、計算結果が表示される。Rのコードは Console に直接打ち込むこともできるが、Sourceペインで入力してから Console に転送する方法が基本である24。 Source ペインの内容をファイルに保存すれば、後でもう1度同じコードを実行したり、コードを他のプロジェクトで再利用することができるようになる。先ほど 3 + 3 を入力した画面にカーソルを合わせ、Cmd/Ctrl + S を押してみよう。ファイルの保存を促されるので、ファイル名をつけて保存しよう。このとき、.R というファイル名拡張子を付ける。これにより、ファイルがRスクリプトとして認識される。例えば、“practice01.R” という名前をつけて保存しよう。Sourceペインの上部に表示されるタブの名前が、“Untitled1” から “practice01.R” に変わることが確認できるはずだ。 以下にRで計算する例を示すので、コードを practice01.R に入力し、command + return （Ctrl + Enter） で Console に送り、実行結果を確認しよう。背景が灰色になっている部分に示されているのが、Rのコマンドである。ただし、##から始まる部分は計算結果である。また、コードブロックのうち、 #（ハッシュ記号）で始まる部分はコメントであり、Rで評価（計算）されない。コメントの使い方 については第25 章で詳しく解説する。 7.3.1 算術演算子 まずは、簡単な足し算と掛け算を実行してみよう。 3 + 3 ## [1] 6 8 * 2 ## [1] 16 これ以外の基本的な演算は以下のとおりである。 演算子 意味 例 結果 + 和 2 + 5 7 - 差 2 - 8 -6 * 積 7 * 3 21 / 商 16 / 5 3.2 ^、** 累乗（べき乗） 2^3または2 ** 3 8 %% 剰余 (モジュロ) 18 %% 7 4 %/% 整数商 18 %/% 7 2 7.3.2 論理演算子 論理演算子とは、入力した式が真か偽かを判定する演算子である。返り値（戻り値）は TRUE（真の場合）または FALSE（偽の場合）のいずれかとなる。たとえば、「3 &gt; 2」は真なので、TRUE が返される。しかし、「2 + 3 = 1」は偽なので、FALSEが返される。実際にやってみよう。 3 &gt; 2 ## [1] TRUE 2 + 3 == 1 ## [1] FALSE このように、等しいかどうかを表す記号は = ではなく ==（二重等号）なので注意されたい。 論理演算子にも、いくつかの種類がある。 演算子 意味 例 結果 1 x &lt; y xはyより小さい 3 &lt; 1 FALSE 2 x &lt;= y xはyと等しいか、小さい 2 &lt;= 2 TRUE 3 x &gt; y xはyより大きい 6 &gt; 5 TRUE 4 x &gt;= y xはyと等しいか、大きい 4 &gt;= 5 FALSE 5 x == y xとyは等しい (2 + 3) == (4 + 1) TRUE 6 x != y xとyは等しくない ((2 * 3) + 1) != (2 * (3 + 1)) TRUE 6番目の例について少し説明する。通常の数式同様、Rも括弧()内の記述を優先的に計算する。したがって、!=左側の((2 * 3) + 1) は 6 + 1 = 7 であり、右側の (2 * (3 + 1)) は 2 * 4 = 8 である。したがって、7 != 8 が判定対象となり、TRUEが返される。! 記号は、「否定」を表すために使われるもので、!= は左右が等しくないときに TRUE を返す 上に挙げた論理演算子は基本的に数字を対象に使うが、TRUEとFALSE を対象に使うものもある。それが and を表す &amp; と or を表す| である。。&amp; は、&amp; を挟む左右の両側が TRUE の場合のみ TRUE を返し、| は少なくとも一方が TRUE なら TRUE を返す。 演算子 意味 例 結果 1 x | y xまたはy (2 + 3 == 5) | (1 * 2 == 3) TRUE 2 x &amp; y xかつy (2 + 3 == 5) &amp; (1 * 2 == 3) FALSE 1番の例では、|の左側は(2 + 3 == 5)であり、TRUE である。一方、右側の(1 * 2 == 3) は FALSE だ。判定対象はTRUE | FALSE となり、TRUE が返される。 2番目の例は TRUE &amp; FALSE なので、返り値は FALSE になる。 7.4 格納とオブジェクトの作成 まず、123454321 * 2 を計算しよう。 次に、123454321 * 3 を計算しよう。 最後に、123454321 * 4 を計算しよう。 これらの計算は簡単にできるだろう。しかし、123454321を3回入力するのが面倒だっただろう25。123454321という数字をxとかaに代入し、数字の代わりに x や a が使えるなら、上の計算は楽になる。ここではその方法を説明する。 xというものに123454321という数字を入れるには、&lt;- という演算子を使う。この演算子により、xという名のもの （オブジェクト）に123454321という数字を代入することができる。ここでは「代入」という表現を使ったが26、&lt;-の役割は代入よりも広いので、これからは「格納」という表現を使う。 &lt;- は、&lt; と- という2つの記号をスペースなしで入力することで作ることができる。 RStudioでは、 option + - [マイナス, ハイフン] (macOS 場合) または Alt + - （Windows の場合）で、&lt;- が入力できる。その際、演算子の前後に半角スペースが1つずつ挿入されるので、このショートカットは必ず使うべきである。 Rを起動した時点では、x というオブジェクトは存在しない。RStudio 右下のペインにある Environment タブを開くと、現時点では何も表示されていないはずだ。しかし、x に何かを格納することで、x というオブジェクトができる。 実際に xに、123454321を格納してみよう。 x &lt;- 123454321 # xに123454321を格納 Environment タブに、x が登場し、格納した数字が右側に表示されていることが確認できるだろう。 オブジェクトの中身は、オブジェクト名をそのまま入力することで表示できる。 x ## [1] 123454321 print(x) でも同じ結果が得られるが、タイプする文字数を減らしたいので xのみにする。ただし、状況やオブジェクトの型（型については後で詳しく説明する）によっては、print() を表示しないと中身が表示されない場合もあるので、R Markdown ファイルで論文などを作成していて、結果を確実に表示したい場合には print(x) とするほうが安全である。 ちなみに、格納と同時にそのオブジェクトの中身を表示することもできる。そのためには、格納コマンド全体を() で囲む。例えば、次のようにする。 (y &lt;- 2) # yに2を格納し、中身を表示 ## [1] 2 値が格納されたオブジェクトは計算に利用できるので、先ほどの計算は、次のようにできる。 x * 2 ## [1] 246908642 x * 3 ## [1] 370362963 x * 4 ## [1] 493817284 文字列を格納することもできる。ただし、文字列は必ず \"\" か '' で囲む必要がある。 x &lt;- &quot;猫の恋 やむとき閨の 朧月（芭蕉）&quot; x ## [1] &quot;猫の恋 やむとき閨の 朧月（芭蕉）&quot; オブジェクトに格納できるのは1つの数値や文字列だけではない。複数の数値や文字列を格納することもできる。そのためには c() という関数を使う。c() のc は concatenate または combine の頭文字で、複数の要素からベクトル (vector) を作るのに使われる関数である。 c() に含む要素はカンマ (,) で区切る。 # ある日の Lions の打順をベクトルに格納する numeric_vec1 &lt;- c(73, 6, 5, 3, 99, 10, 22, 9, 7) numeric_vec1 ## [1] 73 6 5 3 99 10 22 9 7 複数の文字列を格納することもできる。 character_vec &lt;- c(&#39;cat&#39;, &#39;cheetah&#39;, &#39;lion&#39;, &#39;tiger&#39;) character_vec ## [1] &quot;cat&quot; &quot;cheetah&quot; &quot;lion&quot; &quot;tiger&quot; ひとつひとつの要素を指定する代わりに、様々な方法でベクトルを作ることが可能である。 たとえば、seq() 関数を使うと、一連の数字からなるベクトルを作ることができる。from で数列の初項を、to で数列の最終項を指定し、by で要素間の差（第2要素は第1要素に by を加えた値になる ）を指定するか、length.out で最終的にできるベクトルの要素の数を指定する。Rのベクトルの length とは、要素の数のことなので、注意されたい。 いくつか例を挙げる。 seq(from = 1, to = 20, by = 1) # 1から20までの整数。1:20 でも同じ ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ## [16] 16 17 18 19 20 seq(from = 11, to = 20, by = 2) # 1から19までの奇数 ## [1] 11 13 15 17 19 seq(from = 2, to = 20, by = 2) # 2から20までの偶数 ## [1] 2 4 6 8 10 12 14 16 18 20 seq(from = 20, to = 1, by = -5) # 降順、間隔は5 ## [1] 20 15 10 5 seq(from = 1, to = 100, length.out = 10) # 最小値が1、最大値が100で、lengthが10のベクトル ## [1] 1 12 23 34 45 56 67 78 89 100 seq(from = 73, by = -1, length.out = 8) # 73から1つずつ数が小さくなるlengthが10のベクトル ## [1] 73 72 71 70 69 68 67 66 このように1つの関数でも指定する内容は、by になったりlength.out になったりする。by や length.out、from、to などのように、関数で指定する対象になっているもののことを 仮引数 (parameter) と呼ぶ。また、by = 1 の1や、length.out = 10 の10のように、仮引数に実際に渡される値のことを実引数 (argument) と呼ぶ。特に誤解が生じないと思われる場合には、仮引数と実引数を区別せずに引数（ひきすう）と呼ぶ。 Rでは、1つの関数で使う引数の数が複数あることが多いので、仮引数を明示する習慣を身につけたほうがよい。 ただし、第1引数（関数で最初に指定する引数）として必ず入力すべきものは決められている場合がほとんどなので、第1引数の仮引数は省略されることが多い。仮引数が省略される代わりに、第1引数の実引数はほぼ必ず入力する（いくつかの例外もある）。 seq(from = x, to = y, by = 1) の場合はより単純に x:y とすることができる。 21:30 # 21 から30までの整数 ## [1] 21 22 23 24 25 26 27 28 29 30 10:1 # 10 から1までの整数（降順） ## [1] 10 9 8 7 6 5 4 3 2 1 また、rep() 関数も便利である。例を挙げよう。 rep(3, times = 10) # 3が10個のベクトル ## [1] 3 3 3 3 3 3 3 3 3 3 rep(c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), times = c(3, 1, 2)) # aが3つ, bが1つ, cが2つのベクトル ## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; rep(c(&#39;C&#39;, &#39;A&#39;, &#39;T&#39;), each = 2) # C, A, T を2つずつ ## [1] &quot;C&quot; &quot;C&quot; &quot;A&quot; &quot;A&quot; &quot;T&quot; &quot;T&quot; アルファベットのベクトルは、あらかじめ用意されている。 LETTERS # 大文字 ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;F&quot; &quot;G&quot; &quot;H&quot; &quot;I&quot; &quot;J&quot; &quot;K&quot; ## [12] &quot;L&quot; &quot;M&quot; &quot;N&quot; &quot;O&quot; &quot;P&quot; &quot;Q&quot; &quot;R&quot; &quot;S&quot; &quot;T&quot; &quot;U&quot; &quot;V&quot; ## [23] &quot;W&quot; &quot;X&quot; &quot;Y&quot; &quot;Z&quot; letters # 小文字 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; ## [12] &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; ## [23] &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; 7.5 要素の抽出 オブジェクト名（ベクトル）の後に [抽出する要素のインデクス] を付けると、ベクトルの特定の要素を抽出することができる。ちなみに [ は関数である。Console にhelp(\"[\") と打てば、これが Extract と言う名前の関数であることがわかる（help(\"[]\") ではないので注意）。 ベクトルの要素を取り出してみよう。Rのインデクスは、他の多くのプログラミング言語（例えば、C, C++, Pythonなど）とは異なり「1」から始まるので注意されたい。 # numeric_vec1の5番目の要素を抽出 numeric_vec1[5] ## [1] 99 # numeric_vec1の2, 4, 6番目の要素を抽出 numeric_vec1[c(2, 4, 6)] ## [1] 6 3 10 # numeric_vec1の1番目と4番目「以外」の要素を抽出 numeric_vec1[-c(1, 4)] ## [1] 6 5 99 10 22 9 7 # numeric_vec1の5番目から7番目の要素を抽出 numeric_vec1[5:7] ## [1] 99 10 22 c()や:だけでなく、seq()も使える。 numeric_vec2 &lt;- 1:20 # numeric_vec2 の奇数番目の要素を抽出 numeric_vec2[seq(1, 20, by = 2)] ## [1] 1 3 5 7 9 11 13 15 17 19 さらに、TRUEとFALSEを使うこともできる。この場合、抽出したい要素の場所を指定するのではなく、それぞれの場所について抽出する (TRUE) か、しない (FALSE) かを指定する。たとえば、character_vecから1, 3, 4番目の要素を抽出するなら、[c(TRUE, FALSE, TRUE, TRUE)]と指定する。 character_vec[c(TRUE, FALSE, TRUE, TRUE)] ## [1] &quot;cat&quot; &quot;lion&quot; &quot;tiger&quot; TRUEとFALSEが使えるので、論理演算子を[]の中で使うこともできる。たとえば、numeric_vec1の各要素が偶数かどうかを判定するためには、インデックスが2で割り切れるかどうか（2で割った余りが0かどうか）を確認すれば良い。 (numeric_vec1 %% 2) == 0 # 偶数かどうかの判定 ## [1] FALSE TRUE FALSE FALSE FALSE TRUE TRUE ## [8] FALSE FALSE これを利用すれば、numeric_vec1から偶数のみを抽出できる。 numeric_vec1[(numeric_vec1 %% 2) == 0] ## [1] 6 10 22 [ と格納（代入）を組み合わせれば、「ベクトルの一部の要素を書き換える」ことができる。たとえば、numeric_vec1の2番目の要素は5だが、これを100に書き換えたい場合、置換したい要素の場所を[]で指定し、&lt;-で代入すれば良い。 numeric_vec1[2] &lt;- 100 numeric_vec1 ## [1] 73 100 5 3 99 10 22 9 7 複数の要素を置換することもできる。たとえば、偶数を全て0に置換したい場合、以下のようにする。 numeric_vec1[(numeric_vec1 %% 2) == 0] &lt;- 0 numeric_vec1 ## [1] 73 0 5 3 99 0 0 9 7 7.6 演習問題 問1 my_vec1という名のオブジェクトに(3, 9, 10, 8, 3, 5, 8)を格納し、表示せよ。 問2 my_vec1から2, 4, 6番目の要素を抽出せよ。 問3 my_vec1の要素の和を求めよ。 ベクトル内要素の和はsum(ベクトル名)で計算できる。たとえば、ベクトルc(1, 3, 5)の和はsum(c(1, 3, 5))である。 問4 my_vec1の要素から奇数のみを抽出し、その和を求めよ。 問5 my_vec2という名のオブジェクトに長さ7のベクトル、(1, 2, 3, 4, 3, 2, 1)を格納し、表示せよ。 問6 my_vec1とmy_vec2のそれぞれの要素の和を計算し、my_vec3に格納し、表示せよ。 問7 my_vec3の要素から10未満の要素を抽出せよ。 問7 1から100までの公差1の数列 (1, 2, 3, 4, 5, …, 100)を作成し、my_vec4と名付けよ。 問9 my_vec4の各要素を二乗した総和 (\\(1^2 + 2^2 + 3^2 + \\dots + 100^2\\))を求めよ。 問10 my_vec4から奇数のみ抽出し、二乗和 (\\(1^2 + 3^2 + 5^2 + 7^2 + \\dots + 97^2 + 99^2\\))を求めよ。 ファイル名拡張子が “.txt” のファイルを「テキストファイル」と呼ぶ。↩︎ ファイル名拡張子が “.R” または “.r” のファイルを「Rスクリプト」と呼ぶ。↩︎ 本書では、フォルダとディレクトリを同義語として扱う。↩︎ これ以降、原則としてパスの表記には / を使うので、Windowsユーザはご注意を。↩︎ かつては、AドライブとBドライブがフロッビーディスクに使われていた。その名残でCドライブが使われている。↩︎ Rでは、getwd() で現在の作業フォルダを確認できる。また、setwd() で作業フォルダを変更できる。例えば、setwd(\"~/Diary\") とすれば、ホームフォルダ内の Diary フォルダを作業フォルダに指定できる。しかし、これらの関数は基本的には使わない。この後説明するとおり、RStudio のプロジェクト機能の使用を推奨する。↩︎ Rでパスを指定するときは、パスを引用符で囲む。引用符は、\"\" でも '' でも良い。↩︎ file.path() を使って、file.path(\"Documents\", \"R\", \"Analysis\", \"Data\", \"data.csv\") と書くこともできる。この書き方の利点は、/, \\, ￥ を環境に応じて使い分けてくれることである。↩︎ 何らかの事情により、作業ディレクトリ以外のフォルダにアクセスすることが必要なときは、絶対パスを使えば良い。↩︎ Mac では、command + shift + N、Windows では Ctrl + Shift + N のショートカットが使える。↩︎ 電卓として使う程度なら、Consoleに直接入力してもかまわない。↩︎ 反復作業が面倒だと感じるほどプログラミングが上達しやすい。↩︎ 代入の代わりに「付値」と言うこともある。↩︎ "],["io.html", "8. データの入出力 目次 8.1 データの読み込み 8.2 データの書き出し", " 8. データの入出力 目次 8.1 データの読み込み 8.2 データの書き出し ?? 練習問題 この章で使うパッケージを読み込む。 pacman::p_load(tidyverse, xlsx, haven) 8.1 データの読み込み 8.1.1 csvファイルの場合 csv は、comma separated values の略である。多くの人に馴染みがあると思われる Excelファイル (.xlsx) と同じように、表形式（行列形式）のデータを保存できる。しかし、Excelファイルとは異なり、文字の大きさ、セルの背景色、複数のセルの結合のような情報はもたず、純粋にデータに含まれる変数の名前と各変数の値（数値・文字列）のみが格納されているため、ファイルサイズが小さい。また、文字データしかもたないテキストファイルであり、テキストエディタで開くことができる。テキストファイルで csv ファイルを開けば、“csv” と呼ばれる理由がわかるだろう。csvフォーマットはデータを保存のための標準フォーマットの1つであり、多くのデータがcsv形式で保存されている。データ分析ソフトでcsv ファイルを開けないものはおそらくないだろう。 Rでもcsv形式のファイルは簡単に読み込める。実際にやっててみよう。データのダウンロード方法については本書の第1.4章を参照されたい。csvファイルを読み込むにはread.csv()またはreadr::read_csv()関数を使う27。読み込む際は前章のベクトルの生成同様、何らかの名前を付けて作業環境に保存する。Dataフォルダーにある FIFA_Women.csv ファイルを読み込み、my_df1と名付ける場合、以下のようなコードを実行する28。以下のコードでmy_df1 &lt;- の部分を入力しないと、データが画面に出力され、自分の作業スペースには保存されないので注意されたい。 my_df1 &lt;- read.csv(&quot;Data/FIFA_Women.csv&quot;) 読み込まれたデータの中身を見るには、ベクトルの場合と同様にprint()関数を使うか、オブジェクト名を入力する。 my_df1 ## ID Team Rank Points ## 1 1 Albania 75 1325 ## 2 2 Algeria 85 1271 ## 3 3 American Samoa 133 1030 ## 4 4 Andorra 155 749 ## 5 5 Angola 121 1117 ## 6 6 Antigua and Barbuda 153 787 ## 7 7 Argentina 32 1659 ## 8 8 Armenia 126 1103 ## 9 9 Aruba 157 724 ## 10 10 Australia 7 1963 ## 11 11 Austria 22 1792 ## 12 12 Azerbaijan 76 1321 ## 13 13 Bahrain 84 1274 ## 14 14 Bangladesh 134 1008 ## 15 15 Barbados 135 1002 ## 16 16 Belarus 53 1434 ## 17 17 Belgium 17 1819 ## 18 18 Belize 150 824 ## 19 19 Bermuda 136 987 ## 20 20 Bhutan 154 769 ## 21 21 Bolivia 91 1236 ## 22 22 Bosnia and Herzegovina 59 1411 ## 23 23 Botswana 148 848 ## 24 24 Brazil 8 1958 ## 25 25 Bulgaria 79 1303 ## 26 26 Cameroon 51 1455 ## 27 27 Canada 8 1958 ## 28 28 Chile 37 1640 ## 29 29 China PR 15 1867 ## 30 30 Chinese Taipei 40 1589 ## 31 31 Colombia 25 1700 ## 32 32 Comoros 156 731 ## 33 33 Congo 104 1178 ## 34 34 Congo DR 110 1159 ## 35 35 Cook Islands 103 1194 ## 36 36 Costa Rica 36 1644 ## 37 37 Côte d&#39;Ivoire 63 1392 ## 38 38 Croatia 52 1453 ## 39 39 Cuba 88 1240 ## 40 40 Cyprus 123 1114 ## 41 41 Czech Republic 29 1678 ## 42 42 Denmark 16 1851 ## 43 43 Dominican Republic 105 1173 ## 44 44 El Salvador 109 1164 ## 45 45 England 6 1999 ## 46 46 Equatorial Guinea 71 1356 ## 47 47 Estonia 95 1210 ## 48 48 Eswatini 151 822 ## 49 49 Ethiopia 111 1151 ## 50 50 Faroe Islands 86 1259 ## 51 51 Fiji 66 1373 ## 52 52 Finland 30 1671 ## 53 53 France 3 2036 ## 54 54 Gabon 130 1066 ## 55 55 Gambia 113 1143 ## 56 56 Georgia 115 1138 ## 57 57 Germany 2 2090 ## 58 58 Ghana 60 1401 ## 59 59 Greece 62 1396 ## 60 60 Guam 82 1282 ## 61 61 Guatemala 80 1290 ## 62 62 Haiti 64 1391 ## 63 63 Honduras 116 1136 ## 64 64 Hong Kong 74 1329 ## 65 65 Hungary 43 1537 ## 66 66 Iceland 19 1817 ## 67 67 India 55 1432 ## 68 68 Indonesia 94 1222 ## 69 69 IR Iran 70 1358 ## 70 70 Israel 67 1369 ## 71 71 Italy 14 1889 ## 72 72 Jamaica 50 1460 ## 73 73 Japan 11 1937 ## 74 74 Jordan 58 1419 ## 75 75 Kazakhstan 77 1318 ## 76 76 Kenya 137 986 ## 77 77 Korea DPR 10 1940 ## 78 78 Korea Republic 18 1818 ## 79 79 Kosovo 125 1104 ## 80 80 Kyrgyz Republic 120 1118 ## 81 81 Latvia 93 1223 ## 82 82 Lebanon 141 967 ## 83 83 Lesotho 147 850 ## 84 84 Lithuania 107 1169 ## 85 85 Luxembourg 119 1124 ## 86 86 Madagascar 158 691 ## 87 87 Malawi 145 887 ## 88 88 Malaysia 90 1238 ## 89 89 Maldives 142 966 ## 90 90 Mali 83 1276 ## 91 91 Malta 101 1197 ## 92 92 Mauritius 159 357 ## 93 93 Mexico 27 1686 ## 94 94 Moldova 92 1228 ## 95 95 Mongolia 123 1114 ## 96 96 Montenegro 97 1201 ## 97 97 Morocco 81 1289 ## 98 98 Mozambique 152 814 ## 99 99 Myanmar 45 1511 ## 100 100 Namibia 143 956 ## 101 101 Nepal 99 1200 ## 102 102 Netherlands 4 2032 ## 103 103 New Caledonia 96 1208 ## 104 104 New Zealand 23 1757 ## 105 105 Nicaragua 122 1116 ## 106 106 Nigeria 38 1614 ## 107 107 North Macedonia 129 1072 ## 108 108 Northern Ireland 55 1432 ## 109 109 Norway 12 1930 ## 110 110 Palestine 117 1131 ## 111 111 Panama 60 1401 ## 112 112 Papua New Guinea 46 1504 ## 113 113 Paraguay 48 1490 ## 114 114 Peru 65 1376 ## 115 115 Philippines 67 1369 ## 116 116 Poland 28 1683 ## 117 117 Portugal 32 1659 ## 118 118 Puerto Rico 106 1172 ## 119 119 Republic of Ireland 31 1666 ## 120 120 Romania 44 1535 ## 121 121 Russia 24 1708 ## 122 122 Rwanda 144 899 ## 123 123 Samoa 107 1169 ## 124 124 Scotland 21 1804 ## 125 125 Senegal 87 1247 ## 126 126 Serbia 41 1558 ## 127 127 Singapore 128 1089 ## 128 128 Slovakia 47 1501 ## 129 129 Slovenia 49 1471 ## 130 130 Solomon Islands 114 1140 ## 131 131 South Africa 53 1434 ## 132 132 Spain 13 1915 ## 133 133 Sri Lanka 140 968 ## 134 134 St. Kitts and Nevis 131 1050 ## 135 135 St. Lucia 138 982 ## 136 136 Suriname 127 1093 ## 137 137 Sweden 5 2007 ## 138 138 Switzerland 20 1815 ## 139 139 Tahiti 102 1196 ## 140 140 Tajikistan 132 1035 ## 141 141 Tanzania 139 978 ## 142 142 Thailand 39 1596 ## 143 143 Tonga 88 1240 ## 144 144 Trinidad and Tobago 72 1354 ## 145 145 Tunisia 78 1304 ## 146 146 Turkey 69 1365 ## 147 147 Uganda 146 868 ## 148 148 Ukraine 26 1692 ## 149 149 United Arab Emirates 97 1201 ## 150 150 Uruguay 73 1346 ## 151 151 US Virgin Islands 149 843 ## 152 152 USA 1 2181 ## 153 153 Uzbekistan 42 1543 ## 154 154 Vanuatu 117 1131 ## 155 155 Venezuela 57 1425 ## 156 156 Vietnam 35 1657 ## 157 157 Wales 34 1658 ## 158 158 Zambia 100 1198 ## 159 159 Zimbabwe 111 1151 ## Prev_Points Confederation ## 1 1316 UEFA ## 2 1271 CAF ## 3 1030 OFC ## 4 749 UEFA ## 5 1117 CAF ## 6 787 CONCACAF ## 7 1659 CONMEBOL ## 8 1104 UEFA ## 9 724 CONCACAF ## 10 1963 AFC ## 11 1797 UEFA ## 12 1326 UEFA ## 13 1274 AFC ## 14 1008 AFC ## 15 1002 CONCACAF ## 16 1437 UEFA ## 17 1824 UEFA ## 18 824 CONCACAF ## 19 987 CONCACAF ## 20 769 AFC ## 21 1236 CONMEBOL ## 22 1397 UEFA ## 23 848 CAF ## 24 1956 CONMEBOL ## 25 1303 UEFA ## 26 1486 CAF ## 27 1958 CONCACAF ## 28 1637 CONMEBOL ## 29 1842 AFC ## 30 1584 AFC ## 31 1700 CONMEBOL ## 32 731 CAF ## 33 1178 CAF ## 34 1159 CAF ## 35 1194 OFC ## 36 1630 CONCACAF ## 37 1392 CAF ## 38 1439 UEFA ## 39 1240 CONCACAF ## 40 1123 UEFA ## 41 1678 UEFA ## 42 1839 UEFA ## 43 1173 CONCACAF ## 44 1164 CONCACAF ## 45 2001 UEFA ## 46 1356 CAF ## 47 1206 UEFA ## 48 822 CAF ## 49 1151 CAF ## 50 1262 UEFA ## 51 1373 OFC ## 52 1678 UEFA ## 53 2033 UEFA ## 54 1066 CAF ## 55 1183 CAF ## 56 1145 UEFA ## 57 2078 UEFA ## 58 1404 CAF ## 59 1395 UEFA ## 60 1282 AFC ## 61 1290 CONCACAF ## 62 1368 CONCACAF ## 63 1136 CONCACAF ## 64 1335 AFC ## 65 1526 UEFA ## 66 1821 UEFA ## 67 1432 AFC ## 68 1222 AFC ## 69 1358 AFC ## 70 1371 UEFA ## 71 1882 UEFA ## 72 1461 CONCACAF ## 73 1942 AFC ## 74 1419 AFC ## 75 1318 UEFA ## 76 986 CAF ## 77 1940 AFC ## 78 1812 AFC ## 79 1109 UEFA ## 80 1118 AFC ## 81 1223 UEFA ## 82 967 AFC ## 83 850 CAF ## 84 1168 UEFA ## 85 1124 UEFA ## 86 691 CAF ## 87 887 CAF ## 88 1238 AFC ## 89 966 AFC ## 90 1276 CAF ## 91 1195 UEFA ## 92 357 CAF ## 93 1699 CONCACAF ## 94 1229 UEFA ## 95 1114 AFC ## 96 1206 UEFA ## 97 1280 CAF ## 98 814 CAF ## 99 1527 AFC ## 100 956 CAF ## 101 1200 AFC ## 102 2035 UEFA ## 103 1208 OFC ## 104 1760 OFC ## 105 1116 CONCACAF ## 106 1614 CAF ## 107 1073 UEFA ## 108 1433 UEFA ## 109 1929 UEFA ## 110 1131 AFC ## 111 1437 CONCACAF ## 112 1504 OFC ## 113 1490 CONMEBOL ## 114 1376 CONMEBOL ## 115 1369 AFC ## 116 1677 UEFA ## 117 1667 UEFA ## 118 1172 CONCACAF ## 119 1665 UEFA ## 120 1542 UEFA ## 121 1708 UEFA ## 122 899 CAF ## 123 1169 OFC ## 124 1794 UEFA ## 125 1245 CAF ## 126 1553 UEFA ## 127 1089 AFC ## 128 1500 UEFA ## 129 1467 UEFA ## 130 1140 OFC ## 131 1434 CAF ## 132 1900 UEFA ## 133 968 AFC ## 134 1054 CONCACAF ## 135 982 CONCACAF ## 136 1093 CONCACAF ## 137 2022 UEFA ## 138 1817 UEFA ## 139 1196 OFC ## 140 1035 AFC ## 141 978 CAF ## 142 1620 AFC ## 143 1240 OFC ## 144 1354 CONCACAF ## 145 1313 CAF ## 146 1361 UEFA ## 147 868 CAF ## 148 1697 UEFA ## 149 1201 AFC ## 150 1346 CONMEBOL ## 151 843 CONCACAF ## 152 2174 CONCACAF ## 153 1543 AFC ## 154 1131 OFC ## 155 1425 CONMEBOL ## 156 1665 AFC ## 157 1659 UEFA ## 158 1167 CAF ## 159 1151 CAF しかし、通常はデータが読み込まれているかどうかを確認するためにデータ全体を見る必要はない。最初の数行のみで問題ないはずだ。そのために、head() 関数を使う。これは最初の6行 (n で表示行数を変える) を表示してくれる。 head(my_df1) ## ID Team Rank Points Prev_Points ## 1 1 Albania 75 1325 1316 ## 2 2 Algeria 85 1271 1271 ## 3 3 American Samoa 133 1030 1030 ## 4 4 Andorra 155 749 749 ## 5 5 Angola 121 1117 1117 ## 6 6 Antigua and Barbuda 153 787 787 ## Confederation ## 1 UEFA ## 2 CAF ## 3 OFC ## 4 UEFA ## 5 CAF ## 6 CONCACAF 同様に、最後の n行はtail() で表示する。 tail(my_df1, n = 9) ## ID Team Rank Points ## 151 151 US Virgin Islands 149 843 ## 152 152 USA 1 2181 ## 153 153 Uzbekistan 42 1543 ## 154 154 Vanuatu 117 1131 ## 155 155 Venezuela 57 1425 ## 156 156 Vietnam 35 1657 ## 157 157 Wales 34 1658 ## 158 158 Zambia 100 1198 ## 159 159 Zimbabwe 111 1151 ## Prev_Points Confederation ## 151 843 CONCACAF ## 152 2174 CONCACAF ## 153 1543 AFC ## 154 1131 OFC ## 155 1425 CONMEBOL ## 156 1665 AFC ## 157 1659 UEFA ## 158 1167 CAF ## 159 1151 CAF 8.1.1.1 エンコーディングの話 Vote_ShiftJIS.csv はShift-JIS でエンコーディングされた csvファイルである。このファイルを read.csv() 関数で読み込んでみよう。 ShiftJIS_df &lt;- read.csv(&quot;Data/Vote_ShiftJIS.csv&quot;) ## Error in type.convert.default(data[[i]], as.is = as.is[i], dec = dec, : &#39;&lt;96&gt;k&lt;8a&gt;C&lt;93&gt;&lt;b9&gt;&#39; に不正なマルチバイト文字があります このようにエラーが表示され、読み込めない。 このファイルは、read.csv()の代わりに readrパッケージのread_csv()を使えば読み込むことができる29。read_csv()で読み込み、中身を確認してみよう。 ShiftJIS_df1 &lt;- read_csv(&quot;Data/Vote_ShiftJIS.csv&quot;) ## ## ─ Column specification ───────────── ## cols( ## ID = col_double(), ## Pref = col_character(), ## Zaisei = col_double(), ## Over65 = col_double(), ## Under30 = col_double(), ## LDP = col_double(), ## DPJ = col_double(), ## Komei = col_double(), ## Ishin = col_double(), ## JCP = col_double(), ## SDP = col_double() ## ) head(ShiftJIS_df1) ## # A tibble: 6 x 11 ## ID Pref Zaisei Over65 Under30 LDP DPJ ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 &quot;\\x9… 0.419 29.1 24.7 32.8 30.6 ## 2 2 &quot;\\x9… 0.332 30.1 23.9 40.4 24.6 ## 3 3 &quot;\\x8… 0.341 30.4 24.5 34.9 22.4 ## 4 4 &quot;\\x8… 0.596 25.8 27.3 36.7 25.4 ## 5 5 &quot;\\x8… 0.299 33.8 21.4 43.5 22.7 ## 6 6 &quot;\\x8… 0.342 30.8 24.8 42.5 21.5 ## # … with 4 more variables: Komei &lt;dbl&gt;, ## # Ishin &lt;dbl&gt;, JCP &lt;dbl&gt;, SDP &lt;dbl&gt; 2列目のPref列には日本語で都道府県名が入っているはずだが、謎の文字列が表示される。 正しい都道府県名を表示する方法はいくつかあるが、ここでは3つの方法を紹介する。 1. read.csv()関数のfileEncoing引数の指定 一つ目の方法は、read.csv()関数の fileEncoding 引数を追加するというものだる。この引数に、指定したファイルのエンコーディングを指定すればよいが、Shift-JISの場合、\"Shift_JIS\" を指定する。ハイフン (-)ではなく、アンダーバー (_) であることに注意されたい。この\"Shift_JIS\"は\"cp932\" に書き換えても良い。それではやってみよう。 ShiftJIS_df2 &lt;- read.csv(&quot;Data/Vote_ShiftJIS.csv&quot;, fileEncoding = &quot;Shift_JIS&quot;) head(ShiftJIS_df2) ## ID Pref Zaisei Over65 Under30 LDP DPJ ## 1 1 北海道 0.41903 29.09 24.70 32.82 30.62 ## 2 2 青森県 0.33190 30.14 23.92 40.44 24.61 ## 3 3 岩手県 0.34116 30.38 24.48 34.90 22.44 ## 4 4 宮城県 0.59597 25.75 27.29 36.68 25.40 ## 5 5 秋田県 0.29862 33.84 21.35 43.46 22.72 ## 6 6 山形県 0.34237 30.76 24.75 42.49 21.47 ## Komei Ishin JCP SDP ## 1 13.41 3.43 11.44 1.68 ## 2 12.76 3.82 8.92 3.41 ## 3 8.61 5.16 11.24 5.29 ## 4 13.42 3.97 9.99 3.62 ## 5 11.19 5.17 7.56 5.12 ## 6 11.78 4.30 7.60 5.20 Pref列の日本語が正常に表示された。 2. read_csv()関数のlocale引数の指定 二つ目の方法は read_csv() 関数のlocale 引数を指定する方法である。read_csv()には fileEncoding 引数がないが、代わりに locale があるので、locale = locale(encoding = \"Shift_JIS\")を追加すれば良い。 ShiftJIS_df3 &lt;- read_csv(&quot;Data/Vote_ShiftJIS.csv&quot;, locale = locale(encoding = &quot;Shift_JIS&quot;)) ## ## ─ Column specification ───────────── ## cols( ## ID = col_double(), ## Pref = col_character(), ## Zaisei = col_double(), ## Over65 = col_double(), ## Under30 = col_double(), ## LDP = col_double(), ## DPJ = col_double(), ## Komei = col_double(), ## Ishin = col_double(), ## JCP = col_double(), ## SDP = col_double() ## ) head(ShiftJIS_df3) ## # A tibble: 6 x 11 ## ID Pref Zaisei Over65 Under30 LDP DPJ ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 北海道… 0.419 29.1 24.7 32.8 30.6 ## 2 2 青森県… 0.332 30.1 23.9 40.4 24.6 ## 3 3 岩手県… 0.341 30.4 24.5 34.9 22.4 ## 4 4 宮城県… 0.596 25.8 27.3 36.7 25.4 ## 5 5 秋田県… 0.299 33.8 21.4 43.5 22.7 ## 6 6 山形県… 0.342 30.8 24.8 42.5 21.5 ## # … with 4 more variables: Komei &lt;dbl&gt;, ## # Ishin &lt;dbl&gt;, JCP &lt;dbl&gt;, SDP &lt;dbl&gt; 3. LibreOfficeなどを利用した方法 第三の方法は、そもそも Shift-JISでではなく、より一般的な UTF-8 でエンコーディングされたファイルを用意し、それを読み込むことである。ただし、この作業のためにはR以外のソフトが必要である。テキストエディタには文字コードを変更する機能がついているものが多いので、その機能を利用して文字コードを Shift-JISからUTF-8に変えれば良い。また、オープンソースのオフィススイートである LibreOffice は、CSVを開く際に文字コードを尋ねてくれるので、Shift-JIS を指定して上で使った csv ファイルを開こう。その後、文字コードをUTF-8に変更し、別名でcsvファイルを保存すれ、文字コード以外の中身が同じファイルができる。そのようにして作ったのが、Vote.csv である。これを読み込んでみよう。 UTF8_df &lt;- read.csv(&quot;Data/Vote.csv&quot;) head(UTF8_df) ## ID Pref Zaisei Over65 Under30 LDP DPJ ## 1 1 北海道 0.41903 29.09 24.70 32.82 30.62 ## 2 2 青森県 0.33190 30.14 23.92 40.44 24.61 ## 3 3 岩手県 0.34116 30.38 24.48 34.90 22.44 ## 4 4 宮城県 0.59597 25.75 27.29 36.68 25.40 ## 5 5 秋田県 0.29862 33.84 21.35 43.46 22.72 ## 6 6 山形県 0.34237 30.76 24.75 42.49 21.47 ## Komei Ishin JCP SDP ## 1 13.41 3.43 11.44 1.68 ## 2 12.76 3.82 8.92 3.41 ## 3 8.61 5.16 11.24 5.29 ## 4 13.42 3.97 9.99 3.62 ## 5 11.19 5.17 7.56 5.12 ## 6 11.78 4.30 7.60 5.20 第1引数以外の引数を何を指定しなくても、ファイルが正しく読み込まれ、都道府県名が日本語で表示されている。 8.1.2 その他のフォーマット データ分析で用いられるデータの多くは表の形で保存されている。表形式のデータは、.csv以外に、.xlsx (Excel)、.dta (Stata)、.sav (SPSS)、.ods (LibreOfficeなど) などのファイル形式で保存されることがある。ここでは接する機会が多い Excel 形式のファイルと Stata 形式のファイルの読み込みについて説明しよう30。 Excelファイルを読み込むためにはxlsxパッケージを使う。インストールされていない場合、コンソール上でinstall.packages(\"xlsx\")を入力し、インストールする（上で pacman::p_load(xlsx) を実行したのでインストールされているはずだが）。以下ではxlsxパッケージがインストールされていると想定し、Soccer.xlsxファイルを読み込み、Excel_DFと名付けてみよう。 Excel_DF &lt;- read.xlsx(&quot;Data/Soccer.xlsx&quot;, sheetIndex = 1) Excelファイルには2つ以上のシートが含まれる場合が多いので、どのシートを読み込むかをsheetIndex で指定する。実際、Soccer.xlsxファイルをExcelまたはLibreOffice Calc で開いてみると、シートが3つある。そのうち、必要なデータは1つ目のシートにあるので、ここでは1を指定した。きちんと読み込たか確認してみよう。 head(Excel_DF) ## ID Team Rank Points Prev_Points ## 1 1 Albania 75 1325 1316 ## 2 2 Algeria 85 1271 1271 ## 3 3 American Samoa 133 1030 1030 ## 4 4 Andorra 155 749 749 ## 5 5 Angola 121 1117 1117 ## 6 6 Antigua and Barbuda 153 787 787 ## Confederation ## 1 UEFA ## 2 CAF ## 3 OFC ## 4 UEFA ## 5 CAF ## 6 CONCACAF Stataの.dtaファイルはhavenパッケージのread_dta() 関数を使って読み込む。Stata形式で保存された Soccer.dta を読み込み、Stata_DFと名付けてみよう。 Stata_DF &lt;- read_dta(&quot;Data/Soccer.dta&quot;) head(Stata_DF) ## # A tibble: 6 x 6 ## id team rank points prev_points ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Alba… 75 1325 1316 ## 2 2 Alge… 85 1271 1271 ## 3 3 Amer… 133 1030 1030 ## 4 4 Ando… 155 749 749 ## 5 5 Ango… 121 1117 1117 ## 6 6 Anti… 153 787 787 ## # … with 1 more variable: confederation &lt;chr&gt; Excel形式のデータと同じ内容のデータであること確認できる（ただし、変数名は少し異なる）。 実際の社会科学の場合、入手するデータの多くは.csv、.xlsx (または.xls)、.dtaであるため、以上のやり方で多くのデータの読み込みができる。 8.1.3 RDataファイルの場合 データ分析には表形式以外のデータも使われる。データ分析でよく使われるデータの形として、ベクトルや行列のほかにlist型とがある。表形式だけでなく、Rで扱える様々なデータを含むファイル形式の1つが.RDataフォーマットである。.RDataにはRが扱える形式のデータを格納するだけでなく、表形式のデータを複数格納することができる。また、データだけでなく、分析結果も保存することができる。.RData形式のファイルはRでしか読み込めないため、データの保存方法としては推奨できないが、1つのファイルにさまざまなデータが格納できるという大きな長所があるため、分析の途中経過を保存するためにしばしば利用される。 ここではDataフォルダにあるScores.RDataを読み込んでみよう。このファイルには学生5人の数学と英語の成績に関するデータがそれぞれMathScoreとEnglishScoreという名で保存されている。このデータを読み込む前に、現在の実行環境にどのようなオブジェクトがあるかを ls() 関数を使って確認してみよう31。 ls() ## [1] &quot;Excel_DF&quot; &quot;my_df1&quot; &quot;ShiftJIS_df1&quot; ## [4] &quot;ShiftJIS_df2&quot; &quot;ShiftJIS_df3&quot; &quot;Stata_DF&quot; ## [7] &quot;UTF8_df&quot; 現在の実行環境に7個のオブジェクトがあることがわかる。 では、Scores.RDataを読み込んでみよう。.RData は、load() 関数で読み込む。ただし、これまでのファイルの読み込みとは異なり、保存先のオブジェクト名は指定しない。なぜなら、.Rdata の中に既にオブジェクトが保存されているからだ。 load(&quot;Data/Scores.RData&quot;) ここでもう一度実行環境上にあるオブジェクトのリストを確認してみよう。 ls() ## [1] &quot;EnglishScore&quot; &quot;Excel_DF&quot; &quot;MathScore&quot; ## [4] &quot;my_df1&quot; &quot;ShiftJIS_df1&quot; &quot;ShiftJIS_df2&quot; ## [7] &quot;ShiftJIS_df3&quot; &quot;Stata_DF&quot; &quot;UTF8_df&quot; MathScoreとEnglishScoreという名前のオブジェクトが追加されていることが分かる。 このように、load()による.RData の読み込みは、.csvファイルや.xlsxファイルの読み込みと異なる。以下の2点が重要な違いである。 .RData は、1つのファイルに複数のデータを含むことができる。 .RDataの中にRのオブジェクトが保存されているので、ファイルの読み込みと同時に名前を付けて格納する必要がない。 問題なく読み込まれているか確認するため、それぞれのオブジェクトの中身を見てみよう。 MathScore # MathScoreの中身を出力 ## ID Name Score ## 1 1 Caracal 100 ## 2 2 Cheetah 37 ## 3 3 Jaguar 55 ## 4 4 Leopard 69 ## 5 5 Serval 95 EnglishScore # EnglishScoreの中身を出力 ## ID Name Score ## 1 1 Caracal 90 ## 2 2 Cheetah 21 ## 3 3 Jaguar 80 ## 4 4 Leopard 45 ## 5 5 Serval 99 8.2 データの書き出し データを手に入れた時点でそのデータ（生データ）が分析に適した状態であることは稀である。多くの場合、分析をするためには手に入れたデータを分析に適した形に整形する必要がある。この作業を「データクリーニング」と呼ぶが、データ分析の作業全体に占めるデータクリーニングの割合は5から7割ほどで、大部分の作業時をクリーニングに費やすことになる。（クリーニングの方法については、データハンドリングの章で説明する。） データクリーニングが終わったら、生データとクリーニングに使ったコード、クリーニング済みのデータをそれぞれ保存しておこう。クリーニングのコードさえあればいつでも生データからクリーニング済みのデータに変換することができるが、時間的にあまり効率的ではないので、クリーニング済みのデータも保存したほうが良い。そうすれば、いつでもそのデータを読み込んですぐに分析作業に取り組無ことができる32。 8.2.1 csvファイル データを保存する際にまず考えるべきフォーマットは.csv である。データが表の形をしていない場合には次節で紹介する.RDataフォーマットが必要になるが、多くの場合、データは表の形をしている。読み込みのところで説明したとおり、.csvファイルは汎用的なテキストファイルであり、ほとんどの統計ソフトおよび表計算ソフトで読み込むことができるので、特にこだわりがなければ業界標準のフォーマットとも言える csv 形式でデータ保存しておくのが安全だ33。 まずは、架空のデータを作ってみよう。Rにおける表形式のデータは data.frame型で表現する。（詳細については第10章で説明する。） my_data &lt;- data.frame( ID = 1:5, Name = c(&quot;Aさん&quot;, &quot;Bさん&quot;, &quot;Cさん&quot;, &quot;Dさん&quot;, &quot;Eさん&quot;), Score = c(50, 75, 60, 93, 51) ) 上のコードを実行すると、my_dataというオブジェクトが生成され、中には表@ref(tab:my_data)のようなデータが保持される。 (#tab:my_data)my_dataの中身 ID Name Score 1 Aさん 50 2 Bさん 75 3 Cさん 60 4 Dさん 93 5 Eさん 51 このデータをmy_data.csvという名前のcsvファイルで保存するには、write.csv()という関数を使う。必須の引数は2つで、1つ目の引数は保存するオブジェクト名、2つ目の引数 file は書き出すファイル名。もし、プロジェクトフォルダの下位フォルダ、たとえば、Dataフォルダーに保存するなら、ファイル名を\"Data/my_ata.csv\"のように指定する。他によく使う引数としてrow.namesがあり、デフォルトはTRUEだが、FALSEにすることを推奨する。TRUEのままだと、データの1列目に行番号が保存される。 write.csv(my_data, file = &quot;Data/my_data.csv&quot;, row.names = FALSE) これを実行すると、プロジェクトのフォルダの中にある Data フォルダにmy_data.csvが生成される。LibreOfficeやNumbers、Excelなどを使ってmy_data.csvを開いてみると、先ほど作成したデータが保存されていることが確認できる。 図 8.1: my_data.csvの中身 8.2.2 RDataファイル 最後に.RData形式でデータを書き出してみよう。今回は先ほど作成したmy_dataと、以下で作成するnumeric_vec1、numeric_vec2、character_vecをmy_RData.RDataという名のファイルとして Dataフォルダに書き出す。使用する関数は save() である。引数として保存するオブジェクト名をすべてカンマ区切りで書き、最後にfile 引数でファイル名を指定すればよい。 numeric_vec1 &lt;- c(1, 5, 3, 6, 99, 2, 8) numeric_vec2 &lt;- 1:20 character_vec &lt;- c(&#39;cat&#39;, &#39;cheetah&#39;, &#39;lion&#39;, &#39;tiger&#39;) save(my_data, numeric_vec1, numeric_vec2, character_vec, file = &quot;Data/my_RData.RData&quot;) 実際にmy_RData.Rdataファイルが生成されているかを確認してみよう。ファイルの保存がうまくいっていれば、my_RData.Rdataを読み込むだけで、my_data、numeric_vec1、numeric_vec2、character_vec という4つのオブジェクトを一挙に作業スペースに読み込むことができるはずだ。実際にできるか確認しよう。そのために、まず現在の実行環境上にあるmy_ata、numeric_vec1、numeric_vec2、character_vecを削除する。そのために rm() 関数を使う。 rm(my_data) rm(numeric_vec1) rm(numeric_vec2) rm(character_vec) このコードは以下のように1行のコードに書き換えられる。 rm(list = c(&quot;my_data&quot;, &quot;numeric_vec1&quot;, &quot;numeric_vec2&quot;, &quot;character_vec&quot;)) 4のオブジェクトが削除されたか、ls()関数で確認しよう。 ls() ## [1] &quot;EnglishScore&quot; &quot;Excel_DF&quot; &quot;MathScore&quot; ## [4] &quot;my_df1&quot; &quot;ShiftJIS_df1&quot; &quot;ShiftJIS_df2&quot; ## [7] &quot;ShiftJIS_df3&quot; &quot;Stata_DF&quot; &quot;UTF8_df&quot; それではDataフォルダー内のmy_RData.RDataを読み込み、4つのオブジェクトが実行環境に読み込まれるか確認しよう。 load(&quot;Data/my_RData.RData&quot;) # Dataフォルダー内のmy_RData.RDataを読み込む ls() # 作業スペース上のオブジェクトのリストを確認する ## [1] &quot;character_vec&quot; &quot;EnglishScore&quot; ## [3] &quot;Excel_DF&quot; &quot;MathScore&quot; ## [5] &quot;my_data&quot; &quot;my_df1&quot; ## [7] &quot;numeric_vec1&quot; &quot;numeric_vec2&quot; ## [9] &quot;ShiftJIS_df1&quot; &quot;ShiftJIS_df2&quot; ## [11] &quot;ShiftJIS_df3&quot; &quot;Stata_DF&quot; ## [13] &quot;UTF8_df&quot; read.csv()で読み込まれた表は data.frame クラスに、read_csv()関数で読み込まれた表は tibble クラスとして保存される。詳細は第10章で解説する。↩︎ Rのバージョンが4.0.0 未満の場合は、引数としてstringsAsFactors = FALSE を追加する。たとえば、my_df1 &lt;- read.csv(\"Data/FIFA_Women.csv\", stringsAsFactors = FALSE) とする。これを追加しないと、文字列で構成されている列が factor 型として読み込まれる。↩︎ readr パッケージは tidyverse の一部なので、上で読み込み済みである。↩︎ .savファイルはhavenパッケージのread_sav()で、.odsはreadODSパッケージのread.ods()関数で読み込める。↩︎ ちなみにRStudioから確認することもできる。第??章のとおりにRStudioを設定した場合、右下ペインの「Environment」タブに現在の実行環境に存在するオブジェクトが表示されているはずだ。↩︎ 言うまでもないが、データクリーニングのコードと生データも必ず残しておくべきである。↩︎ Excel (.xlsx) も広く使われているが、Excelは有料の商用ソフトであり、もっていない人もいることを忘れてはいけない。矢内も自分のラップトップには Excel （MS Office）をインストールしていない。↩︎ "]]
