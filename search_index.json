[
["index.html", "私たちのR: ぼくらがかんがえたさいきょうのRほん 1. 紹介 1.1 進捗状況 1.2 本書の目的と対象 1.3 著者たち 1.4 本書の構成 1.5 データのダウンロード 1.6 著作権", " 私たちのR: ぼくらがかんがえたさいきょうのRほん 宋財泫 (Jaehyun Song)・矢内勇生 (Yuki Yanai) 最終修正: 2020-07-10 1. 紹介 1.1 進捗状況 章立ては未定です。著者が書きたいものを書いていきます。 全部で25~30章くらいになるかと 章 タイトル 進捗状況 (%) 備考 1 紹介 0 2 R? 75 3 Rのインストール 0 再執筆予定 4 IDEの導入 0 再執筆予定 5 分析の手順 0 6 基本的な操作 80 7 データ型 80 8 データ構造 80 9 Rプログラミングの基礎 85 10 データハンドリング [基礎編: 抽出] 95 11 データハンドリング [基礎編: 拡張] 95 12 データハンドリング [基礎編: factor型] 90 13 整然データ構造 80 13 可視化 10 15 データハンドリング [応用編] 0 16 文字列の処理 0 17 スクレイピング 0 18 R Markdown 5 1.2 本書の目的と対象 『私たちのR: あなたのために書いたわけじゃない』はR界隈の産廃物と神様が一緒に執筆するRプログラミングの入門書です。 注意!! 本書は統計学の本ではありません 注意!! 本書はデータ分析の手法に関する本ではありません。Rを用いたデータ分析については優れた資料が多くあります。とりあえず、『Rによる計量政治学』を購入し暗唱できるまで読みましょう。 つまり、本書が想定している読者は統計学やデータ分析について既に知識を持っている方です。 分析に入るまでの段階、つまりデータの入手やクリーニング方法が知りたい 分析結果を自分好みで可視化したい 複数のモデルを効率的に分析したい ほげほげ Rガチ勢になりたい 本書を読み終えると、著者の中での最弱キャラであるSongのレベルには達します。ただし、矢内のレベルに達するには矢内に生まれ変わる方法以外はありません。現世では諦めましょう。 本書の執筆環境については第20章を参照してください。 1.3 著者たち 図 1.1: 事例研究カフェ前で (Portland, OR. 2016年2月) Song Jaehyun(宋 財泫)1はR初心者です。 Email: jasong@mail.doshisha.ac.jp Webpage: http://www.jaysong.net Twitter: @Tintstyle GitHub: https://github.com/JaehyunSong 矢内勇生先生はRの神様です。主な著書としては聖書の次に売れているという噂の『Rによる計量政治学』(浅野 and 矢内 2018)があります。 Email: yanai.yuki@kochi-tech.ac.jp Webpage: https://yukiyanai.github.io Twitter: @yuki871 GitHub: https://github.com/yukiyanai 1.4 本書の構成 第2章ではR? 第3章ではRおよび統合開発環境の一つであるRStudioのインストールについて解説します。また、本書で頻繁に使うパッケージ群のインストール方法についても解説します。 第4章では本書で用いる統合開発環境 (IDE)であるRStudioの 第5章では 第6章ではRの基本的な操作について説明します。プロジェクト機能を用いたデータの管理、電卓としてのRの使い方、簡単なデータの代入と抽出について解説し、最後はデータの入出力について説明します。 第7章ではRにおけるデータの最小単位であるベクトルのデータ型について説明します。それぞれのデータ型の扱い方については本書を通じて解説していきますので、ここは軽く目を通すだけでも良いかも知れません。 第8章ではデータ構造 第9章ではRプログラミングの基礎 第10章では比較的に綺麗なデータのハンドリング方法 第11章ではデータを拡張する、要約する 第12章ではfactor型 第14章ではデータの視覚化について 第13章では簡潔データ (tidydata)構造について 第15章では 第16章では文字列の処理方法 第17章ではウェブデータの収集方法 第18章ではR Markdown 1.5 データのダウンロード 本書のデータは全て筆者のGitHubレポジトリーから入手可能です。ここではデータのダウンロードの手順について説明します。 本書のGitHubレポジトリーへアクセスします。 レポジトリーURL: https://github.com/JaehyunSong/RBook Dataフォルダーを選択します。 ダウンロードするファイル名を選択します。 「Raw」を右クリックし、「Save Linked Contents As…」を選択します。 保存するフォルダーを指定します。 1.6 著作権 本著作物はクリエイティブ・コモンズ 表示-非営利-改変禁止 4.0国際ライセンスの下に提供されています。 参考資料 "],
["aboutR.html", "2. R? 2.1 Rとは 2.2 Why R? 2.3 GUIとIDE", " 2. R? 2.1 Rとは 図 2.1: R Logo Rは統計、データ分析、作図のためのインタープリタープログラミング言語です。名前の由来は二人の開発者の名前 (Ross IhakaとRobert Clifford Gentleman)です。R言語は完全にゼロベースから開発されたというよりは、原型となる言語があり、それは1976年に開発されたS言語です。S言語もR言語と同様、統計やデータ分析に特化した言語であり、S言語の開発が中止された現在、RはSの正当な後継者とも言えるでしょう。 統計やデータ分析が可能なソフトウェアは星の数ほどあります。社会科学で定量分析の講義を履修したことがある方の多くはSPSSやStataはご存知でしょう。工学系ならMATLABが有名かも知れません。企業ではSASという超高価なソフトもよく使われています。 むろん、お金がないとデータ分析のソフトウェアが使えないわけではありません。優れた無料のソフトウェアも多く公開されております。以下のリストは、そのごく一部にすぎません。 ソフト・言語名 備考 PSPP SPSSに非常に近い無料ソフトウェアです。 JASP/jamovi 裏で動いているのはRです。詳細は本章の後半で gretl 時系列分析など、計量経済学に特化したソフトです。 GNU Octave MATLABとほぼ同じ文法を持つ無料言語です。 HAD 清水裕士先生が開発したExcelベースのデータ分析マクロ 統計分析に特化したプログラミング言語としてのRの競合相手はJuliaとPythonです。とりわけ、Juliaは非常にRに近い感じですが、Rより早いと言われています2。ただし、比較的新しい言語であるため、パッケージがRよりも少ないのがデメリットです。Pythonは現在のデータサイエンス界隈において、Rと共に最も広く使われている言語です。こちらは統計・データ分析に特化した言語ではなく、統計・データ分析のライブラリが非常に充実した言語です。機械学習（とくに、コンピュータービジョン）ではRよりも広く使われています。Python以外の言語、たとえばCやJava、Ruby、Fortranでも統計・データ分析は可能ですし、実際、RやPythonのパッケージの一部はCやJavaで作成されています。ただし、RやPythonに比べ、データ分析のマニュアル・参考書が非常に限られています。 2.2 Why R? 初代R神のHadley Wickham (羽鳥先生)はAdvanced R (2nd Ed.)で以下のように述べています。 It’s free, open source, and available on every major platform. As a result, if you do your analysis in R, anyone can easily replicate it, regardless of where they live or how much money they earn. Rは無料で、オープンソースで、多くのプラットフォーム (macOS, Linux, Windowsなど)で利用可能です。これはあなたがRを用いて分析した場合、誰でも容易に分析を再現できることを意味します。これはあなたの自宅でも、国際宇宙ステーション内でも、あなたに統計ソフトウェアを買うお金が無くても、あるいはF-35が買えるお金があっても同じです。Rの前で万人は平等です。 R has a diverse and welcoming community, both online (e.g. the #rstats twitter community) and in person (like the many R meetups). Two particularly inspiring community groups are rweekly newsletter which makes it easy to keep up to date with R, and R-Ladies which has made a wonderfully welcoming community for women and other minority genders. オンライン (twitterの#rstatなど)、オフライン (TokyoR!など)関係なく多様なRコミュニティーがあります。他にも最新のRをキャッチアップするためのニュースレターであるrweeklyや、女性と性的マイノリティーのためのコミュニティーであるR-Ladiesも活発に活動しています。 A massive set of packages for statistical modelling, machine learning, visualisation, and importing and manipulating data. Whatever model or graphic you’re trying to do, chances are that someone has already tried to do it and you can learn from their efforts. 統計モデリング、機械学習、可視化、データ読み込みおよびハンドリングのための膨大なパッケージが用意されています。どのようなモデルやグラフでも、誰かが既に必ずそれを試みており、あなたは彼女らの努力から勉強することができます。 Powerful tools for communicating your results. RMarkdown makes it easy to turn your results into HTML files, PDFs, Word documents, PowerPoint presentations, dashboards and more. Shiny allows you to make beautiful interactive apps without any knowledge of HTML or javascript. 分析結果を共有する強力なツールを提供しています。RMakrdownは分析結果をHTML、PDF、Word、PowerPoint、Dashboard形式に変換してくれます。HTMLやjavascriptお知識がなくてもShinyを使って美しい対話側のアプリケーションを開発することも可能です。 RStudio, the IDE, provides an integrated development environment, tailored to the needs of data science, interactive data analysis, and statistical programming. 代表的な統合開発環境であるRStudioはデータサイエンス、対話型のデータ分析、そして統計的プログラミングが必要とするものに最適されています。 Cutting edge tools. Researchers in statistics and machine learning will often publish an R package to accompany their articles. This means immediate access to the very latest statistical techniques and implementations. 最先端のツールです。多くの統計学や機械学習の研究者は自分の研究成果とRパッケージを同時に公開しています。これは最先端の方法を誰よりも早く実施可能にします。 Deep-seated language support for data analysis. This includes features like missing values, data frames, and vectorisation. データ分析を根強くサポートする言語です。欠損値、データフレーム、ベクトル化などがその例です。 A strong foundation of functional programming. The ideas of functional programming are well suited to the challenges of data science, and the R language is functional at heart, and provides many primitives needed for effective functional programming. Rはデータサイエンスに非常に有効である関数型プログラミングのための最適な環境を提供しています。 RStudio, the company, which makes money by selling professional products to teams of R users, and turns around and invests much of that money back into the open source community (over 50% of software engineers at RStudio work on open source projects). I work for RStudio because I fundamentally believe in its mission. 営利企業であるRStudio社ですが、その収益の多くをオープンソースコミュニティーに投資しています。 Powerful metaprogramming facilities. R’s metaprogramming capabilities allow you to write magically succinct and concise functions and provide an excellent environment for designing domain-specific languages like ggplot2, dplyr, data.table, and more. メタプログラミングが強力です。Rが持つメタプログラミング能力はあなたのコードを劇的に簡潔にするだけでなく、統計/データ分析に特化したggplot2、dplyr、data.tableなどの開発も可能にしました。 The ease with which R can connect to high-performance programming languages like C, Fortran, and C++. RはC、C++、Fortranのようなハイパフォーマンス言語と容易に結合できるように設計されています。 しかし、他のプログラミング言語と同様、Rは完璧な言語ではありません。以下はR言語の短所の一部です。その多くはRそのものの問題というよりも、(プログラマーではなく)データ分析の研究者が中心となっているRユーザーから起因する問題です。 Much of the R code you’ll see in the wild is written in haste to solve a pressing problem. As a result, code is not very elegant, fast, or easy to understand. Most users do not revise their code to address these shortcomings. あなたが普段見る多くのRコードは「今の」問題を解決するために迅速に書かれたものです。この場合、コードはあまりエレガントでも、速くも、読みやすくありません。ほとんどのユーザーはこの短所を克服するためのコード修正を行っておりません。 Compared to other programming languages, the R community is more focussed on results than processes. Knowledge of software engineering best practices is patchy. For example, not enough R programmers use source code control or automated testing. 他のプログラミング言語に比べ、Rコミュニティーは過程よりも結果に注目する傾向があります。多くのユーザーにおいて、ソフトウェアエンジニアリングの知識を蓄えるための方法が不完全です。たとえば、(GitHubなどの) コード管理システムや自動化された検証を使用するRプログラマーは多くありません。 Metaprogramming is a double-edged sword. Too many R functions use tricks to reduce the amount of typing at the cost of making code that is hard to understand and that can fail in unexpected ways. Rの長所でもあるメタプログラミングは諸刃の剣です。あまりにも多くのR関数はコーディングのコストを減らすようなトリックを使用しており、その代償としてコードの理解が難しく、予期せぬ失敗の可能性があります。 Inconsistency is rife across contributed packages, and even within base R. You are confronted with over 25 years of evolution every time you use R, and this can make learning R tough because there are so many special cases to remember. 開発されたパッケージは、R内蔵のパッケージさえも一貫性が乏しいです。あなたはRを使う度にこの25年を超えるRの進化に直面することになります。また、Rには覚えておくべきの特殊なケースが多く、これはR学習の妨げとなっています。 R is not a particularly fast programming language, and poorly written R code can be terribly slow. R is also a profligate user of memory. Rは格別に速い言語ではありません。下手に書かれたコードは驚くほど遅いです。また、Rはメモリの浪費が激しい言語と知られています。 2.3 GUIとIDE 2.3.1 GUI CUIとGUI 現在、多くのソフトウェアはGUIを採用しています。GUIとはGraphical User Interfaceの略で、ソフトウェア上の入力および出力においてグラフィックが使用されることを意味します。単純にいうと「マウスでポチポチするだけで操作できる環境」です。一方、Rは基本的にCUI (Character User Interface)を採用しています3。これは全ての操作を文字列、つまりキーボードで行うことを意味します。 身近な例で例えると、あるラーメン屋での注文（呪文）システムを考えてみましょう。無料トッピングを指定する時に「決まった言い方」で指定するのがCUIです。ちなみに、一文字でも間違ってしまったらオーダーは通りません。たとえば、「野菜マシマシッ!」と言ってしまうと、店長さんに「は？」と言われます4。一方、食券発売機でトッピングが指定できるのがGUIです5。この場合、そもそも間違いは起きません。 図 2.2: CUIとGUIの比較 CUIとGUI、普通に考えたらGUIが優れているように見えます。マウスでポチポチするだけで操作できるなら楽ですし、間違いの心配もない。キーボードで長いコマンドを打つCUIよりも時間的にも節約できるでしょう。コマンドを覚えるのもしんどいですね。 しかし、必ずしもそうでもありません。CUIはCUIなりの長所があります。まず、コードが記録できます。マウスでポチポチした操作は録画でもしない限り、自分の分析プロセスを残すことが難しいです。一方、全てコマンドで操作した場合、入力したコマンドを記録しておくだけで済みます。また、GUIよりも柔軟である長所もあります。先ほどのラーメン屋の話ですが、CUIだと「一応」野菜ちょいマシのような注文（呪文）も可能です6。しかし、GUIだとそもそも不可能ですね。また、コマンドの入力の時間や暗記も今は後で説明する超有能な秘書であるIDEのおかげで問題になりません。スペルが間違っているか、うろ覚えのコマンドなども今のIDEは瞬時に教えてくれます。 本書はCUIとしてのRについて解説します。なぜなら、本書はRを用いたデータ分析の本ではなく、言語としてのRを対象にしているからです。Rは統計ソフトでありながら、言語でもあります。プログラミング言語は基本的にコードを書く作業の連続です。したがって、CUI以外の選択肢はありません。 データ分析が目的で、それでもやはりGUIの方がとっつきやすいという方のために、ここでは代表的なRのGUIを紹介します。そしてこの本は閉じてください。本書はデータ分析の本ではありません。 図 2.3: R Commander R Commander 図 2.4: RKWard RKWard 図 2.5: JASP JASP 図 2.6: jamovi jamovi 図 2.7: RAnalyticFlow (画像は公式ホームページから) R AnalyticFlow 2.3.2 IDE プログラミングは基本的にコードを書く作業の連続ですが、他にも様々な作業が含まれています。たとえば、自分が書いたコードの結果が正しく作動するかの確認、なにか問題がある場合の対処などもあるでしょう。また、コードを書く際、誤字やミスなどがないかも確認する必要があります。他にもプログラムで使用されるファイルの管理もありますね。これらの仕事を手助けしてくれるのが統合開発環境 (IDE)と呼ばれるものです。IDEはIntergrated Deveolopment Environmentの略です。 プログラマーにとって優れたIDEを使うということは、優れた秘書さんを採用するようなものです。ファイルの管理、うろ覚えのコマンドを教えてくれる、コードの色分けを自動的にしてくれる、コードを走らせた結果の画面をコードと同時に表示してくれる、これまでの作業履歴を教えてくれるなど、多くの作業を手助けしてくれます。Rにもいくつかの優れたIDEがありますが、本書では代表的なIDEであるRStudioを使います。ただし、プログラミングでIDEは必須ではありません。IDEをインストールしなくても、本書を読むには問題ありませんが、これからRで様々な分析をしていくにはRStudioの導入を強く推奨します。 RStudio以外のIDEもあります。とくに、もしWindowsというOSを使用しているなら、R Tools for Visual Studioも有力な候補の一つです。 図 2.8: RStudio 図 2.9: R Tools for Visual Studio 他にも使い慣れているテキストエディターをIDEとして使うことも可能です。Sublime TextやAtomはむろん、伝統のあるEmacsやVimをIDEとして使うことも可能です。 Rもコードの書き方によってパフォーマンス向上ができます。↩︎ または、CLI (Command Line Interface)とも呼ばれます。↩︎ 全ての「ラーメン◯郎」がそうではありません。↩︎ 「◯蘭」の注文システムのようですね。↩︎ 通るかどうかは別ですが…↩︎ "],
["installation.html", "3. Rのインストール 3.1 Rのインストール 3.2 .Rprofileの設定 3.3 RStudio 3.4 パッケージのインストール", " 3. Rのインストール 以下の内容はどうでもいいから、とりあえずこれを読め。 R神による資料 (macOS編、Linux (Ubuntu)編、Windows編) 3.1 Rのインストール 3.1.1 macOSの場合 3.1.1.1 前準備 Xcodeの入手 Command Line Tools? XQuartz clang, gfortran, tcltk? http://mac.r-project.org/tools/ 3.1.1.2 Rのダウンロードとインストール 3.1.2 Linuxの場合 Linuxの場合、ディストリビューション (distribution)7によってインストール方法がやや異なります。詳細はCRANを参照して頂きますが、ここでは個人用OSとして広く使われているUbuntu 18.04.4 LTSの例を紹介します。 図 3.1: Terminalの起動 まず、Terminal (端末)を立ち上げます。Terminalはデスクトップ画面で右クリックし、「Open Terminal (端末を開く)」を選択します。Terminalプロンプト上に以下のように入力します。 sudo apt-get install r-base パスワードを入力すれば、Rがインストールされます。インストールされたRするにはいくつかの方法があります。1つ目はTerminal上で R と入力するだけです。 図 3.2: Applicationから起動1 2つ目の方法はApplicationから開く方法です。Ubuntuの左上の「Activities (アクティビティ)」または、左下のボタンをクリックします。 図 3.3: Applicationから起動2 上段中央の検索で「R」を入力し、検索結果からRを選択します。 図 3.4: R Console 図3.4のような画面が表示されたらRはインストールは完了です。 3.1.3 Windowsの場合 R 4.0.0ではOneDriveとの同期問題がなくなったという噂も…? 3.1.3.1 前準備 Rをインストールする前に以下の2点を確認します。 自分のWindowsがOneDriveと連携している8 ユーザー名が日本語になっている9 一つ以上当てはまる場合、以下の手順で前準備をします。どれも該当しない場合、次節に移りましょう。 OneDriveとの連携を確認する方法 そもそもOneDriveがインストールされていないなら、問題ありません。 タスクバー (画面下段のバー)の右側にあるOneDriveのアイコンをクリックし、「その他」&gt;「設定」 「バックアップ」タブの「バックアップを管理」をクリック 真ん中の「ドキュメント」の列に「ファイルはバックアップされました」と表示されている場合、WindowsとOneDriveが連携していることを意味します。 OneDirveとの連携を解除する方法 「バックアップを停止」をクリックします10。 ユーザー名の確認方法 「設定」&gt;「アカウント」 でかいアイコンの下にユーザー名が表示されていますが、ここが日本語になっていると、ユーザー名は日本語ということになります。 解決方法 新しいユーザーを生成するのが手っ取り早いです。詳しい手順はここから確認できます。 3.1.3.2 Rのダウンロードとインストール 図 3.5: Rのインストール1 (Windows) CRAN (https://cran.r-project.org/)にアクセスし、「Download R for Windows」を選択します。 図 3.6: Rのインストール2 (Windows) 「base」を選択します。 図 3.7: Rのインストール3 (Windows) 「Download R x.x.x for Windows」を選択し、インストーラーをダウンロードします。 インストールの途中、コンポーネントの選択画面が表示されます。「Core File」と「Message translation」にはチェックを入れますが、自分のパソコンのbitによって32bitか64bitかが決まります。多くの場合、64bitで問題ありませんが、以下のような方法で確認できます。 図 3.8: bitの確認 (1) デスクトップ画面のPCを右クリックし、「プロパティ」を選択 図 3.9: bitの確認 (2) 「システムの種類」を確認 3.1.3.3 Rtoolsのインストール 3.2 .Rprofileの設定 3.3 RStudio 3.3.1 RStudioのインストール RStudioのインストール方法はもっと簡単です。 図 3.10: RStudioのインストール1 まず、RStudioのホームページ (https://rstudio.com)にアクセスし、「Download」をクリックします。 図 3.11: RStudioのインストール2 RStudio Desktopの「Download」を選択します。 図 3.12: RStudioのインストール3 自分のOSに合ったインストーラーをダウンロードします11。 ダウンロードしたインストーラーを実行すると、 macOSの場合、RStudioのアイコンをApplicationフォルダーに移動させます。 Ubuntuの場合、Ubuntu Softwareが起動されます。「Install」をクリックするだけです。 Windowsの場合、自動的にインストーラーが起動されます。指示に従ってインストールします。 3.3.2 RStudioの起動と設定 とりあえずインスールされたRStudioを立ち上げてみましょう。図3.13のおような画面が表示されたら問題なくRStudioがインストールされていると考えて良いでしょう。図3.13と完全に同じ画面が表示されなくても問題ゴザ会いません。 図 3.13: RStudioの初期画面 3.3.3 RStudioの設定 このままでもRプログラミングはできます。前章で説明したように、RStudioのようなIDEはプログラミングにおける有能な秘書さんです。もっと自分の好みに合わせてカスタマイズすれば、コーディングも捗るでしょう。せっかくIDEをインストールしましたし、より便利に使えるようにRStudioの設定を変えてみましょう。 RStudioの設定を変えるには「Tools」の「Global Option」を選択します。 左側から「General」を選択します。 左側から「Code」を選択します。 「Editing」タブを選択します。 「Display」タブを選択します。 最後にRStudio画面の設定をしましょう。今のままでももんだいありませんが、快適なコーディングのためには、できる限りコードの画面を大きくする必要があります。そのためには、あまり使わない機能はどこかの領域に集め、最終的には最小化させて見えないようにします。 メニュー「Tools」から「Global Option」を選択します。 左側から「Pane」を選択します。 それぞれの領域を図3.14のように設定します。 ちなみに、RStudioのテーマやフォントなどの設定は「Apperance」から調整できます。 「OK」を押してRStudioの画面に戻ったら、左下Paneの最小化ボタン (図3.14の赤い四角形)をクリックし、最小化します。 図 3.14: Pane設定後 3.4 パッケージのインストール 3.4.1 パッケージのインストール Rの環境は何かを作るための作業台に似ています。作業台にはモノを作るために材料だけでなく、工具・道具セットなども置いたりしますね。この作業台がRにおける「環境 (environment)」であり、材料がベクトルや行列、データフレームなどのデータ、工具セットがパッケージになります。データについては後で説明するとし、ここではパッケージについて考えたいと思います。 モノを作るためには素材・材料だけでは不十分でしょう。多くの場合、なんらかの道具セットが必要となります。Rには既にいくつかの必須道具セットを用意しておりますが、他にも様々な道具セットがあります。一般的に道具セットには複数の道具が含まれています。一つ一つの道具のことを、ここでは「関数 (function)」と呼びます。これらの道具セットを購入し、作業台の収納に入れておくことがパッケージをインストールすることです。 install.packages(&quot;パッケージ名&quot;) これらのパッケージは基本的にCRANという道具屋からダウンロード・インストールされます。もう一つの大きな道具屋としてはGitHubがあります12。GitHubは個人経営の道具屋が集まっているモールのようなものです。GitHub道具屋を使用するためには予めCRANからdevtoolsというパッケージをインストールしておく必要があります。 もし、CRANに登録されていないパッケージをGitHubからインストールするなら、devtoolsパッケージのinstall_github()関数を使います。 install.packages(&quot;devtools&quot;) devtools::install_github(&quot;作成者のGitHubのID/パッケージ名&quot;) たとえば、筆者（Song）が作成しましたBalanceRパッケージがインストールしたいなら、 devtools::install_github(&quot;JaehyunSong/BalanceR&quot;) #または library(devtools) # library()関数については後述 install_github(&quot;JaehyunSong/BalanceR&quot;) のように打ちます。ここでJaehyunSongはSongのGitHub IDであり、BalanceRはパッケージ名です。 3.4.2 パッケージの読み込み 先ほど申しましたように、パッケージのインストールは道具セットの購入と収納に似ています。ただし、実際に道具セットを使うためには、それを自分の作業台上に載せた方が効率がいいでしょう13。この作業がパッケージの読み込み(load)です。インストールしたパッケージを読み込むにはlibrary()またはrequire()関数を使います。require()は関数内に使う目的で設計された関数ですが、パッケージを読み込むという点では全く同じです。 library(&quot;パッケージ名&quot;) #または require(&quot;パッケージ名&quot;) 読み込まれたパッケージはセッションが開かれている時のみに有効です。一通りの作業が終わり、作業部屋から退出すると、作業台上の道具セットは収納に自動的に戻されます。つまり、RまたはRStudioを閉じると読み込まれたパッケージは自動的に取り外されるということです。しかし、作業の途中に読み込んだパッケージをセッションから取り外したい時があるかも知れません（あまり、ないような…）。この場合、detach()関数を使います。 detach(&quot;パッケージ名&quot;) 図 3.15: 無料イメージほしい 3.4.3 必須パッケージのインストール ここでは現在のRにおいて必須パッケージである、tidyverseを紹介します。tidyverseはdplyr、ggplot2、tidyrなど、Rにおいて不可欠なパッケージを含むパッケージ「群」です。また、前節で紹介しましたdevtoolsも今のうちにインストールしておきましょう。むろん、前節ですでに導入済みの方は2行目は不要です。 install.packages(&quot;tidyverse&quot;) install.packages(&quot;devtools&quot;) 3.4.4 パッケージのインストールが出来ない場合 (Ubuntu) パッケージのインストールの祭、エラーが出る場合があります。とりわけ、R導入直後は必要とするライブラリがインストールされていないケースが多く、以下のようなエラーメッセージが表示されるケースがあります。 図 3.16: 必要なライブラリがない場合 これはxml2パッケージをインストールしようとした時に表示されたメッセージです。これはUbuntuにlibxml-2.0というライブラリが入っていないことを意味します。解決方法は、このライブラリを導入することですが、OSによってインストールに必要なライブラリ名が異なります。UbuntuはDebian系列のOSであるため、deb行を確認します。どうやらlibxml2-devをインストールすれば良いようです。したがって、新しいTerminalを起動し、Rと同じやり方でlibxml2-devをインストールします。 sudo apt-get install libxml2-dev もう一回xml2をインストールすれば、問題なくインストールされるでしょう。 よく使われるディストリビューションとしてはDebian系とRed Hat系があります。シェアトップレベルのUbuntuとMintはDebian系です。ちなみに、個人向けのRed Hat Linuxは開発中止され、現在はFedoraに受け継がれています。Red Hat系ではFedoraだけでなく、CentOSも広く使われています。最近はarch linux系のmanjaro linuxも人気です。人気ディストリビューションにつしてはDistroWatch.comから最新ランキングを確認してください。↩︎ この場合、パッケージのインストールがうまくできない可能性があります。↩︎ RStudioが起動しない可能性があります。↩︎ 普段OneDriveのバックアップ機能を使用している場合、この方法は推奨できません。↩︎ Linuxの場合、OSとそのバージョンによってダウンロードするインストーラーが異なります。現時点 (2020年3月)におけるUbuntuの安定版は18.0.4.4ですので、この場合、「Ubuntu 18/Debian 10」を選択します。↩︎ 他にもGitLab、Bitbucketなどがあります。↩︎ 作業台上に載せずに、収納から必要な時だけ道具を取り出して使うことも可能です。この場合、パッケージ名::関数名()のように関数を使います。よく使うパッケージなら読み込んだ方が効率的ですが、1、2回くらいしか使わないパッケージなら、このような使い方も良いでしょう。↩︎ "],
["ide.html", "4. IDEの導入 4.1 RStudioのインストールと起動 4.2 RStudioの設定 4.3 RStudio Cloudについて", " 4. IDEの導入 4.1 RStudioのインストールと起動 4.1.1 macOSの場合 4.1.2 Linux (Ubuntu)の場合 4.1.3 Windowsの場合 4.2 RStudioの設定 4.2.1 設定画面の開き方 4.2.2 私たちのRStudio 4.3 RStudio Cloudについて これまでRとRStudioの導入について説明しましたが、これは自分のパソコンにインストールすることを前提としていました。したがって、パソコンを新しく買ったり、複数のパソコンを持つ場合は、それぞれに対してインストールと設定をする必要があります。これらの作業は慣れれば大したことではありませんが、それでも面倒だと思う方もいるでしょう。また、それぞれのパソコンにRとRStudioをインストールして常に同じ環境を維持するのも手間のかかる作業です。そこで一つの対案となるのがRStudio Cloudです。 図 4.1: RStudio Cloudの起動画面 (Operaの場合) RStudio Cloudはサーバー上にインストールされているRとRStudioをインターネットブラウザ14で動かすことができるサービスです。インターネットさえ接続されていれば、図4.1のように、どこでも同じ環境のRとRStudioを使用することができます。また、無料です。ブラウザ上で操作できるため、スマートフォンやタブレットPCでも操作は不可能ではありませんが、基本的にはPCでの操作を想定しています。 これだけだとRStudio Cloud最強説とかがあってもおかしくはありませんね。しかし、ブラウザ上で動くという点でローカルのRStudioよりもやや重いです。また、PCとは違って、メモリの増設もできませんし、マルチコアの使用も非常に制約されています。Tcl/Tkを使用するパッケージの起動はできない限界もあります。また、日本語ユーザー限定の問題かもしれませんが、図に日本語を含む2バイト文字を埋め込むのが非常に面倒くさい問題もあります。 本書はローカルにインストールされているRとRStudioを念頭に置いて解説しますが、RStudio Cloudでも問題なく本書の実習が可能です15。RStudio Cloudの使い方は適宜インターネットなどで検索してみてください。 Chrome、 Firefox、 Opera、Safari、Edgeなど↩︎ ただし、図に日本語は入力できません。↩︎ "],
["process.html", "5. 分析の手順", " 5. 分析の手順 "],
["rbasic.html", "6. 基本的な操作 6.1 「プロジェクト」のすゝめ 6.2 電卓としてのR 6.3 格納（代入） 6.4 要素の抽出 6.5 データの読み込み 6.6 データの書き出し 6.7 演習問題", " 6. 基本的な操作 目次 第6.1章: 「プロジェクト」のすゝめ 第6.2章: 電卓としてのR 第6.3章: 格納（代入） 第6.4章: 要素の抽出 第6.5章: データの読み込み 第6.6章: データの書き出し 第6.7章: 練習問題 6.1 「プロジェクト」のすゝめ ファイルシステムについて Rを起動する前にコンピューターのファイルシステムについて解説します。私たちが使用しているコンピューターには数千〜数万（あるいはそれ以上）のファイルが含まれています。これらのファイルは基本的には一つのハードディスクドライブ (Hard Disk Drive; HDD)、またはソリッドステートドライブ (Solid State Drive; SSD)に保存されています。これらのファイルを管理する際、全てのファイルが一箇所に集まっていたらどうなるでしょうか（下の図の左側）。 図 6.1: ファイルシステムの例 3年分の日記だけでもファイル数は1000個以上であり、分析のファイル、またソフトウェアやOSを構成するファイルまで考えるとファイル数は数えることすらも困難でしょう。ここから必要なファイルを探すの大変ですし、それぞれのファイルがどの目的で作られたファイルかを把握することも難しいです。また、多くのソフトウェアでは「よく使われているファイル名」があります。しかし、全てのファイルが一箇所に集まっていると、同じファイル名を使うことも出来ません。この困難を解決するために、多くのOSではこれらのファイルをグループとして管理します。このグループをmacOSやLinuxでは「フォルダー (folder)」、Windowsでは「ディレクトリ (directory)」と呼びます。上の図の右側はファイルをフォルダーに分けたものです。フォルダーの中にフォルダーをが入ることも可能です。たとえば、日記はとりあえず年で分けて、その中で月単位でフォルダーを分けることも可能でしょう。 これからRを使ってプログラミング、データ分析を進めていくと数百、いや数万以上のファイルが生成されます。これらには自分が作成したコードや図表以外にも、R側から自動的に生成されるファイルも含まれます。効率よくプログラミングを行うためには、これらのファイルをきちんと管理する必要があります。 フォルダーの概念を導入することでファイルの管理がより楽になったかというと、必ずしもそうとは限りません。逆に不便になったところもあります。それはファイルの入出力先の指定が必要になったことです。パソコン内の全てのファイルが一箇所に集まっているとします。この場合、ファイルの居場所は全て共通であるため、ファイルが「どこにあるか」は気になりません。しかし、フォルダーでファイルが区切られている場合、2019年10月8日の日記 (20191008.txt)を読み込むにはそのフォルダーを全て指定する必要があります。20191008.txtはDiaryフォルダー内の2019フォルダー内のOctoberフォルダーにあります。パソコンではあるファイルの居場所を表現する際、そのファイルが入っているフォルダーの経路を全て明記する必要があります。とたえば、macOSだと/Users/jaehyunsong/Diary/2019/October/20191008.txtになります。これを「パス (path)」とも言います。ちなみに、macOSの最上位フォルダーは/です。ただし、自分が現在作業中のフォルダー（ワーキングディレクトリ; working directory）が/Users/jaehyunsong/ならDiary/2019/October/20191008.txtと表記しても構いません。この場合、パスの最初に/が含まれていません。このようなパスの書き方が「相対パス (relative path)」と呼ばれるものです。相対パスは自分が作業中のフォルダーを基準としたパスです。最上位である/から始まるパスの書き方は「絶対パス (absolute path)」、または「フルパス (full path)」と呼ばれます。これは最上位フォルダーを基準としたパスです。 ファイルをフォルダーで区分することによってファイルの管理は楽になった一方、ファイルの読み込み、書き出しの際には、その場所まで指定しなくてはなりません。現在のパソコンは非常に複雑なフォルダーの構成になっており、それらを一々入力するのは時間の無駄でしょうし、覚えるのも大変です。。 プロジェクト そこで登場するのがRStudioで提供している「プロジェクト」という機能です。 たとえば、macOSのRの場合、デフォルトのワーキングディレクトリは/Users/ユーザー名です。もし、分析に使うデータが、DocumentsフォルダーのRフォルダーのAnalysis1フォルダー内のDataフォルダーにあるdata.csvだとしたら、これらを読み込むためにはread.csv(\"Documents/R/Analysis1/Data/data.csv\")と入力する必要があります。図を出力ためにもこれらのパスを全て入力せねばなりません。もし、ワーキングディレクトリが/Users/ユーザー名/Documents/Analysis1ならどうでしょうか。この場合、read.csv(\"Data/data.csv\")だけで済みます。プロジェクトとは特定のフォルダーをワーキングディレクトリにし、全ての作業を、そのフォルダーと下位フォルダーのみに限定してくれる機能です。全てのコードとデータ、出力物などが一つのフォルダー内に集約され、管理が非常に楽になります。 それではプロジェクトの作り方について説明します。 図 6.2: FileからNew Project… 「File」から「New Project」を選択します 図 6.3: New Directoryを選択 「New Directory」を選択します。 予めプロジェクト用のフォルダーを用意した場合は「Existing Directory」を選択します。 図 6.4: New Projectを選択 「New Project」を選択します。 前段階で「Existing Directory」を選択した場合、この画面は表示されません。 図 6.5: プロジェクト名と保存場所の指定 「Directory name:」にプロジェクト名を入力します。これがフォルダー名にもなりますので、出来る限り英数字のみにしましょう。ここでは第4章のコードということで、Ch04にしました。また、「Create project as subdirectory of:」から「Browse…」をクリックし、プロジェクトのフォルダーが入る上位のフォルダーを指定します。私は/Users/jaehyunsong/Dropbox/RStudyにプロジェクトのフォルダーを入れるとします16。ここまで出来たら、下の「Create Project」をクリックします。 「Existing Directory」を選択した場合、プロジェクトのフォルダーとして使うフォルダーを指定する画面が表示されます。 図 6.6: プロジェクトの確認 ~/Dropbox/RStudy/にCh04フォルダーが生成されていることを確認します。また、Ch04にはCh04.Rprojというファイルが生成されています。今後、Ch04プロジェクトを開く際は、このファイルをダブルクリックするだけでできます。 6.2 電卓としてのR それでは、早速Rを使ってみましょう。まず、「File」メニューから「New File」-「R Sciprt」を選択しましょう。予め指定したペイン (pane)にコードが入力できるようになります。ここで3 + 3と入力し、この行でmacOSだとCmdとEnterキーを、WindowsだとControlとEnterキーを押してみましょう。 図 6.7: コード入力の例 Consoleペインに入力したコードが自動的に転送され、その結果まで表示されます。RのコードはConsoleペインから直接打ち込むのも可能ですが、Sourceペインで入力すれば、これまでのコードの履歴も確認できますし、保存もできます。したがって、コードは基本的にR Sciprt上に書きましょう17。 それでは、以下の例を直接打ち込み、実行結果を確認してみましょう。灰色に網掛けされている箇所は直接R上で打ち込むコマンドです。ただし、##から始まるブロックは計算の結果です。また、コードブロックで#で始まる行はコメントであり、分析に影響を与えません。コメントの使い方などについては第18章で解説します。 6.2.1 算術演算子 まずは、簡単な足し算と掛け算をやってみましょう。 3 + 3 ## [1] 6 8 * 2 ## [1] 16 むろん、引き算や割り算もできます。よく使うRで使える算術演算子は以下の通りです。 演算子 意味 例 結果 + 足し算 2 + 5 7 - 引き算 2 - 8 -6 * 掛け算 7 * 3 21 / 割り算 16 / 5 3.2 ^、** 累乗 2^3または2 ** 3 8 %% 剰余 18 %% 7 4 %/% 数商 18 %/% 7 2 6.2.2 論理演算子 論理演算子とは、入力した式が正しいか間違っているかを判定する演算子です。返り値は必ずTRUEかFALSEです。正しいと判定された場合はTRUEが、間違っている場合はFALSEが表示されます。たとえば、「3は2より大きい」というのは正しいので、TRUEです。一方、「2 + 3は1である」は間違っているため、FALSEです。やってみましょう。 3 &gt; 2 ## [1] TRUE 2 + 3 == 1 ## [1] FALSE 論理演算子にもいくつかの種類があります。 演算子 意味 例 結果 1 x &lt; y xはyより小さい 3 &lt; 1 FALSE 2 x &lt;= y xはyと同じか、小さい 2 &lt;= 2 TRUE 3 x &gt; y xはyより大きい 6 &gt; 5 TRUE 4 x &gt;= y xはyと同じか、大きい 4 &gt;= 5 FALSE 5 x == y xとyは同じである (2 + 3) == (4 + 1) TRUE 6 x != y xとyは同じでない ((2 * 3) + 1) != (2 * (3 + 1)) TRUE 6番目の例について説明します。算数でもそうですが、Rも括弧()内の記述を優先的に計算します。したがって、!=左側の((2 * 3) + 1)は6 + 1 = 7であり、右側の(2 * (3 + 1))は2 * 4 = 8です。結果的には7 != 8が判定対象となり、TRUEが返されます。 論理演算子は基本的に数字を対象に使いますが、TRUEとFALSEを対象に使うものもあります。それがand (&amp;)とor (|)演算子です。&amp;は両側全てがTRUEの場合のみTRUEが返され、|は一つでもTRUEならTRUEが返されます。 演算子 意味 例 結果 1 x | y xまたはy (2 + 3 == 5) | (1 * 2 == 3) TRUE 2 x &amp; y xかつy (2 + 3 == 5) &amp; (1 * 2 == 3) FALSE 1番目の例を見ましょう。|の左側は(2 + 3 == 5)であり、TRUEです。一方、右側の(1 * 2 == 3)はFALSEです。判定対象はTRUE | FALSEとなり、返り値はTRUEです。2番目の例はTRUE &amp; FALSEであるため、返り値はFALSEです。 6.3 格納（代入） まず、123454321 * 2の計算をしてみましょう。 つづいて、123454321 * 3の計算をしてみましょう。 最後に、123454321 * 4の計算をしてみましょう。 別に難しくも、面倒くさくもない内容でしょう。それでも、「123454321を三回も入力するのは面倒くさい！」と思う方はいるかも知れません18。もし、123454321という数字をxとかaといった名前に置換できるなら、先ほどの作業はより楽になるでしょう。ここではその方法について解説します。 xというものに123454321という数字を入れる場合、&lt;-演算子を使います。これはxという名のもの (=オブジェクト)に123454321という数字を代入するということです。ここでは「代入」という表現を使いましたが19、&lt;-の役割はより広いので、これからは「格納」という表現を使います。それではオブジェクトxに123454321を格納してみましょう。 x &lt;- 123454321 # xに123454321を格納 x ## [1] 123454321 オブジェクト名をそのまま打つと、その中身が表示されます。print(x)でも同じ結果が得られますが、出来る限り打ち込む字数を減らしたいのでxのみにします。ちなみに、格納と同時にそのオブジェクトの中身を表示させることもできます。そのためには()を使います。それでは、yに2を代入し、すぐ中身を表示させてみましょう。 (y &lt;- 2) # yに2を格納し、中身を表示 ## [1] 2 これからはいちいち123454321と入力せずにxだけで済みます。x * 2、x * 3といった形式です。 x * 2 ## [1] 246908642 x * 3 ## [1] 370362963 x * 4 ## [1] 493817284 文字列を格納することも可能です。ただし、文字列は必ず\"か'で囲む必要があります。 x &lt;- &quot;矢内先生すげぇ&quot; print(x) ## [1] &quot;矢内先生すげぇ&quot; オブジェクトに格納できるデータの構造は一つの数値また、文字列だけではありません。複数の数値や文字列を格納することも可能です。そのためにはc()という関数を使います。c()の中に入れたい数値列または文字列をコンマ (,)区切りで入力します。 # (1, 6, 3, 6, 99, 2, 8)をnumeric_vec1に格納する numeric_vec1 &lt;- c(1, 5, 3, 6, 99, 2, 8) print(numeric_vec1) ## [1] 1 5 3 6 99 2 8 むろん、複数の文字列を格納することもできます。 character_vec &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;) print(character_vec) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; もし、ある整数から他の整数まで、1間隔の数列を作るなら:が便利です。もし、numeric_vec2という名のオブジェクトに1から10を1刻みで格納するなら、普通はnumeric_vec2 &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)といった書き方をするでしょう。しかし、numeric_vec2 &lt;- 1:10と書くことで、労力を大幅に減らすことができます。 numeric_vec2 &lt;- 1:10 print(numeric_vec2) ## [1] 1 2 3 4 5 6 7 8 9 10 # 逆の順序も可能です print(10:1) ## [1] 10 9 8 7 6 5 4 3 2 1 ほかにも、「1から10まで奇数のみ格納したい」場合はどうでしょう。c(1, 3, 5, 7, 9)と書くことも可能ですが、10まででなく、1000までだとかなりの重労働です。この場合はseq()関数を使います。seq()関数には3つの引数が必要であり、それぞれ、最小値、最大値、間隔です。「1から10まで2間隔」ならseq(1, 10, 2)と書きますが、3番目の引数は引数の名称 (by =)も明記することをおすすめします。したがって、おすすめの表記法はseq(1, 10, by = 2)となります20。 numeric_vec3 &lt;- seq(1, 10, by = 2) print(numeric_vec3) ## [1] 1 3 5 7 9 6.4 要素の抽出 ベクトルから一部の要素を抽出する場合、オブジェクト名の後に[抽出する要素の場所]を加えます。 # numeric_vec1の5番目の要素を抽出 numeric_vec1[5] ## [1] 99 # numeric_vec1の2, 4, 6番目の要素を抽出 numeric_vec1[c(2, 4, 6)] ## [1] 5 6 2 # numeric_vec1の5番目から7番目の要素を抽出 numeric_vec1[5:7] ## [1] 99 2 8 c()や:が使えるということはseq()も使えるということでしょう。 # numeric_vec2の奇数番目の要素を抽出 numeric_vec2[seq(1, 10, by = 2)] ## [1] 1 3 5 7 9 他のやり方として、TRUEとFALSEを使うこともできます。この場合、抽出したい要素の場所を指定するのではなく、全ての場所に対して抽出するか (TRUE)、しないか (FALSE)を指定することになります。たとえば、character_vecから1, 3, 4番目の要素を抽出するなら、[c(TRUE, FALSE, TRUE, TRUE)]と指定します。 character_vec[c(TRUE, FALSE, TRUE, TRUE)] ## [1] &quot;A&quot; &quot;C&quot; &quot;D&quot; TRUEとFALSEが使えることは、論理演算子を[]の中で使うことが可能ということになります。たとえば、numeric_vec1の各要素が偶数か否かを判定するためには2で割って、余りが0か否かを見ればいいでしょう。 (numeric_vec1 %% 2) == 0 ## [1] FALSE FALSE FALSE TRUE FALSE TRUE TRUE これを利用し、numeric_vec1から偶数のみを抽出することも可能です。 numeric_vec1[(numeric_vec1 %% 2) == 0] ## [1] 6 2 8 これと代入を組み合わせると「ベクトルの一部の要素を書き換える」ことも可能です。ととえば、numeric_vec1の2番目の要素は5ですが、これを100に書き換えたい場合、置換したい要素の場所を[]内で指定し、&lt;-で代入するだけです。 numeric_vec1[2] &lt;- 100 numeric_vec1 ## [1] 1 100 3 6 99 2 8 他にも複数の要素を置換することも可能です。たとえば、偶数を全て0に置換したい場合、以下のように打ち込みます。 numeric_vec1[(numeric_vec1 %% 2) == 0] &lt;- 0 numeric_vec1 ## [1] 1 0 3 0 99 0 0 6.5 データの読み込み 6.5.1 csvファイルの場合 csvフォーマットはcomma separated valueの略でありますが、馴染みのExcelファイル (.xlsx)と似たような、表形式のファイルフォーマットです。ただし、Excelファイルとは違って、文字の大きさ、セルの背景色、セルの統合のような情報は持たず、純粋な数値・文字列のみ格納されているため、非常にサイズが小さいです。このcsvフォーマットはデータ分析における標準フォーマットであり、多くのデータがcsv形式で提供されています。 それでは、csv形式ファイルの読み込みからやってみましょう。データのダウンロード方法については本書の第1.5章を参照してください。csvファイルを読み込むにはread.csv()またはread_csv()関数を使います21。読み込む際は前節のベクトルの生成同様、何らかの名前を付けて、作業環境に保存します。DataフォルダーにあるFIFA_Women.csvファイルを読み込み、myDF1と名付ける場合、以下のようなコードを実行します22。もし、以下のコードでmyDF1 &lt;-を入力しない場合、データが出力されるのみであり、自分の作業スペースには保存されません。 myDF1 &lt;- read.csv(&quot;Data/FIFA_Women.csv&quot;) 読み込まれたデータを見るには、ベクトルと同様、print()関数を使うか、オブジェクト名を入力します。 myDF1 ## ID Team Rank Points Prev_Points Confederation ## 1 1 Albania 75 1325 1316 UEFA ## 2 2 Algeria 85 1271 1271 CAF ## 3 3 American Samoa 133 1030 1030 OFC ## 4 4 Andorra 155 749 749 UEFA ## 5 5 Angola 121 1117 1117 CAF ## 6 6 Antigua and Barbuda 153 787 787 CONCACAF ## 7 7 Argentina 32 1659 1659 CONMEBOL ## 8 8 Armenia 126 1103 1104 UEFA ## 9 9 Aruba 157 724 724 CONCACAF ## 10 10 Australia 7 1963 1963 AFC ## 11 11 Austria 22 1792 1797 UEFA ## 12 12 Azerbaijan 76 1321 1326 UEFA ## 13 13 Bahrain 84 1274 1274 AFC ## 14 14 Bangladesh 134 1008 1008 AFC ## 15 15 Barbados 135 1002 1002 CONCACAF ## 16 16 Belarus 53 1434 1437 UEFA ## 17 17 Belgium 17 1819 1824 UEFA ## 18 18 Belize 150 824 824 CONCACAF ## 19 19 Bermuda 136 987 987 CONCACAF ## 20 20 Bhutan 154 769 769 AFC ## 21 21 Bolivia 91 1236 1236 CONMEBOL ## 22 22 Bosnia and Herzegovina 59 1411 1397 UEFA ## 23 23 Botswana 148 848 848 CAF ## 24 24 Brazil 8 1958 1956 CONMEBOL ## 25 25 Bulgaria 79 1303 1303 UEFA ## 26 26 Cameroon 51 1455 1486 CAF ## 27 27 Canada 8 1958 1958 CONCACAF ## 28 28 Chile 37 1640 1637 CONMEBOL ## 29 29 China PR 15 1867 1842 AFC ## 30 30 Chinese Taipei 40 1589 1584 AFC ## 31 31 Colombia 25 1700 1700 CONMEBOL ## 32 32 Comoros 156 731 731 CAF ## 33 33 Congo 104 1178 1178 CAF ## 34 34 Congo DR 110 1159 1159 CAF ## 35 35 Cook Islands 103 1194 1194 OFC ## 36 36 Costa Rica 36 1644 1630 CONCACAF ## 37 37 Côte d&#39;Ivoire 63 1392 1392 CAF ## 38 38 Croatia 52 1453 1439 UEFA ## 39 39 Cuba 88 1240 1240 CONCACAF ## 40 40 Cyprus 123 1114 1123 UEFA ## 41 41 Czech Republic 29 1678 1678 UEFA ## 42 42 Denmark 16 1851 1839 UEFA ## 43 43 Dominican Republic 105 1173 1173 CONCACAF ## 44 44 El Salvador 109 1164 1164 CONCACAF ## 45 45 England 6 1999 2001 UEFA ## 46 46 Equatorial Guinea 71 1356 1356 CAF ## 47 47 Estonia 95 1210 1206 UEFA ## 48 48 Eswatini 151 822 822 CAF ## 49 49 Ethiopia 111 1151 1151 CAF ## 50 50 Faroe Islands 86 1259 1262 UEFA ## 51 51 Fiji 66 1373 1373 OFC ## 52 52 Finland 30 1671 1678 UEFA ## 53 53 France 3 2036 2033 UEFA ## 54 54 Gabon 130 1066 1066 CAF ## 55 55 Gambia 113 1143 1183 CAF ## 56 56 Georgia 115 1138 1145 UEFA ## 57 57 Germany 2 2090 2078 UEFA ## 58 58 Ghana 60 1401 1404 CAF ## 59 59 Greece 62 1396 1395 UEFA ## 60 60 Guam 82 1282 1282 AFC ## 61 61 Guatemala 80 1290 1290 CONCACAF ## 62 62 Haiti 64 1391 1368 CONCACAF ## 63 63 Honduras 116 1136 1136 CONCACAF ## 64 64 Hong Kong 74 1329 1335 AFC ## 65 65 Hungary 43 1537 1526 UEFA ## 66 66 Iceland 19 1817 1821 UEFA ## 67 67 India 55 1432 1432 AFC ## 68 68 Indonesia 94 1222 1222 AFC ## 69 69 IR Iran 70 1358 1358 AFC ## 70 70 Israel 67 1369 1371 UEFA ## 71 71 Italy 14 1889 1882 UEFA ## 72 72 Jamaica 50 1460 1461 CONCACAF ## 73 73 Japan 11 1937 1942 AFC ## 74 74 Jordan 58 1419 1419 AFC ## 75 75 Kazakhstan 77 1318 1318 UEFA ## 76 76 Kenya 137 986 986 CAF ## 77 77 Korea DPR 10 1940 1940 AFC ## 78 78 Korea Republic 18 1818 1812 AFC ## 79 79 Kosovo 125 1104 1109 UEFA ## 80 80 Kyrgyz Republic 120 1118 1118 AFC ## 81 81 Latvia 93 1223 1223 UEFA ## 82 82 Lebanon 141 967 967 AFC ## 83 83 Lesotho 147 850 850 CAF ## 84 84 Lithuania 107 1169 1168 UEFA ## 85 85 Luxembourg 119 1124 1124 UEFA ## 86 86 Madagascar 158 691 691 CAF ## 87 87 Malawi 145 887 887 CAF ## 88 88 Malaysia 90 1238 1238 AFC ## 89 89 Maldives 142 966 966 AFC ## 90 90 Mali 83 1276 1276 CAF ## 91 91 Malta 101 1197 1195 UEFA ## 92 92 Mauritius 159 357 357 CAF ## 93 93 Mexico 27 1686 1699 CONCACAF ## 94 94 Moldova 92 1228 1229 UEFA ## 95 95 Mongolia 123 1114 1114 AFC ## 96 96 Montenegro 97 1201 1206 UEFA ## 97 97 Morocco 81 1289 1280 CAF ## 98 98 Mozambique 152 814 814 CAF ## 99 99 Myanmar 45 1511 1527 AFC ## 100 100 Namibia 143 956 956 CAF ## 101 101 Nepal 99 1200 1200 AFC ## 102 102 Netherlands 4 2032 2035 UEFA ## 103 103 New Caledonia 96 1208 1208 OFC ## 104 104 New Zealand 23 1757 1760 OFC ## 105 105 Nicaragua 122 1116 1116 CONCACAF ## 106 106 Nigeria 38 1614 1614 CAF ## 107 107 North Macedonia 129 1072 1073 UEFA ## 108 108 Northern Ireland 55 1432 1433 UEFA ## 109 109 Norway 12 1930 1929 UEFA ## 110 110 Palestine 117 1131 1131 AFC ## 111 111 Panama 60 1401 1437 CONCACAF ## 112 112 Papua New Guinea 46 1504 1504 OFC ## 113 113 Paraguay 48 1490 1490 CONMEBOL ## 114 114 Peru 65 1376 1376 CONMEBOL ## 115 115 Philippines 67 1369 1369 AFC ## 116 116 Poland 28 1683 1677 UEFA ## 117 117 Portugal 32 1659 1667 UEFA ## 118 118 Puerto Rico 106 1172 1172 CONCACAF ## 119 119 Republic of Ireland 31 1666 1665 UEFA ## 120 120 Romania 44 1535 1542 UEFA ## 121 121 Russia 24 1708 1708 UEFA ## 122 122 Rwanda 144 899 899 CAF ## 123 123 Samoa 107 1169 1169 OFC ## 124 124 Scotland 21 1804 1794 UEFA ## 125 125 Senegal 87 1247 1245 CAF ## 126 126 Serbia 41 1558 1553 UEFA ## 127 127 Singapore 128 1089 1089 AFC ## 128 128 Slovakia 47 1501 1500 UEFA ## 129 129 Slovenia 49 1471 1467 UEFA ## 130 130 Solomon Islands 114 1140 1140 OFC ## 131 131 South Africa 53 1434 1434 CAF ## 132 132 Spain 13 1915 1900 UEFA ## 133 133 Sri Lanka 140 968 968 AFC ## 134 134 St. Kitts and Nevis 131 1050 1054 CONCACAF ## 135 135 St. Lucia 138 982 982 CONCACAF ## 136 136 Suriname 127 1093 1093 CONCACAF ## 137 137 Sweden 5 2007 2022 UEFA ## 138 138 Switzerland 20 1815 1817 UEFA ## 139 139 Tahiti 102 1196 1196 OFC ## 140 140 Tajikistan 132 1035 1035 AFC ## 141 141 Tanzania 139 978 978 CAF ## 142 142 Thailand 39 1596 1620 AFC ## 143 143 Tonga 88 1240 1240 OFC ## 144 144 Trinidad and Tobago 72 1354 1354 CONCACAF ## 145 145 Tunisia 78 1304 1313 CAF ## 146 146 Turkey 69 1365 1361 UEFA ## 147 147 Uganda 146 868 868 CAF ## 148 148 Ukraine 26 1692 1697 UEFA ## 149 149 United Arab Emirates 97 1201 1201 AFC ## 150 150 Uruguay 73 1346 1346 CONMEBOL ## 151 151 US Virgin Islands 149 843 843 CONCACAF ## 152 152 USA 1 2181 2174 CONCACAF ## 153 153 Uzbekistan 42 1543 1543 AFC ## 154 154 Vanuatu 117 1131 1131 OFC ## 155 155 Venezuela 57 1425 1425 CONMEBOL ## 156 156 Vietnam 35 1657 1665 AFC ## 157 157 Wales 34 1658 1659 UEFA ## 158 158 Zambia 100 1198 1167 CAF ## 159 159 Zimbabwe 111 1151 1151 CAF データが読み込まれているか否かを確認するためには全データを見る必要はないでしょおう。最初の数行のみで問題ないはずです。この場合、head()関数が便利です。これは最初の6行まで表示させてくれる関数です。 head(myDF1) ## ID Team Rank Points Prev_Points Confederation ## 1 1 Albania 75 1325 1316 UEFA ## 2 2 Algeria 85 1271 1271 CAF ## 3 3 American Samoa 133 1030 1030 OFC ## 4 4 Andorra 155 749 749 UEFA ## 5 5 Angola 121 1117 1117 CAF ## 6 6 Antigua and Barbuda 153 787 787 CONCACAF 6.5.1.1 エンコーディングの話 Vote_ShiftJIS.csvはShift-JISでエンコーディングされたcsvファイルです。このファイルをread.csv()関数で読み込んでみましょう。 ShiftJIS.df &lt;- read.csv(&quot;Data/Vote_ShiftJIS.csv&quot;) ## Error in type.convert.default(data[[i]], as.is = as.is[i], dec = dec, : &#39;&lt;96&gt;k&lt;8a&gt;C&lt;93&gt;&lt;b9&gt;&#39; に不正なマルチバイト文字があります このようにエラーが表示され読み込めません。この場合、readrパッケージのread_csv()を使えば読み込むことはできます。それではread_csv()で読み込み、中身を確認してみましょう。 ShiftJIS.df1 &lt;- read_csv(&quot;Data/Vote_ShiftJIS.csv&quot;) ## Parsed with column specification: ## cols( ## ID = col_double(), ## Pref = col_character(), ## Zaisei = col_double(), ## Over65 = col_double(), ## Under30 = col_double(), ## LDP = col_double(), ## DPJ = col_double(), ## Komei = col_double(), ## Ishin = col_double(), ## JCP = col_double(), ## SDP = col_double() ## ) head(ShiftJIS.df1) ## # A tibble: 6 x 11 ## ID Pref Zaisei Over65 Under30 LDP DPJ Komei Ishin JCP SDP ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 &quot;\\x96k\\x8aC\\x93\\xb9&quot; 0.419 29.1 24.7 32.8 30.6 13.4 3.43 11.4 1.68 ## 2 2 &quot;\\x90\\xc2\\x90X\\x8c\\xa7&quot; 0.332 30.1 23.9 40.4 24.6 12.8 3.82 8.92 3.41 ## 3 3 &quot;\\x8a\\xe2\\x8e\\xe8\\x8c\\… 0.341 30.4 24.5 34.9 22.4 8.61 5.16 11.2 5.29 ## 4 4 &quot;\\x8b{\\x8f\\xe9\\x8c\\xa7&quot; 0.596 25.8 27.3 36.7 25.4 13.4 3.97 9.99 3.62 ## 5 5 &quot;\\x8fH\\x93c\\x8c\\xa7&quot; 0.299 33.8 21.4 43.5 22.7 11.2 5.17 7.56 5.12 ## 6 6 &quot;\\x8eR\\x8c`\\x8c\\xa7&quot; 0.342 30.8 24.8 42.5 21.5 11.8 4.3 7.6 5.2 2列目のPref列は日本語で都道府県名が入っている列ですが、謎の文字になっています。 解決方法はいくつかありますが、ここでは3つの方法を消化します。 1. read.csv()関数のfileEncoing引数の指定 一つ目の方法はread.csv()関数を使った方法ですが、fileEncoding =引数を追加するだけです。この引数は指定したファイルのエンコーディングを指定しますが、Shift-JISの場合、\"Shift_JIS\"です。ハイフン (-)ではなく、アンダーバー (_)であることに注意して下さい。この\"Shift_JIS\"は\"cp932\"に書き換えても問題ありません。それではやってみましょう。 ShiftJIS.df2 &lt;- read.csv(&quot;Data/Vote_ShiftJIS.csv&quot;, fileEncoding = &quot;Shift_JIS&quot;) head(ShiftJIS.df2) ## ID Pref Zaisei Over65 Under30 LDP DPJ Komei Ishin JCP SDP ## 1 1 北海道 0.41903 29.09 24.70 32.82 30.62 13.41 3.43 11.44 1.68 ## 2 2 青森県 0.33190 30.14 23.92 40.44 24.61 12.76 3.82 8.92 3.41 ## 3 3 岩手県 0.34116 30.38 24.48 34.90 22.44 8.61 5.16 11.24 5.29 ## 4 4 宮城県 0.59597 25.75 27.29 36.68 25.40 13.42 3.97 9.99 3.62 ## 5 5 秋田県 0.29862 33.84 21.35 43.46 22.72 11.19 5.17 7.56 5.12 ## 6 6 山形県 0.34237 30.76 24.75 42.49 21.47 11.78 4.30 7.60 5.20 Pref列の日本語が正常に表示されましたね。 2. read_csv()関数のlocale引数の指定 二つ目の方法はread_csv()関数のlocale =引数を指定する方法です。read_csv()にはfileEncoding =引数がありませんが、似たような引数としてlocale =があります。方法としては既存のやり方にlocale = locale(encoding = \"Shift_JIS\")を追加するだけです。 ShiftJIS.df3 &lt;- read_csv(&quot;Data/Vote_ShiftJIS.csv&quot;, locale = locale(encoding = &quot;Shift_JIS&quot;)) ## Parsed with column specification: ## cols( ## ID = col_double(), ## Pref = col_character(), ## Zaisei = col_double(), ## Over65 = col_double(), ## Under30 = col_double(), ## LDP = col_double(), ## DPJ = col_double(), ## Komei = col_double(), ## Ishin = col_double(), ## JCP = col_double(), ## SDP = col_double() ## ) head(ShiftJIS.df3) ## # A tibble: 6 x 11 ## ID Pref Zaisei Over65 Under30 LDP DPJ Komei Ishin JCP SDP ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 北海道 0.419 29.1 24.7 32.8 30.6 13.4 3.43 11.4 1.68 ## 2 2 青森県 0.332 30.1 23.9 40.4 24.6 12.8 3.82 8.92 3.41 ## 3 3 岩手県 0.341 30.4 24.5 34.9 22.4 8.61 5.16 11.2 5.29 ## 4 4 宮城県 0.596 25.8 27.3 36.7 25.4 13.4 3.97 9.99 3.62 ## 5 5 秋田県 0.299 33.8 21.4 43.5 22.7 11.2 5.17 7.56 5.12 ## 6 6 山形県 0.342 30.8 24.8 42.5 21.5 11.8 4.3 7.6 5.2 3. LibreOfficeなどを利用した方法 6.5.2 その他のフォーマット データ分析で用いられるデータの多くは表の形をしていますが、.csv以外にも、.xlsx (Excel)、.dta (Stata)、.sav (SPSS)、.ods (LibreOfficeなど)などがあります。ここでは接する機会が多いExcel形式のファイルとStata形式のファイルの読み込みについて説明します23。 Excelファイルを読み込むためにはxlsxパッケージを使います。インストールされていない場合、コンソール上でinstall.packages(\"xlsx\")を入力し、インストールしておきましょう。以下ではxlsxパッケージがインストールされていると想定し、Soccer.xlsxファイルを読み込み、Excel.DFと名付けてみましょう。 #install.packages(&quot;xlsx&quot;) インストールされていない場合 library(xlsx) Excel.DF &lt;- read.xlsx(&quot;Data/Soccer.xlsx&quot;, sheetIndex = 1) read.xlsx()関数にはsheetIndex =という引数を指定する必要があります。Excelは2つ以上のシートを含む場合が多いので、どのシートを読み込むかを指定しなくてはなりません。実際、Soccer.xlsxファイルをExcelで開いてみると、シートが3つあり、データは1つ目のシートにあるので、ここでは1と指定します。それでは、ちゃんと読み込まれているかも確認してみましょう。 head(Excel.DF) ## ID Team Rank Points Prev_Points Confederation ## 1 1 Albania 75 1325 1316 UEFA ## 2 2 Algeria 85 1271 1271 CAF ## 3 3 American Samoa 133 1030 1030 OFC ## 4 4 Andorra 155 749 749 UEFA ## 5 5 Angola 121 1117 1117 CAF ## 6 6 Antigua and Barbuda 153 787 787 CONCACAF Stataの.dtaファイルはhavenパッケージのread_dta()関数を使います。Stata形式で保存されている同じデータSoccer.dtaを読み込み、Stata.DFと名付けてみましょう。 library(haven) Stata.DF &lt;- read_dta(&quot;Data/Soccer.dta&quot;) head(Stata.DF) ## # A tibble: 6 x 6 ## id team rank points prev_points confederation ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 Albania 75 1325 1316 UEFA ## 2 2 Algeria 85 1271 1271 CAF ## 3 3 American Samoa 133 1030 1030 OFC ## 4 4 Andorra 155 749 749 UEFA ## 5 5 Angola 121 1117 1117 CAF ## 6 6 Antigua and Barbuda 153 787 787 CONCACAF 実際の社会科学の場合、入手するデータの多くは.csv、.xlsx (または.xls)、.dtaであるため、以上のやり方でもほとんどのデータは読み込めるかと思います。 6.5.3 RDataファイルの場合 データ分析には表形式以外のデータも使います。ベクトルや行列だけでなく、list型というデータ形式もあります。Rで扱える様々なデータが含ま荒れているファイルフォーマットの一つが.RDataフォーマットです。これにはRが扱える形式のデータが格納されているだけでなあく、表形式のデータが複数格納されている場合があります。また、データだけでなく、分析結果も保存することができます。.RDataフォーマットはRでしか読み込めないため、メジャーなフォーマットとは言い難いですが、一つのファイルに様々なデータが格納できる長所があります。 ここではDataフォルダーにあるScores.RDataを読み込んでみましょう。このファイルには学生5人の数学成績と英語成績に関するデータがそれぞれMathScoreとEnglishScoreという名で保存されています。読み込む前に自分の作業スペースにどのようなオブジェクトがあるかをls()関数を使って確認してみます24。 ls() ## [1] &quot;character_vec&quot; &quot;Excel.DF&quot; &quot;myDF1&quot; &quot;numeric_vec1&quot; &quot;numeric_vec2&quot; ## [6] &quot;numeric_vec3&quot; &quot;ShiftJIS.df1&quot; &quot;ShiftJIS.df2&quot; &quot;ShiftJIS.df3&quot; &quot;Stata.DF&quot; ## [11] &quot;x&quot; &quot;y&quot; 現在の作業スペースには12個のオブジェクトがあります。それではScores.RDataを読み込んでみましょう。使用する関数はload()関数であり、引数はファイル名です。 load(&quot;Data/Scores.RData&quot;) それではもう一度作業スペース上のオブジェクトのリストを確認してみます。 ls() ## [1] &quot;character_vec&quot; &quot;EnglishScore&quot; &quot;Excel.DF&quot; &quot;MathScore&quot; &quot;myDF1&quot; ## [6] &quot;numeric_vec1&quot; &quot;numeric_vec2&quot; &quot;numeric_vec3&quot; &quot;ShiftJIS.df1&quot; &quot;ShiftJIS.df2&quot; ## [11] &quot;ShiftJIS.df3&quot; &quot;Stata.DF&quot; &quot;x&quot; &quot;y&quot; MathScoreとEnglishScoreという名のオブジェクトが追加されていることが分かります。.csvや.xlsx形式ファイルの読み込みと異なる点は大きく以下の2点です。 一つのファイルに複数のデータが含まれている。 読み込みと同時に名前を付けて格納する必要がなく、オブジェクトとして読み込まれる。 問題なく読み込まれているかそれぞれのオブジェクトの中身を確認してみましょう。 MathScore # MathScoreの中身を出力 ## ID Name Score ## 1 1 Yanai 100 ## 2 2 Song 37 ## 3 3 Tanaka 55 ## 4 4 Sato 69 ## 5 5 Downs 95 EnglishScore # EnglishScoreの中身を出力 ## ID Name Score ## 1 1 Yanai 90 ## 2 2 Song 21 ## 3 3 Tanaka 80 ## 4 4 Sato 45 ## 5 5 Downs 99 誰だかよく分かりませんが、Songという学生がポンコツということがよく分かりますね。 6.6 データの書き出し 我々が普段手にするデータ（生データ）はかなり汚く、分析をするためにはデータを分析に適した形へ整形する必要があります。これらの作業を「データクリーニング」と呼びますが、実は分析において約5~7割はデータクリーニングに時間を費やすことになります。 一旦、データクリーニングが終わったら、クリーニング済みのデータを保存しておきましょう。クリーニングのコードさえあれば、いつでも生データからクリーニング済みのデータに変換することができますが、時間的にあまり効率的ではありません。クリーニング済みのデータを保存しておけば、いつでも読み込んですぐに分析作業に取り組めるので非常に便利です25。 6.6.1 csvファイル データの保存は基本的に.csvフォーマットにします。むろん、データが表の形をしていない場合は次節で紹介する.RDataフォーマットにしますが、多くの場合、データは表の形をしています。.csvファイルはほとんどの統計ソフトおよび表計算ソフトからも読み込めるため、業界標準のフォーマットとも言えます26。 まずは、架空のデータを作ってみます。Rにおける表形式のデータはdata.frame型ですが、詳細については第8章で説明します。 myData &lt;- data.frame( ID = 1:5, Name = c(&quot;Aさん&quot;, &quot;Bさん&quot;, &quot;Cさん&quot;, &quot;Dさん&quot;, &quot;Eさん&quot;), Score = c(50, 75, 60, 93, 51) ) 以上のコードを実行すると、myDataというオブジェクトが生成され、中には表6.1のようなデータが含まれます。 ## ## Attaching package: &#39;magrittr&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## set_names ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract ## Warning in kableExtra::kable_styling(., bootstrap_options = c(&quot;striped&quot;, : Please specify ## format in kable. kableExtra can customize either HTML or LaTeX outputs. See https:// ## haozhu233.github.io/kableExtra/ for details. 表 6.1: myDataの中身 ID Name Score 1 Aさん 50 2 Bさん 75 3 Cさん 60 4 Dさん 93 5 Eさん 51 このデータをmyData.csvという名前のcsvファイルで保存するためにはwrite.csv()関数を使います。必須引数は2つで、1つ目の引数は保存するオブジェクト名、2つ目の引数は書き出すファイル名です。もし、プロジェクトフォルダーの下位フォルダー、たとえば、Dataフォルダーに保存するなら、ファイル名を\"Data/myData.csv\"のように指定します。他にもよく使う引数にはrow.names =があり、デフォルトはTRUEですが、FALSEにしておくのをオススメします。TRUEの場合、データ1列目に勝手に行番号が付けられます。 write.csv(myData, &quot;myData.csv&quot;, row.names = FALSE) プロジェクトのフォルダーにmyData.csvが生成されます。LibreOfficeやNumbers、Excelなどを使ってmyData.csvを開いてみると、先ほど作成したデータが保存されていることが分かります。 図 6.8: myData.csvの中身 6.6.2 RDataファイル 最後に.RData形式でデータを書き出してみましょう。今回は先ほど作成したmyDataとnumeric_vec1、numeric_vec2、character_vecをmyRData.RDataという名のファイルとしてDataフォルダーに書き出します。使用する関数はsave()関数です。中にはまず、保存するオブジェクト名を全て書き、最後にfile =引数でファイル名を指定するだけです。 save(myData, numeric_vec1, numeric_vec2, character_vec, file = &quot;Data/myRData.RData&quot;) 実際にmyRData.Rdataファイルが生成されているかを確認してみましょう。これからはmyRData.Rdataを読み込むだけで、myData、numeric_vec1、numeric_vec2、character_vecオブジェクトを同時に作業スペースに読み込むのができます。実際にそうなのか確認してみましょう。その前に既存の作業スペース上にあるmyData、numeric_vec1、numeric_vec2、character_vecを作業スペースから削除します。そのためにはrm()関数を使います。 rm(myData) rm(numeric_vec1) rm(numeric_vec2) rm(character_vec) 以上のコードは以下のようなコードでも同じ動きをします。 rm(list = c(&quot;myData&quot;, &quot;numeric_vec1&quot;, &quot;numeric_vec2&quot;, &quot;character_vec&quot;)) ちゃんと4つのオブジェクトが削除されたか、ls()関数で確認してみます。 ls() ## [1] &quot;EnglishScore&quot; &quot;Excel.DF&quot; &quot;MathScore&quot; &quot;myDF1&quot; &quot;numeric_vec3&quot; ## [6] &quot;ShiftJIS.df1&quot; &quot;ShiftJIS.df2&quot; &quot;ShiftJIS.df3&quot; &quot;Stata.DF&quot; &quot;x&quot; ## [11] &quot;y&quot; それではDataフォルダー内のmyRData.RDataを読み込み、4つのオブジェクトが作業スペースに格納されているかを確認します。 load(&quot;Data/myRData.RData&quot;) # Dataフォルダー内のmyRData.RDataを読み込む ls() # 作業スペース上のオブジェクトのリストを確認する ## [1] &quot;character_vec&quot; &quot;EnglishScore&quot; &quot;Excel.DF&quot; &quot;MathScore&quot; &quot;myData&quot; ## [6] &quot;myDF1&quot; &quot;numeric_vec1&quot; &quot;numeric_vec2&quot; &quot;numeric_vec3&quot; &quot;ShiftJIS.df1&quot; ## [11] &quot;ShiftJIS.df2&quot; &quot;ShiftJIS.df3&quot; &quot;Stata.DF&quot; &quot;x&quot; &quot;y&quot; 6.7 演習問題 問1 myVec1という名のオブジェクトに(3, 9, 10, 8, 3, 5, 8)を格納し、表示せよ。 問2 myVec1から2, 4, 6番目の要素を抽出せよ。 問3 myVec1の要素の和を求めよ。 ベクトル内要素の和はsum(ベクトル名)で計算できる。たとえば、ベクトルc(1, 3, 5)の和はsum(c(1, 3, 5))である。 問4 myVec1の要素から奇数のみを抽出し、その和を求めよ。 問5 myVec2という名のオブジェクトに長さ7のベクトル、(1, 2, 3, 4, 3, 2, 1)を格納し、表示せよ。 問6 myVec1とmyVec2のそれぞれの要素の和を計算し、myVec3に格納し、表示せよ。 問7 myVec3の要素から10未満の要素を抽出せよ。 問7 1から100までの公差1の数列 (1, 2, 3, 4, 5, …, 100)を作成し、myVec4と名付けよ。 問9 myVec4の各要素を二乗した総和 (\\(1^2 + 2^2 + 3^2 + \\dots + 100^2\\))を求めよ。 問10 myVec4から奇数のみ抽出し、二乗和 (\\(1^2 + 3^2 + 5^2 + 7^2 + \\dots + 97^2 + 99^2\\))を求めよ。 macOSの場合、/Users/ユーザー名/は~/で省略できます。↩︎ 簡単に電卓として使うくらいならConsole上で入力しても構いません。↩︎ 反復作業が面倒な方はプログラミングが上達しやすいです。↩︎ または「付値」ともします。↩︎ なぜなら、seq()の使い方には「xからyまで全体の長さがzになるように等間隔の数値列を作る」ということもあるからです。もし、「1から100まで長さ15のベクトルを作成し、すべて等間隔にする」場合はseq(1, 100, length.out = 15)のように書きます。↩︎ read.csv()で読み込まれた表はdata.frameクラスに、read_csv()関数で読み込まれた表はtibbleクラスとして読み込まれます。詳細は第8章で解説します。↩︎ R 4.0.0未満を使っている場合、引数としてstringsAsFactors = FALSEを追加します。たとえば、myDF1 &lt;- read.csv(\"Data/FIFA_Women.csv\", stringsAsFactors = FALSE)です。これを追加しない場合、文字列で構成されている列がfactor型として読み込まれます。↩︎ .savファイルはhavenパッケージのread_sav()で、.odsはreadODSパッケージのread.ods()関数で読み込めます。↩︎ ちなみにRStudioからも確認可能です。第3.3章のとおりにRStudioを設定した場合、右下ペインの「Environment」タブで確認できます。↩︎ 言うまでもないですが、データクリーニングのコードと生データも必ず残しておきましょう。↩︎ Excel (.xlsx)も広く使われておりますが、世の中にはExcelを持っていない人も多いです。↩︎ "],
["datatype.html", "7. データの型 7.1 データ型とは 7.2 Logical 7.3 Numeric 7.4 Complex 7.5 Character 7.6 Factor 7.7 Date 7.8 NA 7.9 NULL 7.10 NaN 7.11 Inf", " 7. データの型 目次 第7.1章: データ型とは 第7.2章: Logical型 第7.3章: Numeric型 第7.4章: Complex型 第7.5章: Character型 第7.6章: Factor型 第7.7章: Date型 第7.8章: NA型 第7.9章: NULL型 第7.10章: NaN型 第7.11章: Inf型 7.1 データ型とは ここではRにおけるデータ型について説明します。第8章で説明するデータ「構造」とデータ「型」は異なる概念です。次章でも説明しますが、Rにおけるデータの最小単位はベクトルです。c(1, 2, 3, 4, 5)やc(\"Yanai\", \"Song\", \"Hadley\")もベクトルですが、30とか\"R\"もベクトルです。後者のように要素が1つのベクトルは原子ベクトル (atomic vector)とも呼ばれますが、本質的には普通ベクトルです。このベクトルの要素の性質がデータ型です。たとえばc(2, 3, 5, 7, 11)は数値型ですし、c(\"R\", \"Python\", \"Julia\")は文字型です。他にも第6章で紹介したFALSEやTRUEは論理型と呼ばれています。一つのベクトルは複数の要素で構成されることも可能ですが、必ず同じデータ型である必要があります。 しかし、データ分析を行う際はベクトル以外のデータも多いです。行列や表がその典型例です。しかし、行列でも表でも中身の一つ一つの要素は長さ1のベクトルに過ぎません。たとえば、以下のような2行5列のベクトルがあるとします。ここで1行3列目の要素は11であり、長さ1の数値型ベクトルです。あるいは5列目はc(23, 29)であり、長さ2の数値型ベクトルです。 ## [,1] [,2] [,3] [,4] [,5] ## [1,] 2 5 11 17 23 ## [2,] 3 7 13 19 29 表についても考えてみましょう。以下の表の3行2列目の要素は\"American Samoa\"という長さ1の文字型ベクトルです。また、6列目はc(\"UEFA\", \"CAF\", \"OFC\", \"UEFA\", \"CAF\", \"CONCACAF\")であり、これは長さ6の文字型ベクトルです。このようにRで扱う全てのデータは複数のベクトルが集まっているものです。 ## ID Team Rank Points Prev_Points Confederation ## 1 1 Albania 75 1325 1316 UEFA ## 2 2 Algeria 85 1271 1271 CAF ## 3 3 American Samoa 133 1030 1030 OFC ## 4 4 Andorra 155 749 749 UEFA ## 5 5 Angola 121 1117 1117 CAF ## 6 6 Antigua and Barbuda 153 787 787 CONCACAF つまり、複数のベクトルを綺麗に、または分析しやすく集めたのが行列や表であり、これがデータ構造に該当します。データ型ごとの処理方法については本書を通じて紹介して行きますので、本章は軽く読んで頂いても構いません。ただし、Factor型とDate &amp; Datetime型の処理はやや特殊ですので、手を動かしながら読み進めることをおすすめします。 ここではデータ型について紹介し、次章ではデータ構造について解説します。 7.2 Logical Logical型はTRUEとFALSEのみで構成されたデータ型です。練習としてなにかの長さ5の論理型ベクトルを作ってみましょう。 Logical.Vec1 &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE) Logical.Vec1 ## [1] TRUE FALSE TRUE TRUE FALSE 注意すべきこととしては、TRUEとFALSEは\"で囲まないことです。\"TRUE\"、\"FALSE\"と入力してしまえばlogical 型として認識されません。もし、一つ間違えて2番目の要素であるFALSEを\"FALSE\"と入力したらどうなるでしょうか。 Logical.Vec2 &lt;- c(TRUE, &quot;FALSE&quot;, TRUE, TRUE, FALSE) Logical.Vec2 ## [1] &quot;TRUE&quot; &quot;FALSE&quot; &quot;TRUE&quot; &quot;TRUE&quot; &quot;FALSE&quot; 2番目の要素だけでなく、他の全ての要素も\"で囲まれるようになりました。実際に、この2つのベクトルのデータ型を確認してみましょう。ベクトルのデータ型を確認する関数はclass()関数です。 class(Logical.Vec1) ## [1] &quot;logical&quot; class(Logical.Vec2) ## [1] &quot;character&quot; Logical.Vec1はlogical型ですが、Logical.Vec2はcharacter型と認識されます。 他にも、is.logical()関数を使ってあるベクトルがlogical型か否かを判定することも可能です。もし、ベクトルがlogical型ならTRUEが、logical型以外ならFALSEが返って来ます。 is.logical(Logical.Vec1) ## [1] TRUE is.logical(Logical.Vec2) ## [1] FALSE Logical型は様々な場面で使われますが、代表的な使い方は第6.2章で紹介しました要素の抽出と第9章で紹介する予定の条件分岐 (if()やifelse())、条件反復 (while())があります。 7.3 Numeric Numeric型は数値型ですが、まずはnumeric型のベクトルNumeric.Vec1を作成し、データ型を確認してみましょう。 Numeric.Vec1 &lt;- c(2, 0, 0, 1, 3) class(Numeric.Vec1) ## [1] &quot;numeric&quot; is.logical()に似た関数is.numeric()も使用可能です。 is.numeric(Numeric.Vec1) ## [1] TRUE is.numeric(Logical.Vec1) ## [1] FALSE もうちょっと詳しく分けるとinteger型とdouble型があります。以下の内容はあまり意識的に区分して使う場面が稀ですので、(読み)飛ばしても構いません。 integerは整数型であり、doubleは実数型です。これはclass()関数では確認できず、typeof()関すを使います。 typeof(Numeric.Vec1) ## [1] &quot;double&quot; 一般的に作成するnumeric型のベクトルは全てdouble型です。もし、整数型のベクトルを作成したい場合、数値の後ろにLを付けます。 Integer.Vec1 &lt;- c(2L, 0L, 0L, 1L, 3L) typeof(Integer.Vec1) ## [1] &quot;integer&quot; ここでも注意すべき点としては、一つでもLが付かない要素が含まれる場合、自動的にdouble型に変換されるという点です。 Integer.Vec2 &lt;- c(2L, 0L, 0, 1L, 3L) typeof(Integer.Vec2) ## [1] &quot;double&quot; もちろんですが、小数点のある数値にLを付けてもinteger型にはならず、勝手にdouble型になります。また、integer型同士の割り算の結果もdouble型になります。これは2L/1Lのような場合でも同じです。足し算、引き算、掛け算はinteger型になります。 typeof(2.3L) ## [1] &quot;double&quot; typeof(3L / 12L) ## [1] &quot;double&quot; typeof(3L / 1L) ## [1] &quot;double&quot; typeof(3L + 1L) ## [1] &quot;integer&quot; typeof(3L - 4L) ## [1] &quot;integer&quot; typeof(3L * 6L) ## [1] &quot;integer&quot; 一般的な分析において整数と実数を厳格に区別して使う場面は多くないと考えられますので、今のところはあまり気にしなくても問題ないでしょう。 7.4 Complex Complex型は複素数を表すデータ型であり、実数部+虚数部iのように表記します。まず、複素数のベクトルComplex.Vec1を作成し、データ型を確認してみましょう。 Complex.Vec1 &lt;- c(1+3i, 3+2i, 2.5+7i) Complex.Vec1 ## [1] 1.0+3i 3.0+2i 2.5+7i class(Complex.Vec1) ## [1] &quot;complex&quot; あまりおすすめはできませんが、虚数部i+実数部のような書き方も可能です。 Complex.Vec2 &lt;- c(3i+1, 2i+3, 7i+2.5) Complex.Vec2 ## [1] 1.0+3i 3.0+2i 2.5+7i class(Complex.Vec2) ## [1] &quot;complex&quot; Complex.Vec1とComplex.Vec2は同じベクトルであることを確認してみましょう。 Complex.Vec1 == Complex.Vec2 ## [1] TRUE TRUE TRUE もし、ベクトル内にnumeric型とcomplex型が混在している場合、強制的にcomplex型に変換されます。変換された後の値は実数部+0iのようになります。 Complex.Vec3 &lt;- c(2+7i, 5, 13+1i) Complex.Vec3 ## [1] 2+7i 5+0i 13+1i class(Complex.Vec3) ## [1] &quot;complex&quot; 7.5 Character Character型は文字列で構成されているデータ型です。Rを含む多くの言語は文字列を表現するために、中身を\"で囲みます。\"abc\"はcharacter型ですが、\"1\"や\"3+5i\"もcharacter型です。数字であっても\"で囲んだらそれは文字列となります。それではいくつかのcharacter型ベクトルを作っていみましょう。 Char.Vec1 &lt;- c(&quot;Yanai&quot;, &quot;Song&quot;, &quot;Shigemura&quot;, &quot;Tani&quot;) Char.Vec2 &lt;- c(1, 2, 3, 4) Char.Vec3 &lt;- c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;) Char.Vec1 ## [1] &quot;Yanai&quot; &quot;Song&quot; &quot;Shigemura&quot; &quot;Tani&quot; Char.Vec2 ## [1] 1 2 3 4 Char.Vec3 ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; Char.Vec2とChar.Vec3の違いは通じを\"で囲んだか否かです。ベクトルの中身を見ても、Char.Vec2は\"で囲まれていません。データ型を見てみましょう。 class(Char.Vec1) ## [1] &quot;character&quot; class(Char.Vec2) ## [1] &quot;numeric&quot; class(Char.Vec3) ## [1] &quot;character&quot; やはりChar.Vec3もcharacter型になっていることが分かります。 7.6 Factor Factor型はラベル付きの数値型データです。Factor型の見た目はcharacter型とほぼ同じですし、分析の場面においてもcharacter型とほぼ同じ扱いになります。Factor型とcharacter型との違いは、「順序が付いている」点です。例えば、以下の質問文に対するアンケートの結果を考えてみましょう。 あなたは猫がすきですか。 めちゃめちゃ好き めちゃ好き 好き どちらかといえば好き 以下の表7.1は5人の結果です。 表 7.1: 猫好きの度合い ID Name Cat 1 Yanai めちゃめちゃ好き 2 Song めちゃめちゃ好き 3 Shigemura どちらかといえば好き 4 Tani めちゃ好き 5 Hadley 好き 人間としてはこの表から、重村という人がどれだけ猫が嫌いなのかが分かります。ただし、Rはそうではありません。Rは日本語どころか、人間の言葉は理解できません。各項目ごとに順番を付けてあげる必要がありますが、そのために使われるのがfactor型です。 実習のために表7.1のCat列のみのベクトルを作ってみましょう。 Factor.Vec1 &lt;- c(&quot;めちゃめちゃ好き&quot;, &quot;めちゃめちゃ好き&quot;, &quot;どちらかといえば好き&quot;, &quot;めちゃ好き&quot;, &quot;好き&quot;) Factor.Vec1 ## [1] &quot;めちゃめちゃ好き&quot; &quot;めちゃめちゃ好き&quot; &quot;どちらかといえば好き&quot; ## [4] &quot;めちゃ好き&quot; &quot;好き&quot; class(Factor.Vec1) ## [1] &quot;character&quot; Factor.Vec1は普通の文字列ベクトルであることが分かります。これをfactor型に変換するためにはfactor()関数を使います。 Factor.Vec2 &lt;- factor(Factor.Vec1, ordered = TRUE, levels = c(&quot;どちらかといえば好き&quot;, &quot;好き&quot;, &quot;めちゃ好き&quot;, &quot;めちゃめちゃ好き&quot;)) class(Factor.Vec2) ## [1] &quot;ordered&quot; &quot;factor&quot; データ型がfactor型に変換されています。\"ordered\"というものも付いていますが、これについては後ほど説明します。それでは中身をみましょう。 Factor.Vec2 ## [1] めちゃめちゃ好き めちゃめちゃ好き どちらかといえば好き めちゃ好き ## [5] 好き ## Levels: どちらかといえば好き &lt; 好き &lt; めちゃ好き &lt; めちゃめちゃ好き いくつかの点で異なります。まず、文字列であるにもかかわらず、\"で囲まれていいない点です。そして3行目に4 Levels:というのが追加されている点です。このlevelは「水準」と呼ばれるものです。4 Levelsですから、Factor.Vec2は4つの水準で構成されていることを意味します。Factor型の値は予め指定された水準以外の値を取ることはできません。たとえば、2番目の要素を「超好き」に変えてみましょう。 Factor.Vec2[2] &lt;- &quot;超好き&quot; ## Warning in `[&lt;-.factor`(`*tmp*`, 2, value = &quot;超好き&quot;): invalid factor level, NA generated Factor.Vec2 ## [1] めちゃめちゃ好き &lt;NA&gt; どちらかといえば好き めちゃ好き ## [5] 好き ## Levels: どちらかといえば好き &lt; 好き &lt; めちゃ好き &lt; めちゃめちゃ好き 警告が表示され、2番目の要素が後ほど紹介する欠損値となっていることが分かります。それでは普通に「好き」を入れてみましょう。 Factor.Vec2[2] &lt;- &quot;好き&quot; Factor.Vec2 ## [1] めちゃめちゃ好き 好き どちらかといえば好き めちゃ好き ## [5] 好き ## Levels: どちらかといえば好き &lt; 好き &lt; めちゃ好き &lt; めちゃめちゃ好き 今回は問題なく置換できましたね。このようにfactor型の取りうる値は既に指定されています。また、## 4 Levels: どちらかといえば好き &lt; 好き &lt; ... &lt; めちゃめちゃ好きからも分かるように、その大小関係の情報も含まれています。猫好きの度合いは「どちらかといえば好き-好き-めちゃ好き-めちゃめちゃ好き」の順で高くなることをRも認識できるようになりました。 Factor型はこのように順序付きデータを扱う際に便利なデータ型ですが、順序情報を含まないfactor型もあります。これはfactor()を使う際、ordered = TRUE引数を削除するだけでできます。 Factor.Vec3 &lt;- factor(Factor.Vec1, levels = c(&quot;どちらかといえば好き&quot;, &quot;好き&quot;, &quot;めちゃ好き&quot;, &quot;めちゃめちゃ好き&quot;)) Factor.Vec3 ## [1] めちゃめちゃ好き めちゃめちゃ好き どちらかといえば好き めちゃ好き ## [5] 好き ## Levels: どちらかといえば好き 好き めちゃ好き めちゃめちゃ好き class(Factor.Vec3) ## [1] &quot;factor&quot; 今回は3行目が## Levels: どちらかといえば好き 好き めちゃ好き めちゃめちゃ好きとなり、順序に関する情報がなくなりました。また、class()で確認しましたデータ型に\"ordered\"が付いていません。これは順序なしfactor型であることを意味します。「順序付けしないならfactor型は要らないのでは…?」と思うかも知れませんが、これはこれで便利です。その例を考えてみましょう。 分析においてfactor型はcharacter型に近い役割を果たしますが、factor型なりの長所もあります。それは図や表を作成する際です。例えば、横軸が都道府県名で、縦軸がその都道府県の財政力指数を表す棒グラフを作成するとします。元になるデータは表7.2のZaisei.dfです。 表 7.2: 5都道府県のH29財政力指数 ID Pref Zaisei 1 Hokkaido 0.44396 2 Tokyo 1.19157 3 Aichi 0.92840 4 Osaka 0.78683 5 Fukuoka 0.64322 可視化については第14で詳しく解説しますが、このPref列をcharacter型にしたままグラフにしますと図7.1のようになります。 図 7.1: 5都道府県のH29財政力指数 このようにアルファベット順で横軸が並び替えられます。別にこれでも問題ないと思う方もいるかも知れませんが、基本的に日本の都道府県は北から南の方へ並べるのが一般的な作法です27。北海道と東京、大阪の間には順序関係はありません。しかし、表示される順番は固定したい。この場合、順序なしfactor型が活躍します。これを修正するためにはPref列を順序なしfactor型にすれば良いです28。データフレームの列を修正する方法は第8章で詳しく説明します。 Zaisei.df$Pref &lt;- factor(Zaisei.df$Pref, levels = c(&quot;Hokkaido&quot;, &quot;Tokyo&quot;, &quot;Aichi&quot;, &quot;Osaka&quot;, &quot;Fukuoka&quot;)) Zaisei.dfのPref列を順序付きfactor型にしてから同じ図を描くと図7.2のようになります。 図 7.2: 5都道府県のH29財政力指数 都道府県以外にもこのような例は多くあります。順序尺度で測定された変数が代表的な例です。他にも政党名を議席数順で表示させたい場合もfactor型は有効でしょう。 7.7 Date 7.7.1 なぜDate型があるのか Date型は年月日を表すデータ型29です。この2つのデータ型はかなり複雑ですが、ここでは簡単に説明します。Date型は日付の情報を含むため、順序関係が成立します。その意味では順序付きFactor型とあまり挙動は変わらないかもしれませんが、実際はそうではありません。 たとえば、Songの1週間30の睡眠時間を記録したデータSongSleepがあるとします。Dateという列には日付が、Sleep列には睡眠時間が記録されています。睡眠時間の単位は「分」です。 SongSleep &lt;- data.frame( Date = c(&quot;2017-06-17&quot;, &quot;2017-06-18&quot;, &quot;2017-06-19&quot;, &quot;2017-06-20&quot;, &quot;2017-06-21&quot;, &quot;2017-06-22&quot;, &quot;2017-06-23&quot;), Sleep = c(173, 192, 314, 259, 210, 214, 290) ) 中身をみると、以下のようになります。 SongSleep ## Date Sleep ## 1 2017-06-17 173 ## 2 2017-06-18 192 ## 3 2017-06-19 314 ## 4 2017-06-20 259 ## 5 2017-06-21 210 ## 6 2017-06-22 214 ## 7 2017-06-23 290 日付を横軸に、睡眠時間を縦軸にした散布図を描くと図@ref{fig:sleep1}このようになります。ggplot2を利用した作図については第@ref{visualization}章で解説しますので、ここではDate型の特徴のみ理解してもらえたら十分です。 ggplot(SongSleep, mapping = aes(x = Date, y = Sleep)) + geom_point() + labs(x = &quot;日付&quot;, y = &quot;睡眠時間 (分)&quot;) + theme_bw(base_family = &quot;HiraKakuProN-W3&quot;) 図 7.3: Songの睡眠時間 この図は全く問題ないように見えます。それでは、Date列をそれぞれDate型に変換し、SoongSleepデータのDateDとしてみます。データフレームの列追加については第8.4章で解説します。 SongSleep$DateD &lt;- as.Date(SongSleep$Date) 中身を見てみますが、あまり変わっていないようです。DateとDateD列は全く同じように見えますね。 SongSleep ## Date Sleep DateD ## 1 2017-06-17 173 2017-06-17 ## 2 2017-06-18 192 2017-06-18 ## 3 2017-06-19 314 2017-06-19 ## 4 2017-06-20 259 2017-06-20 ## 5 2017-06-21 210 2017-06-21 ## 6 2017-06-22 214 2017-06-22 ## 7 2017-06-23 290 2017-06-23 図にすると実は先ほどの図と同じものが得られます。 ggplot(SongSleep, mapping = aes(x = DateD, y = Sleep)) + geom_point() + labs(x = &quot;日付&quot;, y = &quot;睡眠時間 (分)&quot;) + theme_bw(base_family = &quot;HiraKakuProN-W3&quot;) 図 7.4: Songの睡眠時間 しかし、Songがうっかり6月19日に記録するのを忘れたとします。つまり、SongSleepデータの3行目が抜けている状況を考えてみましょう。データフレームの要素抽出については第8.4章で解説します。 SongSleep2 &lt;- SongSleep[-3, ] 中身をみると、以下のようになります。DateもDateDも同じように見えます。 SongSleep2 ## Date Sleep DateD ## 1 2017-06-17 173 2017-06-17 ## 2 2017-06-18 192 2017-06-18 ## 4 2017-06-20 259 2017-06-20 ## 5 2017-06-21 210 2017-06-21 ## 6 2017-06-22 214 2017-06-22 ## 7 2017-06-23 290 2017-06-23 この状態で横軸をDateにしたらどうなるでしょうか（図7.5）。 ggplot(SongSleep2, mapping = aes(x = Date, y = Sleep)) + geom_point() + labs(x = &quot;日付&quot;, y = &quot;睡眠時間 (分)&quot;) + theme_bw(base_family = &quot;HiraKakuProN-W3&quot;) 図 7.5: Songの睡眠時間 一方、横軸をDateDにしたものが図7.6です。 ggplot(SongSleep2, mapping = aes(x = DateD, y = Sleep)) + geom_point() + labs(x = &quot;日付&quot;, y = &quot;睡眠時間 (分)&quot;) + theme_bw(base_family = &quot;HiraKakuProN-W3&quot;) 図 7.6: Songの睡眠時間 違いが分かりますかね。違いは抜けている6月19日です。図7.5を見ると、横軸の6月18日の次が20日になっています。一方、図7.6は19日になっており、ちゃんと空けてくれますね。これはDate型でない場合、データにないものは図に表示されないことを意味します。一方、Date型は抜けている日があっても、図に表示表示されます。一般のcharacter型またはfactor型でこのようなことを再現するためには、6月19日の列を追加し、睡眠時間を欠損値として指定する必要があります。たとえば、SongSleepデータにおいて6月19日の行は温存したまま、睡眠時間だけを欠損値にしてみましょう。 SongSleep3 &lt;- SongSleep SongSleep3$Sleep[SongSleep$Date == &quot;2017-06-19&quot;] &lt;- NA SongSleep3 ## Date Sleep DateD ## 1 2017-06-17 173 2017-06-17 ## 2 2017-06-18 192 2017-06-18 ## 3 2017-06-19 NA 2017-06-19 ## 4 2017-06-20 259 2017-06-20 ## 5 2017-06-21 210 2017-06-21 ## 6 2017-06-22 214 2017-06-22 ## 7 2017-06-23 290 2017-06-23 このように日付はあるが、睡眠時間が欠損している場合、図にしたものが図7.7です。 ggplot(SongSleep3, mapping = aes(x = Date, y = Sleep)) + geom_point() + labs(x = &quot;日付&quot;, y = &quot;睡眠時間 (分)&quot;) + theme_bw(base_family = &quot;HiraKakuProN-W3&quot;) ## Warning: Removed 1 rows containing missing values (geom_point). 図 7.7: Songの睡眠時間 警告が表示されましたが、横軸上に6月19日が表示されます。このようにDate型でなくてもDate型と同じように動かすことは可能ですが、非常に面倒です。その意味でDate型は時系列データを扱う際に非常に便利なデータ型です。 7.7.2 Date型の作り方 Date型を作成方法はいくつかあります。 character型をDate型にする numeric型をDate型にする 主に使う方法は1であり、既に前節でお見せしましたas.Date()関数を使います。方法2もまたas.Date()を使いますが、これは「xxxx年xx月xx日から何日目」という書き方となり、起点となる日付 (origin)31を指定する必要があります。 ここでは方法1について解説します。日付を表すいくつかのベクトルを作ってみましょう。 Date1 &lt;- &quot;2020-05-21&quot; Date2 &lt;- &quot;2020-5-21&quot; Date3 &lt;- &quot;2020/5/21&quot; Date4 &lt;- &quot;20/05/21&quot; Date5 &lt;- &quot;20200521&quot; Date6 &lt;- &quot;2020 05 21&quot; Date7 &lt;- &quot;2020.05.21&quot; as.Date(Date1) ## [1] &quot;2020-05-21&quot; as.Date(Date2) ## [1] &quot;2020-05-21&quot; as.Date(Date3) ## [1] &quot;2020-05-21&quot; as.Date(Date4, &quot;%y/%m/%d&quot;) ## [1] &quot;2020-05-21&quot; as.Date(Date5, &quot;%Y%m%d&quot;) ## [1] &quot;2020-05-21&quot; as.Date(Date6, &quot;%Y %m %d&quot;) ## [1] &quot;2020-05-21&quot; as.Date(Date7, &quot;%Y.%m.%d&quot;) ## [1] &quot;2020-05-21&quot; Date1、Date2、Date3のようなベクトルの場合、as.Date()のみでDate型に変換できます。つまり、日付が数字のみで構成され、年が4桁となっており、年月日が-または/で区切られている場合はこれでだけで十分です。しかし、年が2桁になっていたり、その他の記号が使われたり、区切られていない場合は、fotmat =引数を指定する必要があります。たとえばDate4は年が2桁となっているます。2桁の年は%yと表記します。この表記法の一部を以下の表で紹介します。 表記 説明 例 %y 年 (2桁) 20 %Y 年 (4桁) 2020 %m 月 (数字) 5, 10 %b 月 (文字) Jan %B 月 (文字) January %d 日 5, 05, 13 他にも様々な表記法がありますが、詳細は?strptimeで確認してみてください。 他にも、日本では使わない表記法ですが、月を英語で表記したり、日月年の順で表記する場合があります。後者はformat =引数の順番を変えるだけで問題有りませんが、問題は前者です。そこで使うのが%bまたは%Bです。%bは3文字の月表記で、%Bはフルネームです。 as.Date(&quot;21may2020&quot;, format = &quot;%d%b%Y&quot;) ## [1] NA as.Date(&quot;May/21/2020&quot;, format = &quot;%b/%d/%Y&quot;) ## [1] NA うまくいかないですね。これはシステムの時間ロケールが日本になっているのが原因です。ロケール設定はSys.getlocale()で確認できます。 Sys.getlocale(category = &quot;LC_TIME&quot;) ## [1] &quot;ja_JP.UTF-8&quot; これをSys.setlocale()を使って、\"C\"に変更します。 Sys.setlocale(category = &quot;LC_TIME&quot;, locale = &quot;C&quot;) ## [1] &quot;C&quot; それではもう一回やってみましょう。 as.Date(&quot;21may2020&quot;, format = &quot;%d%b%Y&quot;) ## [1] &quot;2020-05-21&quot; as.Date(&quot;May/21/2020&quot;, format = &quot;%b/%d/%Y&quot;) ## [1] &quot;2020-05-21&quot; うまく動くことが確認できました。念の為に、ロケールを戻しておきます。 Sys.setlocale(category = &quot;LC_TIME&quot;, locale = &quot;ja_JP.UTF-8&quot;) ## [1] &quot;ja_JP.UTF-8&quot; 7.7.3 POSIXct、POSIXlt型について POSIXct、POSIXlt型は日付だけでなく時間の情報も含むデータがたです。これらはas.POSIXct()、as.POSIXlt()関数で作成することができます。どちらも見た目は同じデータ型ですが、内部構造がことなります32。詳細は?as.POSIXctまたは?as.POSIXltを参照してください。 7.8 NA NAは欠損値と呼ばれます。これは本来は値があるはずなのがなんらかの理由で欠損していることを意味します。表7.3の例を考えてみましょう。 表 7.3: 4人の支持政党 ID 名前 支持政党あり 政党名 1 Yanai ない NA 2 Song ある ラーメン大好き党 3 Shigemura ある 鹿児島第一党 4 Tani ない NA 3列目で支持政党があるケースのみ、4列目に値があります。YanaiとTaniの場合、支持する政党がないため、政治政党名が欠損しています。実際、多くのデータには欠損値が含まれています。世論調査データの場合はもっと多いです。理由としては「Q2で“はい”を選んだ場合のみQ3に進み、それ以外はQ4へ飛ばす」のようなのもありますが、単に回答を拒否した場合もあります。 まずは欠損値が含まれたベクトルNA.Vec1を作ってみましょう。 NA.Vec1 &lt;- c(1, NA, 3, NA, 5, 6) NA.Vec1 ## [1] 1 NA 3 NA 5 6 つづいて、データ型を確認してみましょう。 class(NA.Vec1) ## [1] &quot;numeric&quot; NAが含まれていてもデータ型はnumericのままです。これは「一応、欠損しているが、ここに何らかの値が割り当てられるとしたらそれはnumeric型だろう」とRが判断しているからです。ある要素がNAか否かを判定するにはis.na()関数を使います。 is.na(NA.Vec1) ## [1] FALSE TRUE FALSE TRUE FALSE FALSE 2番目と4番目の要素が欠損していることが分かります。 欠損値も要素の一つとしてカウントされるため、ベクトルの長さは6になります。ベクトルの長さはlength()関数で確認できます。 length(NA.Vec1) ## [1] 6 欠損値の取り扱い 欠損値を含むデータの処理方法はやや特殊です。まず、NA.Vec1の要素全てに1を足してみましょう。 NA.Vec1 + 1 ## [1] 2 NA 4 NA 6 7 この場合、欠損値の箇所には1が足されず、それ以外の要素のみに1を足した結果が返ってきます。これは直感的に考えると自然です。問題になるのは欠損値が含まれるベクトルを関数に入れた場合です。たとえば、numeric型ベクトル内の要素の総和を求めるにはsum()関数を使います。sum(c(1, 3, 5))を入力すると9が返されます。NA.Vec1は欠損していない要素が1, 3, 5, 6であるため、総和は15のはずです。確認してみましょう。 sum(NA.Vec1) ## [1] NA このように欠損値を含むベクトルの総和はNAとなります。もし、欠損値を除いた要素の総和を求めるには、まずベクトルから欠損値を除去する必要があります。そのためにはis.na()関数を使ってNA.Vec1の要素を抽出します。ただし、is.na()を使うと、欠損値であるところがTRUEになるため、これを反転する必要があります。この場合は!is.na()関数を使います。それではis.na()と!is.na()を使って要素を抽出してみましょう。 NA.Vec1[is.na(NA.Vec1)] ## [1] NA NA NA.Vec1[!is.na(NA.Vec1)] ## [1] 1 3 5 6 !is.na()を使うことで欠損値を除いた要素のみを取り出すことができました。これならsum()関数も使えるでしょう。 sum(NA.Vec1[!is.na(NA.Vec1)]) ## [1] 15 これで欠損値を除いた要素の総和を求めることができました。ただし、一部の関数には欠損値を自動的に除去するオプションを持つ場合があります。sum()関数のその一部であり、na.rm = TRUEオプションを付けると、欠損値を除いた総和を返します。 sum(NA.Vec1, na.rm = TRUE) ## [1] 15 欠損値の使い方 主に欠損値を扱うのは入手したデータに含まれる欠損値に対してですが、NAをこちらから生成することもあります。それは空ベクトルを用意する時です。第9章では関数の作り方について解説します。関数内で何らかの処理を行い、その結果を返すことになりますが、その結果を格納するベクトルを事前に作っておくこともできます。こちらの方がメモリの観点からは効率的です。以下は第9章を読んでから読んでも構いません。 もし、長さ10のベクトルResult.Vec1を返すとします。ベクトルの要素として1から10の数字が入るとします。一つ目の方法としてはまず、Result.Vec1に1を代入し、次はc()を使って要素を一つずつ足して行く手順です。 Result.Vec1 &lt;- 1 Result.Vec1 &lt;- c(Result.Vec1, 2) Result.Vec1 &lt;- c(Result.Vec1, 3) Result.Vec1 &lt;- c(Result.Vec1, 4) Result.Vec1 &lt;- c(Result.Vec1, 5) Result.Vec1 &lt;- c(Result.Vec1, 6) Result.Vec1 &lt;- c(Result.Vec1, 7) Result.Vec1 &lt;- c(Result.Vec1, 8) Result.Vec1 &lt;- c(Result.Vec1, 9) Result.Vec1 &lt;- c(Result.Vec1, 10) 二つ目の方法はまず、10個のNAが格納されたベクトルReuslt.Vec2を作っておいて、その中に要素を置換してく方法です。 Result.Vec2 &lt;- rep(NA, 10) Result.Vec2[1] &lt;- 1 Result.Vec2[2] &lt;- 2 Result.Vec2[3] &lt;- 3 Result.Vec2[4] &lt;- 4 Result.Vec2[5] &lt;- 5 Result.Vec2[6] &lt;- 6 Result.Vec2[7] &lt;- 7 Result.Vec2[8] &lt;- 8 Result.Vec2[9] &lt;- 9 Result.Vec2[10] &lt;- 10 以上の手順をfor()を使って反復処理するとしたら、以下のようなコードになります。 # 方法1 Result.Vec1 &lt;- 1 for (i in 2:10) { Result.Vec1 &lt;- c(Result.Vec1, i) } # 方法2 Result.Vec2 &lt;- rep(NA, 10) for (i in 1:10) { Result.Vec2[i] &lt;- i } 結果を確認してみましょう。 Result.Vec1 ## [1] 1 2 3 4 5 6 7 8 9 10 Result.Vec2 ## [1] 1 2 3 4 5 6 7 8 9 10 コードの書き方は異なりますが、どれも結果は同じです。また、どちらが早いかというと、これくらいの計算ならどの方法でも同じです。ただし、より大規模の反復作業を行う場合、後者の方が時間が節約でき、コードの可読性も高いです。 7.9 NULL NULLは「存在しない」、空っぽであることを意味します。先ほどのNAはデータは存在するはずなのに、何らかの理由で値が存在しない、または割り当てられていないことを意味しますが、NULLは「存在しません」。したがって、NULLが含まれたベクトルを作成しても表示されません。NULLが含まれたNULL.Vec1を作ってみましょう。 NULL.Vec1 &lt;- c(1, 3, NULL, 5, 10) NULL.Vec1 ## [1] 1 3 5 10 3番目の要素であるNULLは表示されません。ということはNAと違って、データの長さも5ではなく4でしょう。確認してみます。 length(NULL.Vec1) ## [1] 4 このNULL.Vec1のデータ型は何でしょう。 class(NULL.Vec1) ## [1] &quot;numeric&quot; is.null()関数もありますが、どうでしょうか。 is.null(NULL.Vec1) ## [1] FALSE NULLは存在しないことを意味するため、NULL.Vec1は要素が4のnumeric型ベクトルです。is.null()でNULLが判定できるのはis.null(NULL)のようなケースです。このNULLはいつ使うのでしょうか。実際、使う機会はあまりありません。強いて言えば、空っぽのリストを作成する際に使うケースがあります。リストについては第8章で説明します。以下の例は第8章を読み終わってから目を通して下さい。 NULL.List1 &lt;- list(Room1 = 1:3, Room2 = c(&quot;Yuki&quot;, &quot;Jaehyun&quot;, &quot;Hadley&quot;), Room3 = NULL) NULL.List1 ## $Room1 ## [1] 1 2 3 ## ## $Room2 ## [1] &quot;Yuki&quot; &quot;Jaehyun&quot; &quot;Hadley&quot; ## ## $Room3 ## NULL このように予めリストの要素は作っておきたいが、とりあえず空けておく際に使います。続く分析の段階でNULL.List1[[\"Room3\"]]に何かを格納したりすることに使えるでしょう。ちなみにこの場合はis.null()が使用可能です。 is.null(NULL.List1[[&quot;Room3&quot;]]) ## [1] TRUE 7.10 NaN NaNはnumeric型、中でもdouble型の一種ですが、これは計算できない値を意味します。つまり、NaN値を直接入力することはめったにありませんが、計算の結果としてNaNが返されるケースがあります。代表的な例が0を0で割った場合です。実際、0を0で割ることはできません。ここでは0を0で割った値を含むNaN.Vec1作ってみましょう。 NaN.Vec1 &lt;- c(2/5, 0/12, 0/0) NaN.Vec1 ## [1] 0.4 0.0 NaN class(NaN.Vec1) ## [1] &quot;numeric&quot; 先ほどせつめいしましたように、NaNはnumeric型の一部ですので、データ型としてはnumeircになります。ある値がNaNか否かを判定するにはis.nan()関数を使います。 is.nan(NaN.Vec1) ## [1] FALSE FALSE TRUE 7.11 Inf Infもまたnumeric型、中でもdouble型の一部ですが、これは無限大を意味します。Infも通常、自分から作成するケースはあまりなく、結果として帰ってくる場合があります。一つの例が0以外の数値を0で割った場合です。それではなんらかの数値を0を割った値が含まれるベクトルInf.Vec1を作ってみましょう。 Inf.Vec1 &lt;- c(28/95, 3/0, -12/0, 0/0) Inf.Vec1 ## [1] 0.2947368 Inf -Inf NaN class(Inf.Vec1) ## [1] &quot;numeric&quot; 正の値を0で割ったらInfが負の値を0で割ったら-Infが返ってきます。これは正の無限大、負の無限大を意味します。データ型はNaNと同様、numeric型ですが、is.infinite()を使うと、無限大か否かが判定できます。 is.infinite(Inf.Vec1) ## [1] FALSE TRUE TRUE FALSE アメリカの州ならアルファベット順ですね。↩︎ むろん、「北から南へ」という規則もあるので、順序付きfactor型にしても問題ありません。ただし、今回はあくまでも表示順番を設定したいだけですので、ordered = TRUEは省略しました。↩︎ 他にも時間まで表すDateTime型があります。↩︎ 実際は2017年6月17日から11月15日まで記録しましたが、ここでは1週間分のみお見せします。↩︎ 主に使うoriginは1970年1月1日です。↩︎ POSIXct型は基準日 (1970年1月1日 00時00分00秒 = UNIX時間)からの符号付き経過秒数であり、POSIXlt型は日付、時間などがそれぞれ数字として格納されています。可読性の観点からはPOSIXlt型が優れていますが、データ処理の観点から見るとPOSIXct型の方が優れていると言われます。↩︎ "],
["datastructure.html", "8. データの構造 8.1 データ構造とは 8.2 ベクトル (vector) 8.3 行列 (matrix) 8.4 データフレーム (data.frame) 8.5 リスト (list) 8.6 配列 (array) 8.7 練習問題", " 8. データの構造 目次 第8.1章: データ構造とは 第8.2章: ベクトル 第8.3章: 行列 第8.4章: データフレーム 第8.5章: リスト 第8.6章: 配列 第8.7章: 練習問題 8.1 データ構造とは データ構造 (data structure)とは最小単位であるベクトルを何らかの形で集めたものです。ベクトル自体もデータ構造であり、同じデータ型のベクトルを積み重ねた行列、異なるデータ型の縦ベクトルを横に並べたデータフレームなど、Rでは様々なデータ構造を提供しています。また、R内臓のデータ構造以外にも、パッケージ等で提供される独自のデータ構造もあります。ここではRが基本的に提供している代表的なデータ構造について、その作り方と操作方法について解説します。 8.2 ベクトル (vector) 8.2.1 ベクトルの作り方 Rにおいてベクトルとは同じデータ型が一つ以上格納されているオブジェクトを意味します。たとえば、以下のmyVec1は長さ1のベクトルです。 myVec1 &lt;- &quot;R is fun!&quot; myVec1 ## [1] &quot;R is fun!&quot; むろん、2つ以上の文字列、または数字を格納することも可能です。以下のmyVec2は長さ5のベクトルです。 myVec2 &lt;- c(1, 3, 5, 6, 7) myVec2 ## [1] 1 3 5 6 7 注意すべきところは、ベクトル内の要素は必ず同じデータ型である必要があるということです。たとえば、数字と文字が混在したmyVec3を考えてみましょう。 myVec3 &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, 1, 2, 3) myVec3 ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; 数字であるはずの1, 2, 3が\"で囲まれ、文字列に自動的に変換されていることが分かります。実際に、デーが型を確認してみましょう。 class(myVec3) ## [1] &quot;character&quot; \"character\"、つまりデータ型が文字列になっていることが分かります。これはcharacter型がnumeric型よりも優先順位が高いからです。それではnumericとlogical型はどうでしょうか。 myVec4 &lt;- c(1, 2, 3, TRUE, FALSE) myVec4 ## [1] 1 2 3 1 0 class(myVec4) ## [1] &quot;numeric&quot; TRUEが1、FALSEが0となり、自動的にnumeric型になりました。一般的によく使われるデータ型はlogical、numeric、characterですが、優先順位はlogical &lt; numeric &lt; characterの関係になります。ここで重要なのは優先順位ではなく、異なるデータ型が含まれるベクトルの場合、自動的にデータ型が統一されるということです。ベクトルを作成する際は、全ての要素が同じ型になるようにしましょう。 8.2.2 ベクトルの操作 ベクトルの長さ ベクトルの長さはベクトルに含まれている要素の数です。ベクトルの長さはlength()関数で調べることができます。それでは前節で作成した4つのベクトルの長さを調べてみましょう。 length(myVec1) # &quot;R is fun!&quot; ## [1] 1 length(myVec2) # c(1, 3, 5, 6, 7) ## [1] 5 length(myVec3) # c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;) ## [1] 6 length(myVec4) # c(1, 2, 3, 1, 0) ## [1] 5 それぞれのベクトルの長さは1、5、6、5ということが分かりますね。 要素の抽出 これは既に説明しましたので、6.4を参照してください。 ベクトルの加減乗除 ここではnumeric型のベクトルを用いた加減乗除について考えたいと思います。Rにおいてベクトルは自動的に反復作業を行います。たとえば、c(1, 2, 3, 4)というベクトルがあり、ここに5を足すと、ベクトルの全ての要素に対して同じ計算を行います。これは引き算でも、掛け算でも、割り算でも同じです。むろん、べき乗などの様々な操作に対しても同じです。それではmyVec2に対して、5を足したり、引いたり、色々してみましょう。 myVec2 + 5 ## [1] 6 8 10 11 12 myVec2 - 5 ## [1] -4 -2 0 1 2 myVec2 * 5 ## [1] 5 15 25 30 35 myVec2 / 5 ## [1] 0.2 0.6 1.0 1.2 1.4 myVec2 ^ 5 ## [1] 1 243 3125 7776 16807 また、ベクトル同士の演算も可能です。まず、myVec2と同じ長さを持つmyVec4との計算を考えてみましょう。これは長さが同じであるため、それぞれ同じ位置の要素同士の計算となります。つまり、足し算の場合、myVec2[1]とmyVec4[1]の和、myVec2[2]とmyVec4[2]の和、…といった形です。 myVec2 + myVec4 ## [1] 2 5 8 7 7 myVec2 - myVec4 ## [1] 0 1 2 5 7 myVec2 * myVec4 ## [1] 1 6 15 6 0 myVec2 / myVec4 ## [1] 1.000000 1.500000 1.666667 6.000000 Inf もし、ベクトルの長さが異なる場合はどうなるでしょう。たとえば、長さ2のベクトルmyVec5とmyVec2の足し算を考えてみましょう。 (myVec5 &lt;- c(1, 10)) ## [1] 1 10 (myVec6 &lt;- myVec2 + myVec5) ## Warning in myVec2 + myVec5: 長いオブジェクトの長さが短いオブジェクトの長さの倍数になって ## いません ## [1] 2 13 6 16 8 警告メッセージは表示されますが、計算自体はできます。同じ長さのベクトル同士なら、同じ位置の要素同士の計算になりますが、この場合は、短い方のベクトルを繰り返すことにより、長さを合わせることになります。myVec5の例だと、c(1, 10, 1, 10, 1)のように扱われます。具体的には以下の表のような関係となります。 myVec6[1] myVec6[2] myVec6[3] myVec6[4] myVec6[5] myVec2[1] myVec2[2] myVec2[3] myVec2[4] myVec2[5] + + + + + myVec5[1] myVec5[2] myVec5[1] myVec5[2] myVec5[1] 実際は長さが異なるベクトル同士の計算を行うことは滅多にありません。例外としては長さ1のベクトルの計算くらいですね。 文字列ベクトルの扱い方はより複雑ですので、第16章で詳細に解説します。 8.3 行列 (matrix) 行列は名前とおり、行と列で構成されたデータ構造です。ただし、我々が一般に考える「表」とは異なる点があります。それは行列内部の要素に制約がある点です。具体的に、行列の要素となり得るデータ型はnumeric、complex、NA型のみです。ここではnumeric型のみで構成された行列の作成および操作方法について解説します。 8.3.1 行列の作り方 行列を作成するにはmatrix()関数を使います。引数として、行列に入る数値と行または列の数は必須です。数値はベクトルであり、行・列の数は整数です。以下のような行列を作るにはいくつかの方法があります。 \\[ \\left[ \\begin{matrix} 1 &amp; 2 &amp; 3 &amp; 4 \\\\ 5 &amp; 6 &amp; 7 &amp; 8 \\\\ 9 &amp; 10 &amp; 11 &amp; 12 \\end{matrix} \\right] \\] # 方法1: 行数を指定する Matrix1 &lt;- matrix(c(1, 5, 9, 2, 6, 10, 3, 7, 11, 4, 8, 12), nrow = 3) Matrix1 ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 # 方法2: 列数を指定する Matrix2 &lt;- matrix(c(1, 5, 9, 2, 6, 10, 3, 7, 11, 4, 8, 12), ncol = 4) Matrix2 ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 いずれも同じ結果が得られます。注意してもらいたいところは、第一引数の書き方です。我々は「左から右へ、そして上から下へ」という順番で読むのになれていますが、Rの行列は「上から下へ、そして左から右へ」の順番です。もし、「左から右へ、そして上から下へ」のような、より我々にとって読みやすい書き方をするためにはもう一つの引数が必要であり、それがbyrow =です。 (matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), nrow = 3, byrow = TRUE)) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 むろん、初項1、公差1、最大値12の等差数列ですのて、1:12のような書き方も可能です。 (matrix(1:12, nrow = 3, byrow = TRUE)) ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 データ構造も確認してみましょう。 class(Matrix1) ## [1] &quot;matrix&quot; &quot;array&quot; R 4.0.0からの仕様変更により行列型はmatrix構造以外にもarrayの構造も持つようになりました。array型については第8.6章で解説します。 単位行列 最後にちょっと特殊な行列である単位行列 (indetity matrix)の作り方について説明します。単位行列とは行と列の数が同じである正方形の行列ですが、対角線上は全て1、その他は全て0となっている行列です。たとえば大きさが4の単位行列は、 \\[ \\left[ \\begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{matrix} \\right] \\] です。これはmatrix(c(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), nrow = 4)で作成することも可能ですが、diag()関数を使えば簡単に出来ます。サイズが4の単位行列はdiag(4)です。 (diag(4)) ## [,1] [,2] [,3] [,4] ## [1,] 1 0 0 0 ## [2,] 0 1 0 0 ## [3,] 0 0 1 0 ## [4,] 0 0 0 1 8.3.2 行列の操作 まず、以下のような行列Aを作ってみましょう。 \\[ A = \\left[ \\begin{matrix} 1 &amp; 2 &amp; 3 &amp; 4 \\\\ 5 &amp; 6 &amp; 7 &amp; 8 \\\\ 9 &amp; 10 &amp; 11 &amp; 12 \\end{matrix} \\right] \\] A &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), nrow = 3, byrow = TRUE) 行列のサイズ 行列の大きさ (行と列の数)を求める際はdim()関数を使います。 dim(A) ## [1] 3 4 結果は長さ2のベクトルですが、1番目の要素が行数、2番目の要素が列数になります。もし、行列の行数のみ確認したい場合はdim(A)[1]、列数ならdim(A)[2]で確認することができます。また、全く同じ機能を持つ関数があり、それがnrow()とncol()関数です。 nrow(A) # 行列の行数を確認: dim(A)[1]と同じ ## [1] 3 ncol(A) # 列列の列数を確認: dim(A)[2]と同じ ## [1] 4 dim()およびnrow()、ncol()関数は第8.4章で紹介するデータフレームでも使用可能です。 要素の抽出 ベクトルと同様、要素の抽出は[]を使います。ただし、行列は横と縦の2次元構成となりますので、行と列のそれぞれの位置を指定する必要があります。たとえば、Aの2行目、3列目の要素を抽出するためには、 A[2, 3] ## [1] 7 のように書きます。行か列の位置を省略した場合、指定した列・行全てが抽出されます。2行目の要素全てを抽出するならA[2, ]、3列目の要素全てを抽出するならA[, 3]となります。 A[2, ] ## [1] 5 6 7 8 A[, 3] ## [1] 3 7 11 この場合、返される値のデータ構造はいずれも行列でなく、ベクトルです。確認してみましょう。 is.vector(A[2, 3]) ## [1] TRUE is.vector(A[2, ]) ## [1] TRUE is.vector(A[, 3]) ## [1] TRUE 例外は複数の行と複数の列を同時に抽出した場合です。たとえば、行列Aの1・2行目と2・3列目の要素を全て抽出するとします。その場合はA[1:2, 2:3]のように書きます。むろん、:を使わずにA[c(1, 2), c(2, 3)]のような書き方も可能です。抽出後、返された結果のデータ構造も確認してみましょう。 A[1:2, 3:4] ## [,1] [,2] ## [1,] 3 4 ## [2,] 7 8 class(A[1:2, 3:4]) ## [1] &quot;matrix&quot; &quot;array&quot; この場合、返された結果のデータ構造は行列であることが分かります。 行列の足し算と引き算 行列の足し算 (引き算)には 行列内の全要素に対して同じ数字を足す (引く) 同じサイズの2つの行列から対応する要素を足す (引く) 2パタンがあります。例えば、行列Aの全要素に5を足す場合は以下のように入力します。 (A_plus_5 &lt;- A + 5) ## [,1] [,2] [,3] [,4] ## [1,] 6 7 8 9 ## [2,] 10 11 12 13 ## [3,] 14 15 16 17 同様に、Aから10を引く場合は-演算子を使います。 (A_minus_10 &lt;- A - 10) ## [,1] [,2] [,3] [,4] ## [1,] -9 -8 -7 -6 ## [2,] -5 -4 -3 -2 ## [3,] -1 0 1 2 二つ目は同じサイズの行列同士の足し算と引き算です。行列Aは3 \\(\\times\\) 4の行列ですので、同じサイズの行列Bを作成してみましょう。 (B &lt;- matrix(c(3, 2, 1, 4, 5, 9, 7, 11, 6, 12, 8, 10), nrow = 3, byrow = TRUE)) ## [,1] [,2] [,3] [,4] ## [1,] 3 2 1 4 ## [2,] 5 9 7 11 ## [3,] 6 12 8 10 この行列AとBの足し算はそれぞれ同じ位置の要素同士の和を行列をして返し、これは引き算も同じです。 A + B ## [,1] [,2] [,3] [,4] ## [1,] 4 4 4 8 ## [2,] 10 15 14 19 ## [3,] 15 22 19 22 A - B ## [,1] [,2] [,3] [,4] ## [1,] -2 0 2 0 ## [2,] 0 -3 0 -3 ## [3,] 3 -2 3 2 注意すべき点は、2つの行列は同じ大きさでなければならない点です。たとえば、行列Bの1列から3列までを抽出した3 \\(\\times\\) 3行列Cを作成し、A + Cをしてみましょう。 (C &lt;- B[, 1:3]) ## [,1] [,2] [,3] ## [1,] 3 2 1 ## [2,] 5 9 7 ## [3,] 6 12 8 A + C ## Error in A + C: 適切な配列ではありません このように足し算ができなくなり、これは引き算でも同じです。 行列の掛け算 やや特殊なのは行列の掛け算です。行列Aの全要素を2倍にしたい場合、これは足し算・引き算と同じやり方で十分です。 A * 2 ## [,1] [,2] [,3] [,4] ## [1,] 2 4 6 8 ## [2,] 10 12 14 16 ## [3,] 18 20 22 24 ただし、問題は行列同士の掛け算です。行列AとBの掛け算といえば、直感的には足し算や引き算同様、同じ位置の要素の積と考えるかも知れません。実際A * Bはそのように計算を行います。 A * B ## [,1] [,2] [,3] [,4] ## [1,] 3 4 3 16 ## [2,] 25 54 49 88 ## [3,] 54 120 88 120 ただし、このような掛け算は「アダマール積 (Hadamard product)」と呼ばれる計算方法であり33、一般的に使う掛け算ではありません。実際、数学において\\(A \\times B\\)はアダマール積を意味すのではなく、アダマール積は\\(A \\circ B\\)または\\(A \\odot B\\)と表記します。 それでは一般的な行列の積は何でしょう。詳しいことは線形代数の入門書に譲りますが、以下のような2つの行列CとDを考えてみましょう。 \\[ C = \\left[ \\begin{matrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\end{matrix} \\right], D = \\left[ \\begin{matrix} 2 &amp; 7 &amp; 17 \\\\ 3 &amp; 11 &amp; 19 \\\\ 5 &amp; 13 &amp; 23 \\end{matrix} \\right] \\] 行列の大きさが異なりますね。行列Cの大きさは2 \\(\\times\\) 3、Dは3 \\(\\times\\) 3です。実はこれが正しいです。行列の積は\\(n \\times m\\)の行列と\\(m \\times p\\)の行列同士でないと計算できません。\\(n\\)と\\(p\\)は同じでも、同じでなくても構いません。その意味で\\(C \\times D\\)は計算可能でも、\\(D \\times C\\)は計算できません。そして、2つの行列の積の大きさは\\(n \\times p\\)です。したがって、\\(C \\times D\\)の大きさは\\(2 \\times 3\\)です。 行列の積がどのように求められるかを確認するために、まず行列CとDを作成してみましょう。 (C &lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2,byrow = TRUE)) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 (D &lt;- matrix(c(2, 7, 17, 3, 11, 19, 5, 13, 23), nrow = 3,byrow = TRUE)) ## [,1] [,2] [,3] ## [1,] 2 7 17 ## [2,] 3 11 19 ## [3,] 5 13 23 この2つの積は%*%演算子で計算されますが、まずその結果から見ましょう。 (E &lt;- C %*% D) ## [,1] [,2] [,3] ## [1,] 23 68 124 ## [2,] 53 161 301 2行2列の行列ができました。これらの数字、どうやった計算されたのでしょうか。Eの[1, 1]は23であり、[1, 2]は68、[2, 1]は53、[2, 2]は161です。各値は以下のように求まります。 E[1, 1] = (C[1, 1] * D[1, 1]) + (C[1, 2] * D[2, 1]) + (C[1, 3] * D[3, 1]) = 23 E[1, 2] = (C[1, 1] * D[1, 2]) + (C[1, 2] * D[2, 2]) + (C[1, 3] * D[3, 2]) = 68 E[1, 3] = (C[1, 1] * D[1, 3]) + (C[1, 2] * D[2, 3]) + (C[1, 3] * D[3, 3]) = 124 E[2, 1] = (C[2, 1] * D[1, 1]) + (C[2, 2] * D[2, 1]) + (C[2, 3] * D[3, 1]) = 53 E[2, 2] = (C[2, 1] * D[1, 2]) + (C[2, 2] * D[2, 2]) + (C[2, 3] * D[3, 2]) = 161 E[2, 3] = (C[2, 1] * D[1, 3]) + (C[2, 2] * D[2, 3]) + (C[2, 3] * D[3, 3]) = 301 大きさ\\(n \\times m\\)行列Cのi行目j列目の要素を\\(C_{i,j}\\)と表記し、大きさ\\(n \\times p\\)行列Dのi行目j列目の要素を\\(D_{i,j}\\)と表記した場合、以下のような関係が成り立ちます。 行列Eのi行目j列目の要素を\\(e_{i,j}\\)と表記した場合、以下のような関係が成り立ちます。 \\[ e_{i, j} = \\sum_{k = 1}^m C_{i, k} \\cdot D_{k, j}. \\] したがって、行列\\(C\\)と\\(D\\)の積は \\[\\begin{align} CD = E &amp; = \\left[ \\begin{matrix} e_{1, 1} &amp; e_{1, 2} &amp; e_{1, 3} \\\\ e_{2, 1} &amp; e_{2, 2} &amp; e_{2, 3} \\end{matrix} \\right] \\\\ &amp; = \\left[ \\begin{matrix} \\sum_{k = 1}^m C_{1, k} \\cdot D_{k, 1} &amp; \\sum_{k = 1}^m C_{1, k} \\cdot D_{k, 2} &amp; \\sum_{k = 1}^m C_{1, k} \\cdot D_{k, 3} \\\\ \\sum_{k = 1}^m C_{2, k} \\cdot D_{k, 1} &amp; \\sum_{k = 1}^m C_{2, k} \\cdot D_{k, 2} &amp; \\sum_{k = 1}^m C_{2, k} \\cdot D_{k, 3} \\end{matrix} \\right]. \\end{align}\\] このように業績同士の積はかなり求めるのが面倒ですが、Rを使えば一瞬で終わります。 行列式 行列式 (determinant)は\\(n \\times n\\)の正方行列のみに対して定義される値の一つです。主に一次方程式において解が存在するか否かを判断するために用いられる数値ですが34、その詳しい意味や求め方については線形代数の入門書を参照してください。 行列\\(A\\)の行列式は一般的に\\(\\text{det}(A)\\)、または\\(|A|\\)と表記されます。行列式を求めるRの関数はdet()です。それでは適当に正方行列Fを作成し、その行列を求めてみましょう。 (F &lt;- matrix(c(2, -6, 4, 7, 2, 3, 8, 5, -1), nrow = 3, byrow = 3)) ## [,1] [,2] [,3] ## [1,] 2 -6 4 ## [2,] 7 2 3 ## [3,] 8 5 -1 det(F) ## [1] -144 行列Fの行列式は-144です。この場合、以下の一次方程式に何らかの一組の解が存在することを意味します (\\(p\\), \\(q\\), \\(r\\)は任意の実数)。 \\[\\begin{align} 2x - 6y + 4z = &amp; p, \\\\ 7x + 2y + 3z = &amp; q, \\\\ 8x + 5y - 1z = &amp; r. \\end{align}\\] しかし、以下のような連立方程式はいかがでしょう。これは二組以上の解が存在する方程式です35。 \\[\\begin{align} 2x - 6y + 4z = &amp; p, \\\\ 1x - 3y + 2z = &amp; q, \\\\ 5x + 9y + 3z = &amp; r. \\end{align}\\] 実際に行列Gを作成し、det(G)を計算してみましょう。 (G &lt;- matrix(c(2, -6, 4, 1, -3, 2, 5, 9, 3), nrow = 3, byrow = 3)) ## [,1] [,2] [,3] ## [1,] 2 -6 4 ## [2,] 1 -3 2 ## [3,] 5 9 3 det(G) ## [1] 0 \\(|G|\\)は0であることが分かりますね。 階数 行列の特徴を表す代表的な数値の一つが階数 (rank)です。詳しい説明は省きますが、一次方程式の例だと、階数が行列の行数と一致する場合、一組の解が存在することを意味します。階数を求める方法はqr(行列)$rankであり、行列FとGの階数を確認してみましょう。 qr(F)$rank ## [1] 3 qr(G)$rank ## [1] 2 どれも3行の行列ですが、行列Fの階数は3、行列Gの階数は2です。Gの階数はGの行数より小さいため、連立方程式に一組の解がないことが分かります。 階数の活用先は様々であり、行列式とは違って、正方行列でなくても計算可能です。 逆行列 逆行列とは掛け算すると単位行列となる行列を意味します。行列\\(A\\)の逆行列は一般的に\\(A^{\\prime}\\)と表記し、\\(A \\times A^{\\prime} = I\\)となります。この逆行列の求め方は非常に複雑であり、一定以上の大きさの行列になると手計算で解くのはほぼ不可能です。しかし、Rでは逆行列を計算するsolve()関数が内蔵されております。 以下の行列\\(A\\) (A)の逆行列、\\(A^{\\prime}\\) (Ap)を求めてみましょう。そして\\(A \\times A^{\\prime}\\)が単位行列になるかまで確認してみます。 # 行列Aの作成 (A &lt;- matrix(c(1, -2, 2, 0, 1, -1, 1, 0, 1), nrow = 3)) ## [,1] [,2] [,3] ## [1,] 1 0 1 ## [2,] -2 1 0 ## [3,] 2 -1 1 # 行列Aの逆行列を計算し、Apに格納 (Ap &lt;- solve(A)) ## [,1] [,2] [,3] ## [1,] 1 -1 -1 ## [2,] 2 -1 -2 ## [3,] 0 1 1 # AとApの積が単位行列であることを確認 A %*% Ap ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 0 1 0 ## [3,] 0 0 1 ちゃんと単位行列ができましたね。 転置 行列\\(A\\)の転置行列は\\(A^T\\)と表記され、以下のような関係となります。 \\[ A = \\left[ \\begin{matrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\end{matrix} \\right], A^T = \\left[ \\begin{matrix} 1 &amp; 4 &amp; 7 \\\\ 2 &amp; 5 &amp; 8 \\\\ 3 &amp; 6 &amp; 9 \\end{matrix} \\right] \\] 正方行列の場合、対角成分を除き、全ての要素が対角成分を中心に反転していることが分かりますね。このような転置行列の作成にはt()関数を使います。それでは行列Aとその転置行列Atを作ってみましょう。 A &lt;- matrix(1:9, byrow = TRUE, nrow = 3) A ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 At &lt;- t(A) ちなみに転置行列は正方行列でなくても作成できます。 8.4 データフレーム (data.frame) データフレームはデータ分析の際に最もよく見るデータ構造です。我々が一般的に考える表形式のデータはデータフレームです。行列も見た目は表に近いですが、行列は中身の要素がnumericまたはcomplex型に限定されるに対して36、データフレームはcharacterやfactor、Dateなど様々なデータ型が許容されます。 8.4.1 データフレームの作成 まずは、表8.1のようなデータフレームを作成して見ましょう。データフレームを作成する際はdata.frame()関数を使います。 表 8.1: myDFの中身 ID Name Math Stat 1 Yanai 50 25 2 Song 90 5 3 Shigemura 100 100 4 Tani 80 85 myDF &lt;- data.frame( ID = 1:4, Name = c(&quot;Yanai&quot;, &quot;Song&quot;, &quot;Shigemura&quot;, &quot;Tani&quot;), Math = c(50, 90, 100, 80), Stat = c(25, 5, 100, 85) ) myDF ## ID Name Math Stat ## 1 1 Yanai 50 25 ## 2 2 Song 90 5 ## 3 3 Shigemura 100 100 ## 4 4 Tani 80 85 データ構造を確認してみましょう。 class(myDF) ## [1] &quot;data.frame&quot; データフレームを作成する際、事前にベクトルを用意してから作成することも可能です。 myDF.ID &lt;- 1:4 myDF.Name &lt;- c(&quot;Yanai&quot;, &quot;Song&quot;, &quot;Shigemura&quot;, &quot;Tani&quot;) myDF.Math &lt;- c(50, 90, 100, 80) myDF.Stat &lt;- c(25, 5, 100, 85) myDF2 &lt;- data.frame(myDF.ID, myDF.Name, myDF.Math, myDF.Stat) myDF2 ## myDF.ID myDF.Name myDF.Math myDF.Stat ## 1 1 Yanai 50 25 ## 2 2 Song 90 5 ## 3 3 Shigemura 100 100 ## 4 4 Tani 80 85 この場合、列の名前はベクトル名そのままになります。もし、列名を指定したい場合は以下のように作成します。 myDF3 &lt;- data.frame( ID = myDF.ID, Name = myDF.Name, Math = myDF.Math, Stat = myDF.Stat ) myDF3 ## ID Name Math Stat ## 1 1 Yanai 50 25 ## 2 2 Song 90 5 ## 3 3 Shigemura 100 100 ## 4 4 Tani 80 85 以上をコードを考えてみると、データフレームは複数のベクトルを横方向にくっつけたものになります。注意すべき点としては各ベクトルの長さが一致している点です。myDFの場合、4つのベクトルで構成されていますが、全てのベクトルの長さは4です。むろん、長さが異なる場合もデータフレームは作成できます。この場合、長さが足りないベクトルは最も長さが長いベクトルに合わせて繰り返されます。例としてmyDF4を作ってみましょう。 myDF4 &lt;- data.frame( ID = 1:4, Name = c(&quot;Yanai&quot;, &quot;Song&quot;, &quot;Shigemura&quot;, &quot;Tani&quot;), Math = c(50, 90, 100, 80), Stat = c(25, 5, 100, 85), City = &quot;Kobe&quot;, Food = c(&quot;Ramen&quot;, &quot;Udon&quot;) ) myDF4 ## ID Name Math Stat City Food ## 1 1 Yanai 50 25 Kobe Ramen ## 2 2 Song 90 5 Kobe Udon ## 3 3 Shigemura 100 100 Kobe Ramen ## 4 4 Tani 80 85 Kobe Udon City列はすべて\"Kobe\"が入り、Food列は長さが足りない3, 4番目の要素に1, 2番目の要素が代入されます。実際はあまり使わない使い方ですが、ある列の要素が全て同じ場合、このような使い方をすることがあります。 8.4.2 データフレームの操作 データフレームの大きさ 行列と同じ dim(myDF4) ## [1] 4 6 nrow(myDF4) ## [1] 4 ncol(myDF4) ## [1] 6 要素の抽出 まず、データフレーム内要素の抽出についてですが、行列型と同じやり方で問題ありません。つまり、[行番号, 列番号]で要素の抽出が可能です。これに加え、データフレームには$を使った抽出方法があります。 まず、行列と同じやり方でmyDF4の2行目、6列目の要素を抽出してみましょう。 myDF4[2, 6] ## [1] &quot;Udon&quot; 行を丸ごと抽出したい場合は、列を指定しません。myDF4の3, 4行目を抽出してみましょう。 myDF4[3:4, ] # myDF4[c(3, 4), ]も同じ ## ID Name Math Stat City Food ## 3 3 Shigemura 100 100 Kobe Ramen ## 4 4 Tani 80 85 Kobe Udon 同じやり方で列を抽出すことも可能です。好きな食べ物 (Food)列を抽出してみましょう。 myDF4[, 6] ## [1] &quot;Ramen&quot; &quot;Udon&quot; &quot;Ramen&quot; &quot;Udon&quot; 列を抽出する場合は、列名を指定することも可能です。やり方は[, \"列名\"]による方法、$列名による方法があります。Name列を抽出してみましょう。 myDF4[, &quot;Name&quot;] ## [1] &quot;Yanai&quot; &quot;Song&quot; &quot;Shigemura&quot; &quot;Tani&quot; myDF4$Name ## [1] &quot;Yanai&quot; &quot;Song&quot; &quot;Shigemura&quot; &quot;Tani&quot; どれも同じ結果が返されます。後者の方が簡単ですが、一つの列しか抽出できない限界があります。それに比べ、前者はc()を使うことで複数の列を同時に抽出することも可能です。それぞれの場面に応じて使い分けていきましょう。 また、$で列を抽出した場合、抽出されたものはベクトル扱いになるため、[]を使った要素の抽出が可能です。例えばmyDF4のName列の2番目の要素を抽出してみましょう。 myDF4$Name[2] ## [1] &quot;Song&quot; あまり意識する必要はありませんが、抽出後のデータ構造について簡単に説明します。データフレームから一部の要素を抽出した結果物は必ずしもデータフレームにはなりません。 操作 返されるデータ型 1 1行を抽出する データフレーム 2 複数の行を抽出する データフレーム 3 1列を抽出する ベクトル 4 複数の列を抽出する データフレーム 注目するのは3番目の例ですが、これはRの最小単位がベクトルであり、データフレームもベクトルの集めだからです。データフレームは「縦」ベクトルを横に並べたものです。もし、行を抽出した場合、その要素は全て同じデータ型だとは限りません。実際、myDF4の3行目を抽出しても、中にはcharacter型とnumeric型と混在しています。しかし、一つの列のみを抽出した場合、全ての要素は必ず同じデータ型となるため、ベクトルとして扱うことが可能です。同様に、行列型の一列を抽出した場合も結果はベクトルとなります。ただし、行列は全ての要素がNAを除き、同じであるため、一行を抽出しても結果はベクトル型となります。 セルの修正 特定のセルの修正する方法は簡単です。先ほど、データフレームから一つのセルを取り出すにはデータフレーム名[行番号, 列番号]だけでした。そのセルを修正するにはベクトルと同様、データフレーム名[行番号, 列番号] &lt;- 新しい値のように入力します。 たとえば、重村さんが数学試験で不正が発覚し、0点になるとします。そのためには、myDF4の3行・3列目の要素を0に修正する必要がありますが、以下のようなコマンドで修正可能です。 myDF4[3, 3] &lt;- 0 myDF4 ## ID Name Math Stat City Food ## 1 1 Yanai 50 25 Kobe Ramen ## 2 2 Song 90 5 Kobe Udon ## 3 3 Shigemura 0 100 Kobe Ramen ## 4 4 Tani 80 85 Kobe Udon ちゃんと重村さんの数学点数が0点になりました。ざまあみろですね！ もう一つのやり方としては、一旦、列を取り出し、ベクトルにおける要素の置換操作を行う方法です。矢内大先生が神戸から離れ、高知県へ移住し、小物の宋は京都へ移住したとします。myDF4のCity列の1・2番目要素をc(\"Kochi\", \"Kyoto\")に修正する必要があります。そのためには以下のように入力します。 myDF4$City[c(1, 2)] &lt;- c(&quot;Kochi&quot;, &quot;Kyoto&quot;) myDF4 ## ID Name Math Stat City Food ## 1 1 Yanai 50 25 Kochi Ramen ## 2 2 Song 90 5 Kyoto Udon ## 3 3 Shigemura 0 100 Kobe Ramen ## 4 4 Tani 80 85 Kobe Udon 修正した要素が反映されました。 列の追加・修正 まずは、データフレームに列を追加する方法について紹介します。方法は データフレーム名$新しい列名 &lt;- ベクトル のように入力するだけです。たとえば、4人を対象に英語試験を行い、それぞれの点数が95点、50点、80点、5点だとします。この英語試験の成績をmyDF4のEnglish列として追加してみましょう。 myDF4$English &lt;- c(95, 50, 80, 5) むろん、以下のように予めベクトルを作成してから代入することも可能です。 English_Score &lt;- c(95, 50, 80, 5) myDF4$English &lt;- English_Score どれも同じ結果になりますが、結果を見てみましょう。 myDF4 ## ID Name Math Stat City Food English ## 1 1 Yanai 50 25 Kochi Ramen 95 ## 2 2 Song 90 5 Kyoto Udon 50 ## 3 3 Shigemura 0 100 Kobe Ramen 80 ## 4 4 Tani 80 85 Kobe Udon 5 「EnglishがStatの次じゃなくて気持ち悪い！」と思う方もいるかも知れませんが、列順番の変更については第10章で解説します。まずは、これで我慢しましょう。 次は、列の置換についてです。実はよく考えてみるとこれは列の追加と全く同じです。たとえば、英語試験において配点が5点の問題にミスが見つかり、全生徒の英語成績に5点を上乗せるとします。そのためにはベクトルmyDF4$Englishの全ての要素に5を足し、それをもう一回myDf4$Englishに代入すれば良いです。 myDF4$English &lt;- myDF4$English + 5 myDF4 ## ID Name Math Stat City Food English ## 1 1 Yanai 50 25 Kochi Ramen 100 ## 2 2 Song 90 5 Kyoto Udon 55 ## 3 3 Shigemura 0 100 Kobe Ramen 85 ## 4 4 Tani 80 85 Kobe Udon 10 これでEnglish列の修正ができました。 行の追加・修正はなるべくしない 行の追加はなるべくしない方が良いです。その理由について考えてみましょう。今は4人の生徒のデータがありますが、ここにもう一人の生徒のデータを追加するとします。そのためにはmyDF4の5行目に生徒のID、名前、数学・統計学の成績、居住地域、好きな食べ物、英語の成績を入れれば良いでしょう。新しい学生、吐合さんの数学・統計学・英語成績は50, 50, 50点、居住地域は芦屋、好きな食べ物は二郎だとします。早速追加してみましょう。 myDF4[5, ] &lt;- c(5, &quot;Hakiai&quot;, 50, 50, &quot;Ashiya&quot;, &quot;Jiro&quot;, 50) myDF4 ## ID Name Math Stat City Food English ## 1 1 Yanai 50 25 Kochi Ramen 100 ## 2 2 Song 90 5 Kyoto Udon 55 ## 3 3 Shigemura 0 100 Kobe Ramen 85 ## 4 4 Tani 80 85 Kobe Udon 10 ## 5 5 Hakiai 50 50 Ashiya Jiro 50 問題なく吐合さんのデータが追加されたように見えますが、実は問題があります。myDF4のStat列を取り出して見ましょう。 myDF4$Stat ## [1] &quot;25&quot; &quot;5&quot; &quot;100&quot; &quot;85&quot; &quot;50&quot; 異常に気づきましたか。それではこのベクトルのデータ型を確認してみましょう。 class(myDF4$Stat) ## [1] &quot;character&quot; 元々はnumeric型であるはずのStat列がcharacter型になりました。その理由は明白です。ベクトルの要素は全て同じデータ型だからです。そして、numericとcharacter型が混在している場合は、自動的にnumeric型になります。以下の2つのコマンドが同じであることは理解できるでしょう。 # Case 1 myDF4[5, ] &lt;- c(5, &quot;Hakiai&quot;, 50, 50, &quot;Ashiya&quot;, &quot;Jiro&quot;, 50) # Case 2 Hakiai_Data &lt;- c(5, &quot;Hakiai&quot;, 50, 50, &quot;Ashiya&quot;, &quot;Jiro&quot;, 50) myDF4[5, ] &lt;- Hakiai_Data ここのベクトルHakiai_Dataが強制的にcharacter型になるため、myDF4の5行目の要素は全てcharacter型になります。また、データフレームは縦ベクトルを横に並べたものであるなら、myDF4$Math列にcharacter型の要素が追加されることによって、列も全てcharacter型になってしまいます。したがって、データフレームにcharacter型とnumeric型が混在している状況において新しい行の追加は全ての要素をcharacter型に変えてしまうのです。むろん、データフレームの全要素がnumeric型であれば、このような問題は生じますが、numeric型のみで構成されたデータフレームはなかなかないでしょう。 5行目を消しても問題は解決しないので、結局は列のデータ型を強制的に変更する必要があります。 myDF4$ID &lt;- as.numeric(myDF4$ID) myDF4$Math &lt;- as.numeric(myDF4$Math) myDF4$Stat &lt;- as.numeric(myDF4$Stat) myDF4$English &lt;- as.numeric(myDF4$English) class(myDF4$Math) ## [1] &quot;numeric&quot; これでやっと元通りになりましたね。 どうしても行を追加したい場合は、以下のようなやり方もありますが、おすすめはできません。 myDF4[6, ] &lt;- rep(NA, 7) # myDF4の6行目を追加し、7つの欠損値を代入 myDF4$ID[6] &lt;- 6 # myDF4$IDの6番目の要素に6を代入 myDF4$Name[6] &lt;- &quot;Yukawa&quot; # myDF4$Nameの6番目の要素にYukawaを代入 myDF4$Math[6] &lt;- 80 # 以下、省略 myDF4$Stat[6] &lt;- 30 myDF4$City[6] &lt;- &quot;Hiroshima&quot; myDF4$Food[6] &lt;- &quot;Ramen&quot; myDF4$English[6] &lt;- 90 myDF4 ## ID Name Math Stat City Food English ## 1 1 Yanai 50 25 Kochi Ramen 100 ## 2 2 Song 90 5 Kyoto Udon 55 ## 3 3 Shigemura 0 100 Kobe Ramen 85 ## 4 4 Tani 80 85 Kobe Udon 10 ## 5 5 Hakiai 50 50 Ashiya Jiro 50 ## 6 6 Yukawa 80 30 Hiroshima Ramen 90 class(myDF4$English) ## [1] &quot;numeric&quot; 欠損値 (NA)はどのようなデータ型にも対応できる特徴を利用すれば、このような操作も可能ですが、かなり面倒です。そもそも実際の分析において任意の行を追加することは滅多にないはずです。 8.4.3 tibble型 data.frameに似ているデータ型としてtibbleがあります。これはR内蔵のデータ型ではありませんが、Rの必須パッケージとも言えるtidyverse内に含まれているデータ型であり、これからもどんどん普及していくでしょう。tibbleとdata.frameの違いを説明するために、同じデータをそれぞれのデータ型で読み込んでみましょう。 とりあえずread_csv()で読み込み、VoteDF1と名付けましょう。 VoteDF1 &lt;- read.csv(&quot;Data/Vote.csv&quot;) 続いてVoteDF1をas_tibble()関数を使ってtibble型にし、VoteDF2と名付けます。そして、それぞれのデータ構造を確認してみます。 VoteDF2 &lt;- as_tibble(VoteDF1) class(VoteDF1); class(VoteDF2) ## [1] &quot;data.frame&quot; ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; 全く同じデータですが、VoteDF2にはtblとtbl_dfというクラスが追加されていることが分かります。それではデータの中身を覗いてみましょう。まずは、data.frameがたから VoteDF1 ## ID Pref Zaisei Over65 Under30 LDP DPJ Komei Ishin JCP SDP ## 1 1 北海道 0.41903 29.09 24.70 32.82 30.62 13.41 3.43 11.44 1.68 ## 2 2 青森県 0.33190 30.14 23.92 40.44 24.61 12.76 3.82 8.92 3.41 ## 3 3 岩手県 0.34116 30.38 24.48 34.90 22.44 8.61 5.16 11.24 5.29 ## 4 4 宮城県 0.59597 25.75 27.29 36.68 25.40 13.42 3.97 9.99 3.62 ## 5 5 秋田県 0.29862 33.84 21.35 43.46 22.72 11.19 5.17 7.56 5.12 ## 6 6 山形県 0.34237 30.76 24.75 42.49 21.47 11.78 4.30 7.60 5.20 ## 7 7 福島県 0.50947 28.68 25.23 33.82 28.31 10.96 3.43 10.45 3.24 ## 8 8 茨城県 0.63309 26.76 26.60 40.64 18.95 15.05 6.67 10.07 2.88 ## 9 9 栃木県 0.62166 25.87 26.78 38.78 21.63 12.42 10.88 7.00 2.05 ## 10 10 群馬県 0.60277 27.60 26.59 42.06 19.31 13.85 5.61 10.00 2.44 ## 11 11 埼玉県 0.76548 24.82 27.66 32.30 20.40 16.00 7.23 13.94 1.91 ## 12 12 千葉県 0.77694 25.86 26.71 37.79 21.70 13.98 5.46 11.34 2.01 ## 13 13 東京都 1.00321 22.67 27.39 34.37 19.76 11.44 7.34 14.21 2.82 ## 14 14 神奈川県 0.91745 23.86 27.84 34.92 21.49 12.18 7.77 12.46 2.79 ## 15 15 新潟県 0.43519 29.86 25.23 43.66 25.25 8.27 4.39 8.00 3.76 ## 16 16 富山県 0.45307 30.54 24.88 44.16 24.22 9.81 5.06 5.79 5.02 ## 17 17 石川県 0.46812 27.87 27.25 48.09 18.54 11.00 6.36 7.07 2.36 ## 18 18 福井県 0.37820 28.63 26.70 45.29 17.52 10.91 13.09 5.66 2.09 ## 19 19 山梨県 0.37876 28.41 26.37 37.36 28.04 12.83 4.32 9.20 1.67 ## 20 20 長野県 0.47586 30.06 25.52 35.27 27.69 10.70 4.23 12.61 3.59 ## 21 21 岐阜県 0.52358 28.10 27.22 39.71 23.62 12.33 5.51 9.41 1.98 ## 22 22 静岡県 0.70999 27.79 26.28 37.47 24.13 12.68 7.99 9.59 2.22 ## 23 23 愛知県 0.92052 23.79 29.44 34.32 29.27 11.67 6.41 9.55 2.14 ## 24 24 三重県 0.57544 27.90 26.74 33.67 34.23 13.07 5.09 7.59 1.76 ## 25 25 滋賀県 0.53932 24.15 29.96 37.85 22.25 9.57 12.82 11.44 1.41 ## 26 26 京都府 0.56713 27.51 27.76 31.18 19.93 12.25 11.16 18.50 1.55 ## 27 27 大阪府 0.74980 26.15 27.55 22.12 9.30 16.39 34.86 11.37 1.25 ## 28 28 兵庫県 0.62062 27.09 26.94 31.71 15.84 15.37 19.50 10.30 2.01 ## 29 29 奈良県 0.41269 28.70 26.86 33.51 18.41 13.44 18.94 9.17 1.66 ## 30 30 和歌山県 0.31955 30.89 25.08 39.61 12.10 18.00 13.51 10.43 1.23 ## 31 31 鳥取県 0.25486 29.71 25.86 41.62 20.93 16.71 5.98 7.14 2.56 ## 32 32 島根県 0.24170 32.48 24.59 48.24 19.14 13.43 4.75 7.50 2.51 ## 33 33 岡山県 0.50096 28.66 27.44 37.87 19.91 17.18 10.67 7.87 1.60 ## 34 34 広島県 0.58581 27.53 27.46 39.93 18.53 15.20 9.69 8.52 2.35 ## 35 35 山口県 0.42560 32.07 24.91 46.75 17.27 16.50 5.31 7.39 1.78 ## 36 36 徳島県 0.32018 30.95 24.31 38.44 17.72 16.87 9.46 9.10 1.81 ## 37 37 香川県 0.46060 29.93 25.29 44.07 16.60 15.14 6.20 7.56 5.07 ## 38 38 愛媛県 0.41181 30.62 24.75 43.57 19.28 14.82 6.77 6.97 2.40 ## 39 39 高知県 0.24472 32.85 23.60 37.01 16.95 15.83 3.93 17.41 2.91 ## 40 40 福岡県 0.61836 25.90 28.21 36.52 19.08 17.15 7.03 10.78 3.33 ## 41 41 佐賀県 0.32938 27.68 27.97 43.53 21.10 15.48 4.85 5.67 4.16 ## 42 42 長崎県 0.31562 29.60 25.84 41.70 20.68 16.86 5.12 6.27 3.48 ## 43 43 熊本県 0.38688 28.78 27.18 46.54 19.29 15.27 4.53 6.32 2.60 ## 44 44 大分県 0.35828 30.45 25.65 39.44 18.37 13.26 4.42 6.85 13.05 ## 45 45 宮崎県 0.32034 29.49 26.26 40.11 14.50 17.11 5.74 7.27 6.81 ## 46 46 鹿児島県 0.32140 29.43 26.04 45.97 16.19 14.49 6.47 6.52 3.62 ## 47 47 沖縄県 0.31535 19.63 33.37 27.82 13.29 15.09 7.66 15.64 12.13 つづいて、tibble型 VoteDF2 ## # A tibble: 47 x 11 ## ID Pref Zaisei Over65 Under30 LDP DPJ Komei Ishin JCP SDP ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 北海道 0.419 29.1 24.7 32.8 30.6 13.4 3.43 11.4 1.68 ## 2 2 青森県 0.332 30.1 23.9 40.4 24.6 12.8 3.82 8.92 3.41 ## 3 3 岩手県 0.341 30.4 24.5 34.9 22.4 8.61 5.16 11.2 5.29 ## 4 4 宮城県 0.596 25.8 27.3 36.7 25.4 13.4 3.97 9.99 3.62 ## 5 5 秋田県 0.299 33.8 21.4 43.5 22.7 11.2 5.17 7.56 5.12 ## 6 6 山形県 0.342 30.8 24.8 42.5 21.5 11.8 4.3 7.6 5.2 ## 7 7 福島県 0.509 28.7 25.2 33.8 28.3 11.0 3.43 10.4 3.24 ## 8 8 茨城県 0.633 26.8 26.6 40.6 19.0 15.0 6.67 10.1 2.88 ## 9 9 栃木県 0.622 25.9 26.8 38.8 21.6 12.4 10.9 7 2.05 ## 10 10 群馬県 0.603 27.6 26.6 42.1 19.3 13.8 5.61 10 2.44 ## # … with 37 more rows 同じデータですが、表示画面がやや異なります。data.frameは全ての列と行が表示されましたが、tibbleの場合、「画面に収まる」程度しか表示されません。表示されなかった行や列に関しては最後に表示されています。たとえば、VoteDF2の場合、下段にこのように書かれていますね (画面の大きさによって変わります)。 ## # … with 37 more rows, and 1 more variable: SDP &lt;dbl&gt; これは表示されなかった行が37行あり、SDPという変数も表示されていないということです。他の違いとしては、tibbleの場合、最初にデータのサイズ (47行11列)が、各変数名の下にデータ型 (&lt;int&gt;、&lt;chr&gt;、&lt;dbl&gt;など)が表示されるという点です。 本書はtibbleとdata.frameを区別して解説はしませんが、一部の章・節においてはtibbleを念頭において解説をします。tibble型の作り方は先ほどのようにas_tibble()使う方法もありますが、readr::read_csv()を使う方法もあります37。read_csv()を使うと各列がどのようなデータ型として読み込まれたかも表示されるので便利です。readrパッケージはtidyverseに含まれているため、普段では以下のような使い方で十分です。 VoteDF3 &lt;- read_csv(&quot;Data/Vote.csv&quot;) ## Parsed with column specification: ## cols( ## ID = col_double(), ## Pref = col_character(), ## Zaisei = col_double(), ## Over65 = col_double(), ## Under30 = col_double(), ## LDP = col_double(), ## DPJ = col_double(), ## Komei = col_double(), ## Ishin = col_double(), ## JCP = col_double(), ## SDP = col_double() ## ) class(VoteDF3) # VoteDF3の構造 ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; tibbleとdata.frameの最も大きな違いは、data.frameの一つのセルには長さ1のベクトルしか入らない一方、tibbleは何でも入るという点です。つまり、tibbleなら一つのセルに数字や文字列だけでなく、長さ2以上のベクトル、後述するリスト型、行列、さらにはtibbleも入れることが出来ます。これについては本書の中盤以降に解説します。 本書で「データフレーム」と書いた場合、それはtibbleでも適用可能です。ただし、tibbleと明示した場合、データフレームでは適用不可能です。 8.5 リスト (list) リスト型は「様々なデータ構造を集めたもの」です。これは複数のデータフレームが格納されたオブジェクト、複数のベクトルが格納されたオブジェクト、行列とデータフレームが混在したオブジェクトなどを意味します。また、リスト型データはリスト型データを含むことも可能であり、非常に柔軟なデータ構造です。 8.5.1 リスト型データの作成 ここではまず、2つのデータフレームを含むリストを作成してみます。それぞれのデータフレームはFIFA国別サッカーランキングであり38、本書のサンプルデータのFIFA_Women.csvとFIFA_Men.csvです。まずは、2つのデータを読み込み、Soccer_WとSoccer_Mという名のオブジェクトに格納しましょう。また、ここでは単に例を見せるだけなので、全データを利用するのではなく、最初の10行のみを利用します。 Soccer_W &lt;- read.csv(&quot;Data/FIFA_Women.csv&quot;) Soccer_M &lt;- read.csv(&quot;Data/FIFA_Men.csv&quot;) Soccer_W &lt;- Soccer_W[1:10, ] Soccer_M &lt;- Soccer_M[1:10, ] リストの作成にはlist()関数に入れたいオブジェクト名を指定するだけです。それではList1という名前でSoccer_WとSoccer_Mデータフレームを入れてみましょう。格納後はList1のデータ構造をclass()で確認します List1 &lt;- list(Soccer_W, Soccer_M) class(List1) ## [1] &quot;list&quot; List1 ## [[1]] ## ID Team Rank Points Prev_Points Confederation ## 1 1 Albania 75 1325 1316 UEFA ## 2 2 Algeria 85 1271 1271 CAF ## 3 3 American Samoa 133 1030 1030 OFC ## 4 4 Andorra 155 749 749 UEFA ## 5 5 Angola 121 1117 1117 CAF ## 6 6 Antigua and Barbuda 153 787 787 CONCACAF ## 7 7 Argentina 32 1659 1659 CONMEBOL ## 8 8 Armenia 126 1103 1104 UEFA ## 9 9 Aruba 157 724 724 CONCACAF ## 10 10 Australia 7 1963 1963 AFC ## ## [[2]] ## ID Team Rank Points Prev_Points Confederation ## 1 1 Afghanistan 149 1052 1052 AFC ## 2 2 Albania 66 1356 1356 UEFA ## 3 3 Algeria 35 1482 1482 CAF ## 4 4 American Samoa 192 900 900 OFC ## 5 5 Andorra 135 1082 1082 UEFA ## 6 6 Angola 124 1136 1136 CAF ## 7 7 Anguilla 210 821 821 CONCACAF ## 8 8 Antigua and Barbuda 126 1127 1127 CONCACAF ## 9 9 Argentina 9 1623 1623 CONMEBOL ## 10 10 Armenia 102 1213 1213 UEFA 一つのオブジェクトに2つのデータフレームが入っていますね。これは2つのデータフレームで構成された長さ2のリストです。ただし、どちらが女性ランキングで、どちらが男子ランキングか区別が難しいです。この場合、各データフレームに名前を付けることも可能です。 List2 &lt;- list(Women = Soccer_W, Men = Soccer_M) List2 ## $Women ## ID Team Rank Points Prev_Points Confederation ## 1 1 Albania 75 1325 1316 UEFA ## 2 2 Algeria 85 1271 1271 CAF ## 3 3 American Samoa 133 1030 1030 OFC ## 4 4 Andorra 155 749 749 UEFA ## 5 5 Angola 121 1117 1117 CAF ## 6 6 Antigua and Barbuda 153 787 787 CONCACAF ## 7 7 Argentina 32 1659 1659 CONMEBOL ## 8 8 Armenia 126 1103 1104 UEFA ## 9 9 Aruba 157 724 724 CONCACAF ## 10 10 Australia 7 1963 1963 AFC ## ## $Men ## ID Team Rank Points Prev_Points Confederation ## 1 1 Afghanistan 149 1052 1052 AFC ## 2 2 Albania 66 1356 1356 UEFA ## 3 3 Algeria 35 1482 1482 CAF ## 4 4 American Samoa 192 900 900 OFC ## 5 5 Andorra 135 1082 1082 UEFA ## 6 6 Angola 124 1136 1136 CAF ## 7 7 Anguilla 210 821 821 CONCACAF ## 8 8 Antigua and Barbuda 126 1127 1127 CONCACAF ## 9 9 Argentina 9 1623 1623 CONMEBOL ## 10 10 Armenia 102 1213 1213 UEFA これでどれが女性ランキングか、男性ランキングかが区別しやすくなりました。ここでは2つのデータフレームを入れましたが、様々なデータ構造が混在したリストも可能です。様々なデータ構造が混在したリストを自分で作成する場面はあまりありません。自分で作成した独自クラスを利用するパッケージを開発する際はよく使いますが、ここでは省略します。ただし、様々なデータ構造が含まれたリスト型を見ることはよくあります。たとえば、lm()関数で回帰分析を行った際、その結果はリスト型であり、中にはベクトル、データフレーム、リストなどが混在しています。これについては今後詳細に解説していきたいと思います。 8.5.2 リスト型データの操作 リスト型の中身は何でもあり得るので、なんらかの操作方法があるわけではありません。リスト型の操作というのはリスト内の要素をどのように抽出するかであり、各要素 (データフレーム、行列、ベクトルなど)の操作はこれまで説明してきた方法と同じです。したがって、ここではリストを構成する要素を抽出する方法についてのみ解説します。 要素の番号を利用する方法 List1は各要素に名前が付いていないため、番号で抽出します。たとえば、あるリストのi番目の要素を抽出するにはリスト名[[i]]で抽出します。[]ではなく、[[]]であることに注意してください。それではList1の1番目の要素を抽出してみましょう。 List1[[1]] ## ID Team Rank Points Prev_Points Confederation ## 1 1 Albania 75 1325 1316 UEFA ## 2 2 Algeria 85 1271 1271 CAF ## 3 3 American Samoa 133 1030 1030 OFC ## 4 4 Andorra 155 749 749 UEFA ## 5 5 Angola 121 1117 1117 CAF ## 6 6 Antigua and Barbuda 153 787 787 CONCACAF ## 7 7 Argentina 32 1659 1659 CONMEBOL ## 8 8 Armenia 126 1103 1104 UEFA ## 9 9 Aruba 157 724 724 CONCACAF ## 10 10 Australia 7 1963 1963 AFC このようにList1内の1番目のデータが抽出されました。こちらのデータ構造は何でしょうか。 class(List1[[1]]) ## [1] &quot;data.frame&quot; 既に予想したかと思いますが、データフレームとして抽出されました。ここから更に、3行目のデータを抽出するには、[[]]の後に[3, ]を付けます。 List1[[1]][3, ] ## ID Team Rank Points Prev_Points Confederation ## 3 3 American Samoa 133 1030 1030 OFC 先ほどリストの要素の抽出には「[]でなく、[[]]です」と申しましたが、実は[]も使用可能です。やってみましょう。 List1[1] ## [[1]] ## ID Team Rank Points Prev_Points Confederation ## 1 1 Albania 75 1325 1316 UEFA ## 2 2 Algeria 85 1271 1271 CAF ## 3 3 American Samoa 133 1030 1030 OFC ## 4 4 Andorra 155 749 749 UEFA ## 5 5 Angola 121 1117 1117 CAF ## 6 6 Antigua and Barbuda 153 787 787 CONCACAF ## 7 7 Argentina 32 1659 1659 CONMEBOL ## 8 8 Armenia 126 1103 1104 UEFA ## 9 9 Aruba 157 724 724 CONCACAF ## 10 10 Australia 7 1963 1963 AFC [[]]を使った抽出とあまり変わらないですね。しかし、重要な違いが一つあります。それはデータ構造です。 class(List1[1]) ## [1] &quot;list&quot; []で抽出したリストの要素のデータ構造もまたリスト型です。この場合、先ほどのように[x, ]を使って、x行目のデータを抽出することはできません。なぜなら、[行, 列]による要素の抽出はデータフレームのためのものであって、リスト型のためのものではないからです。 List1[1][3, ] ## Error in List1[1][3, ]: 次元数が正しくありません このようにエラーが表示されます。 要素の名前を利用する方法 List2のようにリストの要素に名前を付けた場合、これまでの方法に加え[[\"要素名\"]]と$要素名を使った操作が可能です39。List2から男子ランキング (Men)を抽出してみましょう。 List2[[&quot;Men&quot;]] ## ID Team Rank Points Prev_Points Confederation ## 1 1 Afghanistan 149 1052 1052 AFC ## 2 2 Albania 66 1356 1356 UEFA ## 3 3 Algeria 35 1482 1482 CAF ## 4 4 American Samoa 192 900 900 OFC ## 5 5 Andorra 135 1082 1082 UEFA ## 6 6 Angola 124 1136 1136 CAF ## 7 7 Anguilla 210 821 821 CONCACAF ## 8 8 Antigua and Barbuda 126 1127 1127 CONCACAF ## 9 9 Argentina 9 1623 1623 CONMEBOL ## 10 10 Armenia 102 1213 1213 UEFA List2$Men ## ID Team Rank Points Prev_Points Confederation ## 1 1 Afghanistan 149 1052 1052 AFC ## 2 2 Albania 66 1356 1356 UEFA ## 3 3 Algeria 35 1482 1482 CAF ## 4 4 American Samoa 192 900 900 OFC ## 5 5 Andorra 135 1082 1082 UEFA ## 6 6 Angola 124 1136 1136 CAF ## 7 7 Anguilla 210 821 821 CONCACAF ## 8 8 Antigua and Barbuda 126 1127 1127 CONCACAF ## 9 9 Argentina 9 1623 1623 CONMEBOL ## 10 10 Armenia 102 1213 1213 UEFA どれも結果は同じです。また、それぞれのデータ構造もデータフレームです。 class(List2[[&quot;Men&quot;]]) ## [1] &quot;data.frame&quot; class(List2$Men) ## [1] &quot;data.frame&quot; したがって、[行番号, 列番号]のようにデータフレームの操作が可能です。Men要素から10行目のデータを抽出してみましょう。 List2[[&quot;Men&quot;]][10, ] ## ID Team Rank Points Prev_Points Confederation ## 10 10 Armenia 102 1213 1213 UEFA List2$Men[10, ] ## ID Team Rank Points Prev_Points Confederation ## 10 10 Armenia 102 1213 1213 UEFA もちろん、名前を付けた場合であっても、要素の番号を利用した操作も可能です。自分でリスト型を作成する際には各要素に名前を付けた方が分かりやすくて良いでしょう。 8.6 配列 (array) 配列は行列の拡張版であり、行列は配列の特殊な形です。これまでのRでは行列と配列は区別されてきましたが、R 4.0.0以降、行列は配列の属するデータ構造となりました。 配列型は簡単にいうと、同じサイズの行列を数枚重ねたものです。図8.1は配列型のイメージを表したものです。 図 8.1: 配列型データのイメージ したがって、配列型は行と列以外にも、層の要素も持つことになります。複数の行列で構成されている点では、リスト型と類似していますが、配列型は同じサイズの行列のみで構成されている点が特徴です。 配列型は普段、扱う機会があまりありませんが、マルコフ連鎖モンテカルロ法 (MCMC)でベイジアン推定を行った後の事後分布データは配列型で格納される場合があります。 8.6.1 配列型データの作成 各行列は3行4列とし、4層構造とします。まずは、同じサイズの行列を作成し、それぞれMat1、Mat2、Mat3、Mat4と名付けます。 Mat1 &lt;- matrix(sample(1:12, 12, replace = TRUE), byrow = TRUE, nrow = 3) Mat2 &lt;- matrix(sample(1:12, 12, replace = TRUE), byrow = TRUE, nrow = 3) Mat3 &lt;- matrix(sample(1:12, 12, replace = TRUE), byrow = TRUE, nrow = 3) Mat4 &lt;- matrix(sample(1:12, 12, replace = TRUE), byrow = TRUE, nrow = 3) sample()関数は初めてですね。これは与えられたベクトルの要素から無作為に要素を抽出する関数です。sample(1:12, n)ならc(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,1 2)から無作為にn個の要素を抽出するという意味です。replace = TRUEを指定すると、反復抽出、つまり、一回抽出された要素であっても抽出される可能性があることを意味します。デフォルトはFALSEですが、この場合、一旦抽出された要素は二度と抽出されません。それではそれぞれの行列の中身を見てみましょう。 Mat1 ## [,1] [,2] [,3] [,4] ## [1,] 7 8 12 9 ## [2,] 2 4 12 11 ## [3,] 8 6 7 3 Mat2 ## [,1] [,2] [,3] [,4] ## [1,] 6 2 10 11 ## [2,] 11 10 9 12 ## [3,] 4 11 8 11 Mat3 ## [,1] [,2] [,3] [,4] ## [1,] 6 2 10 5 ## [2,] 11 7 6 7 ## [3,] 10 1 3 4 Mat4 ## [,1] [,2] [,3] [,4] ## [1,] 8 10 9 9 ## [2,] 10 5 6 2 ## [3,] 2 6 3 9 配列型データを作成するにはarray()関数を使います。引数としては行列名をc()で繋ぎ40、dim =でarrayの大きさを指定するだけです。配列を作成した後はそのデータ構造も確認してみましょう。 Array1 &lt;- array(c(Mat1, Mat2, Mat3, Mat4), dim = c(3, 4, 4)) class(Array1) ## [1] &quot;array&quot; dim = c(m, n, z)の部分ですが、これは「m行n列の行列がz枚重ねる」という意味です。今回は3行4列の行列を4枚重ねるのでdim = c(3, 4, 4)です。それではArray1の中身を見てみます。 Array1 ## , , 1 ## ## [,1] [,2] [,3] [,4] ## [1,] 7 8 12 9 ## [2,] 2 4 12 11 ## [3,] 8 6 7 3 ## ## , , 2 ## ## [,1] [,2] [,3] [,4] ## [1,] 6 2 10 11 ## [2,] 11 10 9 12 ## [3,] 4 11 8 11 ## ## , , 3 ## ## [,1] [,2] [,3] [,4] ## [1,] 6 2 10 5 ## [2,] 11 7 6 7 ## [3,] 10 1 3 4 ## ## , , 4 ## ## [,1] [,2] [,3] [,4] ## [1,] 8 10 9 9 ## [2,] 10 5 6 2 ## [3,] 2 6 3 9 このように一つのオブジェクト内に複数の行列が格納されたオブジェクトが生成されます。 8.6.2 配列型データの操作 配列型データの操作は行列型に似ていますが、層というもう一つの次元があるため、行列名[行番号, 列番号]ではなく、配列名[行番号, 列番号, 層番号]を使います。たとえば、Array1の3番目の行列を抽出したい場合、Array1[, , 3]と入力します。 Array1[, , 3] ## [,1] [,2] [,3] [,4] ## [1,] 6 2 10 5 ## [2,] 11 7 6 7 ## [3,] 10 1 3 4 また、2番目の行列の3行目・1列目の要素を抽出するならArray1[3, 1, 2]と入力します。 Array1[3, 1, 2] ## [1] 4 配列型における操作の特徴の一つは全ての行列が同じ大きさを持つため、層を貫通した操作ができるという点です。たとえば、全ての層の2行目を抽出するなら、層番号を指定せず、行番号のみで抽出します。 Array1[2, , ] ## [,1] [,2] [,3] [,4] ## [1,] 2 11 11 10 ## [2,] 4 10 7 5 ## [3,] 12 9 6 6 ## [4,] 11 12 7 2 ただ、返された結果は配列型でなく行列型であることに注意しましょう。たとえば、1番目の行列の2行目の要素は2, 4, 12, 11ですが、これは先ほど抽出された行列の1列目に該当します。また、2番目の行列の2行目の要素は11, 10, 9, 12であり、これは先ほどの抽出された行列の2列目となります。全層において特定の一列を抽出しても同じです。これは各層において抽出されたデータが行列でなく、ベクトルだからです。 一方、複数の行または列を抽出した場合、結果は配列型です。Array1の各層から1・2行目と1・2列目の要素、つまり大きさが2 \\(\\times\\) 2の行列を抽出してみましょう。 Array1[1:2, 1:2, ] ## , , 1 ## ## [,1] [,2] ## [1,] 7 8 ## [2,] 2 4 ## ## , , 2 ## ## [,1] [,2] ## [1,] 6 2 ## [2,] 11 10 ## ## , , 3 ## ## [,1] [,2] ## [1,] 6 2 ## [2,] 11 7 ## ## , , 4 ## ## [,1] [,2] ## [1,] 8 10 ## [2,] 10 5 このように各層において抽出されたデータが行列だからです。自分の操作から得られた結果がどのようなデータ型・データ構造かを予め知っておくことで分析の効率が上がるでしょう。 行列に名前を付けたい 今回は各行列に1, 2, 3, 4という番号のみ割り当てましたが、実は行列に名前を付けることも可能です。そのためには配列データ作成時、dimnames =引数を指定する必要があります。 Array2 &lt;- array(c(Mat1, Mat2, Mat3, Mat4), dim = c(3, 4, 4), dimnames = list(NULL, NULL, c(&quot;M1&quot;, &quot;M2&quot;, &quot;M3&quot;, &quot;M4&quot;)) ) dimnames =引数は必ず長さ3のリスト型である必要があります。1番目と2番目の要素は行名と列名ですが、行列において一般的に使われないため、ここではNULLにし、3番目の要素、つまり各層の名前だけを指定します。ここではそれぞれの層をM1、M2、M3、M4と名付けました。ここでM4のみを抽出する場合は、以下のように操作します。 Array2[, , &quot;M4&quot;] ## [,1] [,2] [,3] [,4] ## [1,] 8 10 9 9 ## [2,] 10 5 6 2 ## [3,] 2 6 3 9 むろん、これまでと同様、番号で抽出することも可能です。 Array2[, , 4] ## [,1] [,2] [,3] [,4] ## [1,] 8 10 9 9 ## [2,] 10 5 6 2 ## [3,] 2 6 3 9 8.7 練習問題 リストと配列は要素の抽出が主な操作となるため、練習問題は掲載しておりません。 8.7.1 ベクトル 問1 1から10までの公差1の等差数列 (1, 2, 3, …, 10)を作成し、myVec1と名付けよ。 問2 myVec1の長さを求めよ。 問3 myVec1から偶数のみを抽出せよ 問4 myVec1をmyVec2という名でコピーし、myVec2の偶数を全て0に置換せよ。 問5 myVec1の全要素から1を引し、myVec3と名付けよ。 問6 myVec1の奇数番目の要素には1を、偶数番目の要素には2を足し、myVec4と名付けよ。 問7 myVec4からmyVec1を引け。 8.7.2 行列 問1 以下のような2つの行列を作成し、それぞれmyMat1、myMat2と名付けよ。 \\[ \\text{myMat1} = \\left[ \\begin{matrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\end{matrix} \\right], \\text{myMat2} = \\left[ \\begin{matrix} 1 &amp; 4 &amp; 7 \\\\ 2 &amp; 5 &amp; 8 \\\\ 3 &amp; 6 &amp; 9 \\end{matrix} \\right] \\] 問2 myMat1とmyMat2の掛け算を行い、myMat3と名付けよ。掛け算はアダマール積でなく、一般的な行列間の積を求めること。 問3 以下のような連立方程式を解くケースを考える。 \\[\\begin{align} 3x - y + 2z &amp; = 12, \\\\ x + 2y + 3z &amp; = 11, \\\\ 2x - y - z &amp; = 2. \\end{align}\\] 以下のような2つの行列を作成し、それぞれmyMat4、myMat5と名付けよ。 \\[ \\text{myMat4} = \\left[ \\begin{matrix} 3 &amp; -1 &amp; 2 \\\\ 1 &amp; 2 &amp; 3 \\\\ 2 &amp; -1 &amp; -1 \\end{matrix} \\right], \\text{myMat5} = \\left[ \\begin{matrix} 12 \\\\ 11 \\\\ 2 \\end{matrix} \\right] \\] myMat4の逆行列を求めよ。 myMat4の逆行列とmyMat5の積を求め、myMat6と名付けよ。 これが連立方程式の解である。 myMat4とmyMat6の積を求めよ。 8.7.3 データフレーム 問1 以下のようなデータフレームを作成し、myDF1と名付けよ41。 ID Name Rank Socre 1 Japan 28 1500 2 Iran 33 1489 3 South Korea 40 1464 4 Australia 42 1457 5 Qatar 55 1396 6 Saudi Arabia 67 1351 7 Iraq 70 1344 8 UAE 71 1334 9 China 76 1323 10 Syria 79 1314 問2 myDF1からName列を抽出せよ。 問3 myDF1のName列から3番目の要素を抽出せよ。 問4 myDF1の3行目を抽出せよ。 問5 FIFA_Women.csvをtibble型として読み込み、myTbl1と名付けよ42。 問6 myTbl1のRank列を抽出し、それぞれの要素が20より小さいかを判定せよ。 問7 myTbl1のRankが20より小さい国名を抽出せよ。 問8 myTbl1からランキングが20より上位の行を抽出せよ。 他にも要素ごとの積 (element-wise product)、シューア積 (Schur product)と呼ばれたりします。↩︎ 行列式が0でない場合において一次方程式には一組の解があります。↩︎ なぜなら2行目が1行目の0.5倍になっているからです。↩︎ NAも可能です。↩︎ tibble型を直接作成するにはtibble()関数を使いますが、data.frame()と同じ使い方で問題ありません。他にもtribble()関数を使った方法もありますが、詳細は?tribbleで確認してください。↩︎ 厳密には国別ではありません。イギリスの場合、イングランド、スコットランド、北アイルランド、ウェールズがそれぞれ独立したチームとしてFIFAに加盟しています。↩︎ [\"要素名\"]で抽出することも可能ですが、この場合、返される結果はリスト型になります。↩︎ 元々はベクトルを入力しますが、行列をc()で繋ぐと自動的にベクトルに変換されます。↩︎ 2020年4月9日現在のFIFA男子サッカーランキングである。データはAFC (アジアサッカー連盟)所属の上位10カ国である。データ源は(https://www.fifa.com/fifa-world-ranking/ranking-table/men/rank/id12882/)である (アクセス日: 2020年4月11日)。↩︎ 2020年3月27日現在のFIFA女子サッカーランキングである。データ源は(www.fifa.com/fifa-world-ranking/ranking-table/women/)である (アクセス日: 2020年4月11日)。それぞれの変数はID: 国名のID (アルファベット順)、Team: チーム名、Rank: FIFAランキング、Points: 2020年3月27日のポイント、Prev_Points: 2019年12月13日のポイント、Confederation: 所属しているサッカー連盟である。↩︎ "],
["programming.html", "9. Rプログラミングの基礎 9.1 R言語の基礎概念 9.2 スクリプトの書き方 9.3 反復 9.4 条件分岐 9.5 関数の作成 9.6 練習問題", " 9. Rプログラミングの基礎 目次 第9.1章: R言語の基礎概念 第9.2章: スクリプトの書き方 第9.3章: 反復 第9.4章: 条件分岐 第9.5章: 関数の作成 第9.6章: 練習問題 ここでは統計ソフトウェアではなく、プログラミング言語としてのRについて解説します。プログラミングとは難しそうなイメージがありますが、実は難しいです (?!?!)。ただし、プログラミングにおける重要概念は「代入」、「条件分岐」、「反復」この3つだけです43。実はこの3つだけでほとんどのプログラムは作れます。しかし、この単純さがプログラミングの難しさでもあります。 たとえば、ある数字列を小さいものから大きい順へ並び替えることを考えてみましょう。c(6, 3, 7, 2, 5, 1, 8, 4)の場合、人間ならあまり苦労することなく、c(1, 2, 3, 4, 5, 6, 7, 8)に並び替えるでしょう。しかし、「代入」、「条件分岐」、「反復」のみでこれを具現化できるでしょうか44。もちろんですが、できます。たしかに、Rにはこのためのsort()関数やorder()関数などが用意されていますし、これを使えば良いのではないかと思うでしょう。しかし、これも「代入」、「条件分岐」、「反復」を組み合わせてR開発チームが予め作っておいた関数です。 「代入」、「条件分岐」、「反復」といった3つの概念さえ理解すれば何でも出来るという意味でプログラミングは簡単です。しかし、この3つだけで解決しないといけないという点でプログラミングは難しいです。ただし、ほとんどのプログラミング言語は既に作られた関数 (bulit-in function)が多く用意されており、それを使うのが賢明です。それでも条件分岐や反復について勉強する必要があるのは、我々一般ユーザーにとってもこれが必要な場面が多いからです。たとえば、同じ分析をデータだけ変えながら複数回走らせるには反復が有効です。これを使えばコードを数十分の一に減らすことも可能です。また、学歴が大卒以上なら「高学歴」、未満なら「その他」にデータを再分類したい場合は条件分岐が非常に便利です。これがないと、一々自分がデータを眺めてExcelなどで入力しないといけませんが、パソコンを使うと秒レベルで終わります。 9.1 R言語の基礎概念 9.1.1 オブジェクト これまで「オブジェクト」や「関数」、「引数」などという概念を何の断りもなく使ってきましたが、ここではもうちょっと詳細に定義したいと思います。これらはプログラミングをやっていく上である程度は意識すべき点でもあります。 オブジェクト (object)とはメモリに割り当てられた何かです。それは長さ1のベクトルを含むベクトル、行列、データフレーム、リストだけでなく、後ほど紹介する関数もオブジェクトに含まれます。一般的にオブジェクトとは何かの名前が付いています。たとえば、1から5までの公差1の等比数列なら、 myVec1 &lt;- c(1, 2, 3, 4, 5) # myVec1 &lt;- 1:5も同じ のようにmyVec1という名前でオブジェクトに割り当てます。一旦、名前を付けてオブジェクトとしてメモリに割り当てると、今後myVec1と入力するだけで中身の内容を読み込むことができます。それでは以下のように、myVec1の要素を2倍にする操作を考えてみましょう。 myVec1 * 2 ## [1] 2 4 6 8 10 ここでmyVec1はオブジェクトです。それでは2はどうでしょう。メモリに割り当てられていないし、これはオブジェクトではないでしょうか。実は、この数字2もオブジェクトです。計算する瞬間のみにおいてメモリに割り当てられ、計算が終わったらメモリから消されたと考えた方が簡単でしょう。R内の全てのものはオブジェクトです (“Everything that exists in R is an object”)。実は先ほどの*のような演算子すらもオブジェクトです。 9.1.2 クラス クラス (class)とはオブジェクトを特徴づけるものです。既にこれまで何回もclass()関数を作ってデータ型やデータ構造を確認してきましたが、このclass()関数はオブジェクトのクラスを確認する関数です。先ほど、myVec1も*も2もオブジェクトであると説明しましたが、これがオブジェクトということは何らかのクラスを持っていることになります。また、class()関数そのものもオブジェクトであるため、何らかのクラスを持っています。 class(myVec1) ## [1] &quot;numeric&quot; class(`*`) ## [1] &quot;function&quot; class(2) ## [1] &quot;numeric&quot; class(class) ## [1] &quot;function&quot; 統計言語としてのRでクラスを意識することは多くありません。しかし、Rでパッケージを開発したり、複雑な関数を自作する場合、オブジェクト指向プログラミング (Object-oriented Programming; OOP)の考え方が重要になりますが、その際はオブジェクトのクラスを厳密に定義する必要があります45。 ただし、自分でパッケージを開発しなくても、クラスの概念を知っておくことは便利です。なぜなら、後で説明する関数には引数というものがあります。この引数は特定のクラスのデータしか指定できません。関数の使い方がわからない時には?関数名でヘルプを出しますが、ここには各引数に使えるクラスが書かれています。Rコンソール上で?meanを入力すると、図9.1のようなmean()関数のヘルプが表示されます。 図 9.1: mean()関数のヘルプ画面 mean()関数に必要な引数はx、trim、na.rmです。たとえば、引数xはnumeric、logicalベクトルクラスが使えることが分かります。numeric、logical型ベクトル以外にも使えるクラス (dateやdate-timeなど)も教えてくれます。また、回帰分析の関数であるlm()の場合、data引数はdata.frameクラスまたはtibbleクラスを指定します46。クラスはそこまで意識しなくてもいいですが、(1) 全てのオブジェクトにはクラスが付与されており、(2) 関数 (の引数)ごとに引数として使えるクラスが異なることは頭に入れておきましょう。 9.1.3 関数と引数 関数 (function)は入力されたデータを、関数内部で決められた手順に沿って処理し、その結果を返すものです。関数は関数名(データ)のように使いますが、class(myVec1)はmyVec1というデータのクラスを返す関数です。また、sum(myVec1)はmyVec1の要素の総和を計算し、返す関数です。関数は自分で作成することも可能です。複雑な行動を繰り返す場合、その行動を関数内部で記述することで、一行でその行動を再現することが可能になります。この関数を使う際に必要なものが引数 (argument)というものです。sum()関数はこれだけだと何もできません。何らかのデータが与えられないと結果は返せません。たとえば、sum(myVec1)のようにです。ここでmyVec1がsum()関数の引数です。また、引数は複数持つことができます。たとえば、欠損値を含む以下のmyVec2を考えてみましょう。 myVec2 &lt;- c(1, 2, 3, NA, 5) これをsum()関数で総和を求めると、結果は欠損値となります。 sum(myVec2) ## [1] NA これはsum()の基本仕様が「欠損値が含まれているなら結果は欠損値にする」ことになっているからです。そこでsum()はもう一つの引数があり、それがna.rm引数です。na.rm = TRUEを指定すると、欠損値を除外した上で総和を返します。 sum(myVec2, na.rm = TRUE) ## [1] 11 引数を指定する場合はmyVec2のように名前を付けないケースもありますが、ほとんどの場合、na.rm = ...のように、どのような引数かを明示する必要があります。関数によっては数十個の引数を必要する関数もあります。それらの多くはデフォルト値を持っています。たとえば、sum()関数のna.rm引数のデフォルト値はFALSEです。しかし、自分で引数を指定したい場合、その引数がどの引数かを明確にするために、引数名は書いた方が望ましいです。むろん、引数が1つのみの関数なら、省略しても構いませんし、そもそも引数名が付いていない場合もあります。sum()関数の最初の引数はnumericまたはcomplex型のベクトルですが、これらの引数名はそもそもありません。 ある関数がどのような引数を要求しているか、そのデフォルト値は何か、引数として何か決められたデータ型/データ構造があるかを調べるためには?関数名と入力します。ここでは()がないことに注意してください。多くの関数の場合、非常に充実なヘルプが付いているため、関数の具体的な使い方を調べるには?関数名が有用です。 9.2 スクリプトの書き方 Rのコードの書き方には正解がありません。文法さえ合っていれば、何の問題もありません。しかし、コードを「書く」仕事以外にも「修正する」仕事も非常に重要です。そのためにはコードの書き手である人間に優しい書き方をした方が良いでしょう。書き方に正解はありませんが、「このように書いたら読みやすい」、「多くの人が採用している書き方」というのはあります。ここではこれについて簡単に説明します。 9.2.1 オブジェクト名 ベクトルやデータフレームなどの変数や自作の関数など、全てのオブジェクトには何らかの名前が付きます。むろん、ラムダ式など、名前のない無名関数などもありますが、多くの場合は名前を持ちます。 名前を付ける決まったルールはありませんが、大事な原則があります。 オブジェクト名は英数字と限られた記号のみにする。数字で始まる変数名は避ける。 むろん、ローマ字以外にも日本語やハングルの変数名も可能ですが、推奨されておりません。ローマ字以外は文字化けの可能性もありますし、コードを書く際、列がずれる原因ともなります。 Variable1 &lt;- c(2, 3, 5, 7, 11) # 推奨 変数1 &lt;- c(2, 3, 5, 7, 11) # 非推奨 변수1 &lt;- c(2, 3, 5, 7, 11) # 非推奨 Variable1 ## [1] 2 3 5 7 11 変数1 ## [1] 2 3 5 7 11 변수1 ## [1] 2 3 5 7 11 ただし、数字で始まるオブジェクト名は作成できません。 100A &lt;- &quot;R&quot; ## Error: &lt;text&gt;:1:4: 想定外のシンボルです ## 1: 100A ## ^ 他にも変数名に.と_が入ることは禁じられておらず、むしろ積極的に使われる場合が多いです。 予約語を避ける また、Rで既に提供している関数やオブジェクト名は避けるべきです。例えば、Rには円周率 (\\(\\pi\\))の数値がpiという名前で含まれています。 pi ## [1] 3.141593 piという新しい変数を作るのは可能ですが、既存のpiが上書きされるため避けましょう。このようにプロブラミング言語が最初から提供しているオブジェクトの名前を「予約語」といいます。多くのプロブラミング言語は予約語を変数名として使うことを禁じており、Rも一部は禁止されています。たとえば、piは上書き可能ですが、ifやforというオブジェクト名は禁止されています。 pi &lt;- 3 if &lt;- &quot;Yanai&quot; ## Error: &lt;text&gt;:1:5: 想定外の付値です ## 1: if &lt;- ## ^ for &lt;- &quot;All&quot; ## Error: &lt;text&gt;:1:5: 想定外の付値です ## 1: for &lt;- ## ^ 短さと分かりやすさを重視する できれば、オブジェクト名を見るだけで、中身がどのようなものかが分かればベストでしょう。たとえば、学生5人の数学成績が格納されたベクトルを作るとします。 Variable1 &lt;- c(30, 91, 43, 77, 100) これでも問題ありませんが、プロブラミングの世界において変数はVariable1と全て書くよりもVar1やV1のように略す場合が多いです。データ分析の世界だと、変数名をX1やX2にする場合も多いです。しかし、これだけだと中身の内容が想像できません。したがって、変数名は可能な限り中身の内容をよく表現した名前が望ましいです。 mathscore &lt;- c(30, 91, 43, 77, 100) これだと、「あ、この変数には数学成績が入っているんだろうな」と容易に想像できます。ただ、ここで変数の可読性をより高めることも可能です。 MathScore &lt;- c(30, 91, 43, 77, 100) mathScore &lt;- c(30, 91, 43, 77, 100) math_score &lt;- c(30, 91, 43, 77, 100) math.score &lt;- c(30, 91, 43, 77, 100) 以上の例はmathとscoreの間に何らかの方法を使って区切りを入れた変数名であり、こちらの方が可読性が高いです。大文字と小文字の組み合わせで区切る方法は「キャメルケース (camel case)」と呼ばれ、大文字から始まるキャメルケースをアッパーキャメルケース (upper camel case)、小文字から始まるキャメルケースをローワーキャメルケース (lower camel case)と呼びます。また、_ (アンダーバー)で区切る方法は「スネークケース (snake case)」と呼ばれます。他にも- (ハイフン)で区切る「チェーンケース (chain case)」というのもありますが、Rの場合、オブジェクト名に-は禁止されております47。 最後に.を使う方法がありますが、Rでは使用可能です。しかし、この方法を推奨しない方も多いです。現在、データサイエンスにおけるTop2の言語はRとPythonですが、Pythonの場合、.をメソット呼び出しに使うため、オブジェクト名として使えないからです。RとPython二刀流の方には混乱の原因となりうるため、.を嫌う方もいます。しかし、Rのみ使用する方なら.を使っても問題ありません。 9.2.2 改行 コードは1行が長すぎないように適宜改行します。Rやパッケージなどが提供している関数の中には十数個以上の引数を必要とするケースもあります。この場合、コードを一行に全部書いてしまうと、コードの可読性が著しく落ちてしまします。 一行のどれくらいの文字を入れるべきかについて決まったルールはありませんが、昔は一行80字という基準がよく使われてきました。これま昔のパソコンで使ったパンチカード (図9.2)が一行に80個の穴を開けることができたのから由来します。 図 9.2: パンチカードの例 今はモニターのサイズも大きくなり、解像度も高くなっているので、80文字にこだわる必要はありません。ただし、少なくとも自分のRStudioのSource Paneに収まるように、改行を適宜行ってください。 9.2.3 スペースとインデント 適切なスペースはコードの可読性を向上させます。以下のコードは全く同じものですが、後者をスペースを入れなかったため、可読性があまりよくありません。 # 良い例 sum(myVec2, na.rm = TRUE) # 悪い例 sum(myVec2,na.rm=TRUE) どこにスペースを入れるかも決まっておりませんが、「,の後にスペース」、「演算子の前後にスペース」などの例があります。ただし、^の前後にスペースを入れません。また、後ほど紹介するfor(){}、while(){}、if(){}は()前後にスペースを入れます。ただし、function(){}は()の後のみにスペースを入れます。その他の関数の場合、関数名と()の間にスペースは入れません。 また、スペースを2回以上入れるケースもあります。たとえば、あるデータフレームを作るとします。 # 良い例 data.frame( Name = c(&quot;Song&quot;, &quot;Yanai&quot;, &quot;Hadley&quot;), Favorite = c(&quot;Ramen&quot;, &quot;Cat&quot;, &quot;R&quot;), Gender = c(&quot;Male&quot;, &quot;Male&quot;, &quot;Male&quot;) ) # 悪い例 data.frame( Name = c(&quot;Song&quot;, &quot;Yanai&quot;, &quot;Hadley&quot;), Favorite = c(&quot;Ramen&quot;, &quot;Cat&quot;, &quot;R&quot;), Gender = c(&quot;Male&quot;, &quot;Male&quot;, &quot;Male&quot;) ) どのコードも同じですが、前者の方が読みやすいです。ここでもう一つ見てもらいのは「字下げ」です。先ほどのコードは以下のように一行にまとめることは可能ですが、あまりにも可読性がよくありません。 # 邪悪な例 data.frame(Name = c(&quot;Song&quot;, &quot;Yanai&quot;, &quot;Hadley&quot;), Favorite = c(&quot;Ramen&quot;, &quot;Cat&quot;, &quot;R&quot;), Gender = c(&quot;Male&quot;, &quot;Male&quot;, &quot;Male&quot;)) このように一行のコードが長い場合、「改行」が重要です。ただし、改行した場合、字下げを入れましょう。改行された行は2文字または4文字分の字下げをします。こうすることで、「この行は上の行の続きです」ということは一目で分かります。 # 良い例 data.frame( Name = c(&quot;Song&quot;, &quot;Yanai&quot;, &quot;Hadley&quot;), Favorite = c(&quot;Ramen&quot;, &quot;Cat&quot;, &quot;R&quot;), Gender = c(&quot;Male&quot;, &quot;Male&quot;, &quot;Male&quot;) ) # 悪い例 data.frame( Name = c(&quot;Song&quot;, &quot;Yanai&quot;, &quot;Hadley&quot;), Favorite = c(&quot;Ramen&quot;, &quot;Cat&quot;, &quot;R&quot;), Gender = c(&quot;Male&quot;, &quot;Male&quot;, &quot;Male&quot;) ) RStudioは自動的に字下げをしてくれるので、あまり気にする必要がありませんが、メモ帳などでコードを書く際は意識してください。 9.2.4 代入 オブジェクトに値を代入する演算子として、これまでは&lt;-を使ってきましたが、=も使えます。実際、多くのプログラミング言語の場合、代入演算子は=を採用しています。しかし、本書では&lt;-の使用を推奨します。 以上の内容は書き方の一部に過ぎません。本書のコードは出来る限り、多くの人に受け入れられているコードの書き方をするように心がけております。本書のコードを自分の手で書いていくうちに、徐々に書き方が身につくと思います。 最後に、より詳細な書き方のガイドについては以下の2つの資料が非常に参考になります。とりわけ、Hadley先生が書いたThe tidyverse style guideは事実上 (de facto)の業界標準であり、Google’s Style GuideはHadley先生が書いたスタイルガイドに基づいています。かなりの分量ですが、自分でパッケージ開発などを考えている場合は必ず一回目を通しておきましょう。 The tidyverse style guide Google’s Style Guide 9.3 反復 パソコンが最も得意とすることが「反復作業」です。普通の人間なら数時間〜数年かかるような退屈な反復作業を、パソコンを一瞬で終わらせます。Rもプログラミング言語である以上、反復作業のための様々な関数を提供しております。 反復作業を行う際は、「いつまで繰り返せば良いのか」を考えなくてはありません。そこで、2つのケースが考えられます。 指定した回数だけ処理を繰り返す場合: for()文 一定の条件が満たされるまで処理を繰り返す場合: while()文 ここではこの2つのケースそれぞれについて解説します。 9.3.1 for()による反復 まずは、for()文を用いた反復処理のコードの雛形をみてみましょう。 for (任意の変数 in ベクトル) { 処理内容 } 任意の変数は何でもいいんですが、よく使うのはiです (indexの意味)。この変数はfor(){}文の内部で使うために用いられる変数です。そして、inの後の「ベクトル」は長さ1以上のベクトルです。必ずしもnumeric型である必要はありません。 また、{}内の内容が1行くらいで短い場合、{}は省略することもできます。したがって、以下のような書き方も可能です。これはfor()だけでなく、if()やfunction()など、{}で処理内容を囲む関数において共通です。この場合、処理内容を()の直後に書くのが一般的です。例えば、以下のように書きます。 for (任意の変数 in ベクトル) 処理内容 ただし、処理内容が2行以上の場合は、必ず{}で囲んでください。 まずは、単にN回繰り返すfor()文を書いてみましょう。任意の変数名はiとします。この場合、for (i in 1:N)と書きます。5回繰り返すならfor (i in 1:5)となります。1:5はc(1, 2, 3, 4, 5)と同じですので、for (i in c(1, 2, 3, 4, 5))でも構いませんが、効率はよくありません。 とりあえず、以下のようにコードを作成し、走らせてみましょう。これは3行にわたるコードですので、Rコンソールで打ち込むのは非効率的です。必ずソースコード欄に書いて、forの行にカーソルを置いた状態でCmd + Enter (Windowsの場合、Contrl + Enter)を入力しましょう。むろん、この3行を全て選択してからCmd + Enterを押しても構いません。 for (i in 1:5) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 # 上記のコードはこのように書くことも可能 # for(i in 1:5) print(i) 1から5までの数字が表示されました。これは一体、どのような動きをしているのでしょうか。これから詳しく解説します。 iにベクトル1:5の最初の要素を代入 (i = 1) print(i)を実行 {}中身の処理が終わったらiにベクトル1:5内の次の要素を代入 (i = 2) print(i)を実行 {}中身の処理が終わったらiにベクトル1:5内の次の要素を代入 (i = 3) print(i)を実行 {}中身の処理が終わったらiにベクトル1:5内の次の要素を代入 (i = 4) print(i)を実行 {}中身の処理が終わったらiにベクトル1:5内の次の要素を代入 (i = 5) print(i)を実行 {}中身の処理が終わったらiにベクトル1:5内の次の要素を代入するが、5が最後なので反復終了 以上のような手順でfor()文は作動します。この手順を要約すると以下のようになります。 任意の変数 (ここではi)にベクトル (ここでは1:5)の最初の要素が格納され、{}内の処理を行う。 {}内の処理が終わったら、ベクトル (ここでは1:5)の次の要素を任意の変数 (ここではi)に格納し、{}内の処理を行う。 格納できる要素がなくなったら反復を終了する。 したがって、反復はベクトル (ここでは1:5)の長さだけ実行される (ここでは5回)。 反復はベクトルの長さだけ実行されるので、1:5のような書き方でなく、普通のベクトルでも問題ありません。たとえば、長さ6のIter_Vec1というベクトルを作り、その要素を出力するコードを書いてみましょう。 Iter_Vec1 &lt;- c(24, 64, 31, 46, 81, 102) for (damage in Iter_Vec1) { x &lt;- paste0(&quot;トンヌラに&quot;, damage, &quot;のダメージ!!&quot;) print(x) } ## [1] &quot;トンヌラに24のダメージ!!&quot; ## [1] &quot;トンヌラに64のダメージ!!&quot; ## [1] &quot;トンヌラに31のダメージ!!&quot; ## [1] &quot;トンヌラに46のダメージ!!&quot; ## [1] &quot;トンヌラに81のダメージ!!&quot; ## [1] &quot;トンヌラに102のダメージ!!&quot; スライムを倒すには十分な攻撃力を持つ勇者ですね。ちなみに、paste0()は引数を空白なし48で繋ぎ、文字列として返す関数です。詳細は第16で解説する予定ですが、簡単な例だけお見せします。 paste0(&quot;私は&quot;, &quot;Rが&quot;, &quot;使えません。&quot;) ## [1] &quot;私はRが使えません。&quot; paste0(&quot;私の&quot;, &quot;英語成績は&quot;, 0, &quot;点です。&quot;) ## [1] &quot;私の英語成績は0点です。&quot; むろん、文字列のベクトルを使うことも可能です。10個の都市名が格納されたIter_Vec2の要素を一個ずつ出力するコードは以下のようになります。 Iter_Vec2 &lt;- c(&quot;Sapporo&quot;, &quot;Sendai&quot;, &quot;Tokyo&quot;, &quot;Yokohama&quot;, &quot;Nagoya&quot;, &quot;Kyoto&quot;, &quot;Osaka&quot;, &quot;Kobe&quot;, &quot;Hiroshima&quot;, &quot;Fukuoka&quot;) for (city in Iter_Vec2) { x &lt;- paste0(&quot;現在、cityの値は&quot;, city, &quot;です。&quot;) print(x) } ## [1] &quot;現在、cityの値はSapporoです。&quot; ## [1] &quot;現在、cityの値はSendaiです。&quot; ## [1] &quot;現在、cityの値はTokyoです。&quot; ## [1] &quot;現在、cityの値はYokohamaです。&quot; ## [1] &quot;現在、cityの値はNagoyaです。&quot; ## [1] &quot;現在、cityの値はKyotoです。&quot; ## [1] &quot;現在、cityの値はOsakaです。&quot; ## [1] &quot;現在、cityの値はKobeです。&quot; ## [1] &quot;現在、cityの値はHiroshimaです。&quot; ## [1] &quot;現在、cityの値はFukuokaです。&quot; 次は、for()の外にあるオブジェクトを参照するfor()文について説明します。たとえば、\"1番目の都市名はSapporoです\"、\"2番目の都市名はSendaiです\"、…のように出力するにはどうすれば良いでしょうか。今までは一箇所だけ変えながら表示しましたが、今回は「i番目」と「cityです」の二箇所が変わります。この場合は、まずiを基準に反復を行いながら、Iter_Vec2のi番目要素を呼び出すことで解決できます。以下のコードを見てみましょう。 for (i in 1:length(Iter_Vec2)) { msg &lt;- paste0(i, &quot;番目の都市名は&quot;, Iter_Vec2[i], &quot;です。&quot;) print(msg) } ## [1] &quot;1番目の都市名はSapporoです。&quot; ## [1] &quot;2番目の都市名はSendaiです。&quot; ## [1] &quot;3番目の都市名はTokyoです。&quot; ## [1] &quot;4番目の都市名はYokohamaです。&quot; ## [1] &quot;5番目の都市名はNagoyaです。&quot; ## [1] &quot;6番目の都市名はKyotoです。&quot; ## [1] &quot;7番目の都市名はOsakaです。&quot; ## [1] &quot;8番目の都市名はKobeです。&quot; ## [1] &quot;9番目の都市名はHiroshimaです。&quot; ## [1] &quot;10番目の都市名はFukuokaです。&quot; ここではfor (i in 1:10)ではなく、for (i in 1:length(Iter_Vec2))と表記しましたが、前者よりも後者の方が望ましい書き方です。なぜなら、もし事後的にIter_Vec2に都市名を2つ追加した場合、前者だと1:12と修正する必要がありますが、後者はlength()関数でIter_Vec2の長さを計算してくれるからです。 多重for()文について for()文の中に、更にfor()文を使用することも可能です。最初はやや難しいかも知れませんが、多重反復はプログラミングでもよく使われるので49、この機会に勉強しておきましょう。 この多重for()文の定番の例は(掛け算)九九です。1から9まで、全ての組み合わせの掛け算を計算するためには、2つのfor()文が必要です。i * jでiとjそれぞれに1から9を代入しながら結果を出力するコードは以下のように書きます。 for (i in 1:9) { for (j in 1:9) { print(paste(i, &quot;*&quot;, j, &quot;=&quot;, i * j)) } } ## [1] &quot;1 * 1 = 1&quot; ## [1] &quot;1 * 2 = 2&quot; ## [1] &quot;1 * 3 = 3&quot; ## [1] &quot;1 * 4 = 4&quot; ## [1] &quot;1 * 5 = 5&quot; ## [1] &quot;1 * 6 = 6&quot; ## [1] &quot;1 * 7 = 7&quot; ## [1] &quot;1 * 8 = 8&quot; ## [1] &quot;1 * 9 = 9&quot; ## [1] &quot;2 * 1 = 2&quot; ## [1] &quot;2 * 2 = 4&quot; ## [1] &quot;2 * 3 = 6&quot; ## [1] &quot;2 * 4 = 8&quot; ## [1] &quot;2 * 5 = 10&quot; ## [1] &quot;2 * 6 = 12&quot; ## [1] &quot;2 * 7 = 14&quot; ## [1] &quot;2 * 8 = 16&quot; ## [1] &quot;2 * 9 = 18&quot; ## [1] &quot;3 * 1 = 3&quot; ## [1] &quot;3 * 2 = 6&quot; ## [1] &quot;3 * 3 = 9&quot; ## [1] &quot;3 * 4 = 12&quot; ## [1] &quot;3 * 5 = 15&quot; ## [1] &quot;3 * 6 = 18&quot; ## [1] &quot;3 * 7 = 21&quot; ## [1] &quot;3 * 8 = 24&quot; ## [1] &quot;3 * 9 = 27&quot; ## [1] &quot;4 * 1 = 4&quot; ## [1] &quot;4 * 2 = 8&quot; ## [1] &quot;4 * 3 = 12&quot; ## [1] &quot;4 * 4 = 16&quot; ## [1] &quot;4 * 5 = 20&quot; ## [1] &quot;4 * 6 = 24&quot; ## [1] &quot;4 * 7 = 28&quot; ## [1] &quot;4 * 8 = 32&quot; ## [1] &quot;4 * 9 = 36&quot; ## [1] &quot;5 * 1 = 5&quot; ## [1] &quot;5 * 2 = 10&quot; ## [1] &quot;5 * 3 = 15&quot; ## [1] &quot;5 * 4 = 20&quot; ## [1] &quot;5 * 5 = 25&quot; ## [1] &quot;5 * 6 = 30&quot; ## [1] &quot;5 * 7 = 35&quot; ## [1] &quot;5 * 8 = 40&quot; ## [1] &quot;5 * 9 = 45&quot; ## [1] &quot;6 * 1 = 6&quot; ## [1] &quot;6 * 2 = 12&quot; ## [1] &quot;6 * 3 = 18&quot; ## [1] &quot;6 * 4 = 24&quot; ## [1] &quot;6 * 5 = 30&quot; ## [1] &quot;6 * 6 = 36&quot; ## [1] &quot;6 * 7 = 42&quot; ## [1] &quot;6 * 8 = 48&quot; ## [1] &quot;6 * 9 = 54&quot; ## [1] &quot;7 * 1 = 7&quot; ## [1] &quot;7 * 2 = 14&quot; ## [1] &quot;7 * 3 = 21&quot; ## [1] &quot;7 * 4 = 28&quot; ## [1] &quot;7 * 5 = 35&quot; ## [1] &quot;7 * 6 = 42&quot; ## [1] &quot;7 * 7 = 49&quot; ## [1] &quot;7 * 8 = 56&quot; ## [1] &quot;7 * 9 = 63&quot; ## [1] &quot;8 * 1 = 8&quot; ## [1] &quot;8 * 2 = 16&quot; ## [1] &quot;8 * 3 = 24&quot; ## [1] &quot;8 * 4 = 32&quot; ## [1] &quot;8 * 5 = 40&quot; ## [1] &quot;8 * 6 = 48&quot; ## [1] &quot;8 * 7 = 56&quot; ## [1] &quot;8 * 8 = 64&quot; ## [1] &quot;8 * 9 = 72&quot; ## [1] &quot;9 * 1 = 9&quot; ## [1] &quot;9 * 2 = 18&quot; ## [1] &quot;9 * 3 = 27&quot; ## [1] &quot;9 * 4 = 36&quot; ## [1] &quot;9 * 5 = 45&quot; ## [1] &quot;9 * 6 = 54&quot; ## [1] &quot;9 * 7 = 63&quot; ## [1] &quot;9 * 8 = 72&quot; ## [1] &quot;9 * 9 = 81&quot; まずは、iに1が代入されます。そして、jに1から9が一つずつ入れ替わるので、1 * 1、1 * 2、1 * 3、…、1 * 9が計算されます。1 * 9の計算が終わったらiに2が代入され、再び内側のfor()文が実行され、2 * 1、2 * 2、2 * 3、…、2 * 9が計算されます。これを9の段まで繰り返します。もし、9の段から1の段の順にしたい場合は、i in 1:9をi in 9:1に変えるだけです。 for (i in 9:1) { for (j in 1:9) { print(paste(i, &quot;*&quot;, j, &quot;=&quot;, i * j)) } } ## [1] &quot;9 * 1 = 9&quot; ## [1] &quot;9 * 2 = 18&quot; ## [1] &quot;9 * 3 = 27&quot; ## [1] &quot;9 * 4 = 36&quot; ## [1] &quot;9 * 5 = 45&quot; ## [1] &quot;9 * 6 = 54&quot; ## [1] &quot;9 * 7 = 63&quot; ## [1] &quot;9 * 8 = 72&quot; ## [1] &quot;9 * 9 = 81&quot; ## [1] &quot;8 * 1 = 8&quot; ## [1] &quot;8 * 2 = 16&quot; ## [1] &quot;8 * 3 = 24&quot; ## [1] &quot;8 * 4 = 32&quot; ## [1] &quot;8 * 5 = 40&quot; ## [1] &quot;8 * 6 = 48&quot; ## [1] &quot;8 * 7 = 56&quot; ## [1] &quot;8 * 8 = 64&quot; ## [1] &quot;8 * 9 = 72&quot; ## [1] &quot;7 * 1 = 7&quot; ## [1] &quot;7 * 2 = 14&quot; ## [1] &quot;7 * 3 = 21&quot; ## [1] &quot;7 * 4 = 28&quot; ## [1] &quot;7 * 5 = 35&quot; ## [1] &quot;7 * 6 = 42&quot; ## [1] &quot;7 * 7 = 49&quot; ## [1] &quot;7 * 8 = 56&quot; ## [1] &quot;7 * 9 = 63&quot; ## [1] &quot;6 * 1 = 6&quot; ## [1] &quot;6 * 2 = 12&quot; ## [1] &quot;6 * 3 = 18&quot; ## [1] &quot;6 * 4 = 24&quot; ## [1] &quot;6 * 5 = 30&quot; ## [1] &quot;6 * 6 = 36&quot; ## [1] &quot;6 * 7 = 42&quot; ## [1] &quot;6 * 8 = 48&quot; ## [1] &quot;6 * 9 = 54&quot; ## [1] &quot;5 * 1 = 5&quot; ## [1] &quot;5 * 2 = 10&quot; ## [1] &quot;5 * 3 = 15&quot; ## [1] &quot;5 * 4 = 20&quot; ## [1] &quot;5 * 5 = 25&quot; ## [1] &quot;5 * 6 = 30&quot; ## [1] &quot;5 * 7 = 35&quot; ## [1] &quot;5 * 8 = 40&quot; ## [1] &quot;5 * 9 = 45&quot; ## [1] &quot;4 * 1 = 4&quot; ## [1] &quot;4 * 2 = 8&quot; ## [1] &quot;4 * 3 = 12&quot; ## [1] &quot;4 * 4 = 16&quot; ## [1] &quot;4 * 5 = 20&quot; ## [1] &quot;4 * 6 = 24&quot; ## [1] &quot;4 * 7 = 28&quot; ## [1] &quot;4 * 8 = 32&quot; ## [1] &quot;4 * 9 = 36&quot; ## [1] &quot;3 * 1 = 3&quot; ## [1] &quot;3 * 2 = 6&quot; ## [1] &quot;3 * 3 = 9&quot; ## [1] &quot;3 * 4 = 12&quot; ## [1] &quot;3 * 5 = 15&quot; ## [1] &quot;3 * 6 = 18&quot; ## [1] &quot;3 * 7 = 21&quot; ## [1] &quot;3 * 8 = 24&quot; ## [1] &quot;3 * 9 = 27&quot; ## [1] &quot;2 * 1 = 2&quot; ## [1] &quot;2 * 2 = 4&quot; ## [1] &quot;2 * 3 = 6&quot; ## [1] &quot;2 * 4 = 8&quot; ## [1] &quot;2 * 5 = 10&quot; ## [1] &quot;2 * 6 = 12&quot; ## [1] &quot;2 * 7 = 14&quot; ## [1] &quot;2 * 8 = 16&quot; ## [1] &quot;2 * 9 = 18&quot; ## [1] &quot;1 * 1 = 1&quot; ## [1] &quot;1 * 2 = 2&quot; ## [1] &quot;1 * 3 = 3&quot; ## [1] &quot;1 * 4 = 4&quot; ## [1] &quot;1 * 5 = 5&quot; ## [1] &quot;1 * 6 = 6&quot; ## [1] &quot;1 * 7 = 7&quot; ## [1] &quot;1 * 8 = 8&quot; ## [1] &quot;1 * 9 = 9&quot; 九九を覚える際はこれで良いでしょうが、i * jとj * iは実質的に同じですから、片方だけ出力させても問題はないでしょう。これはどうすれば良いでしょうか。この場合、for (j in 1:9)をfor (j in 1:i)に変えるだけです。 for (i in 1:9) { for (j in 1:i) { print(paste(i, &quot;*&quot;, j, &quot;=&quot;, i * j)) } } ## [1] &quot;1 * 1 = 1&quot; ## [1] &quot;2 * 1 = 2&quot; ## [1] &quot;2 * 2 = 4&quot; ## [1] &quot;3 * 1 = 3&quot; ## [1] &quot;3 * 2 = 6&quot; ## [1] &quot;3 * 3 = 9&quot; ## [1] &quot;4 * 1 = 4&quot; ## [1] &quot;4 * 2 = 8&quot; ## [1] &quot;4 * 3 = 12&quot; ## [1] &quot;4 * 4 = 16&quot; ## [1] &quot;5 * 1 = 5&quot; ## [1] &quot;5 * 2 = 10&quot; ## [1] &quot;5 * 3 = 15&quot; ## [1] &quot;5 * 4 = 20&quot; ## [1] &quot;5 * 5 = 25&quot; ## [1] &quot;6 * 1 = 6&quot; ## [1] &quot;6 * 2 = 12&quot; ## [1] &quot;6 * 3 = 18&quot; ## [1] &quot;6 * 4 = 24&quot; ## [1] &quot;6 * 5 = 30&quot; ## [1] &quot;6 * 6 = 36&quot; ## [1] &quot;7 * 1 = 7&quot; ## [1] &quot;7 * 2 = 14&quot; ## [1] &quot;7 * 3 = 21&quot; ## [1] &quot;7 * 4 = 28&quot; ## [1] &quot;7 * 5 = 35&quot; ## [1] &quot;7 * 6 = 42&quot; ## [1] &quot;7 * 7 = 49&quot; ## [1] &quot;8 * 1 = 8&quot; ## [1] &quot;8 * 2 = 16&quot; ## [1] &quot;8 * 3 = 24&quot; ## [1] &quot;8 * 4 = 32&quot; ## [1] &quot;8 * 5 = 40&quot; ## [1] &quot;8 * 6 = 48&quot; ## [1] &quot;8 * 7 = 56&quot; ## [1] &quot;8 * 8 = 64&quot; ## [1] &quot;9 * 1 = 9&quot; ## [1] &quot;9 * 2 = 18&quot; ## [1] &quot;9 * 3 = 27&quot; ## [1] &quot;9 * 4 = 36&quot; ## [1] &quot;9 * 5 = 45&quot; ## [1] &quot;9 * 6 = 54&quot; ## [1] &quot;9 * 7 = 63&quot; ## [1] &quot;9 * 8 = 72&quot; ## [1] &quot;9 * 9 = 81&quot; これは1の段は1 * 1まで、2の段は2 * 2まで、3の段は3 * 3まで計算し、出力するコードです。2の段の場合、2 * 3や2 * 9などが出力されませんが、これは3の段において3 * 2が、9の段で9 * 2が出力されるので問題ないでしょう。このように多重for()文は複数のベクトルの組み合わせ全てにおいて処理を行う場合、有効です。 複数のベクトルでなく、データフレームなどの2次元以上データにも多重for()文は使われます。データフレームは複数のベクトルで構成されているため、実質的には複数のベクトルを扱うことになります。今回は例として、FIFA_Men.csvを利用し、それぞれの国のチーム名、FAFAランキング、ポイントをまとめて表示するコードを書いてみます。全てのチームを出すと結果が長くなるので、OFC (オセアニアサッカー連盟)所属チームだけに絞ります。 # FIFA_Men.csvを読み込み、myDFという名で保存 myDF &lt;- read_csv(&quot;Data/FIFA_Men.csv&quot;) # myDFのConfederation列がOFCの行だけを抽出 myDF &lt;- myDF[myDF$Confederation == &quot;OFC&quot;, ] myDF ## # A tibble: 10 x 6 ## ID Team Rank Points Prev_Points Confederation ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 4 American Samoa 192 900 900 OFC ## 2 69 Fiji 163 996 996 OFC ## 3 135 New Caledonia 156 1035 1035 OFC ## 4 136 New Zealand 122 1149 1149 OFC ## 5 147 Papua New Guinea 165 991 991 OFC ## 6 159 Samoa 194 894 894 OFC ## 7 171 Solomon Islands 141 1073 1073 OFC ## 8 185 Tahiti 161 1014 1014 OFC ## 9 191 Tonga 203 862 862 OFC ## 10 204 Vanuatu 163 996 996 OFC ちょうど10チームとなります。作りたいのは以下のような内容が表示されるコードです。 =====1番目の国家情報===== Team: American Samoa Rank: 192 Points: 900 =====2番目の国家情報===== Team: Fiji Rank: 163 Points: 996 =====3番目の国家情報===== Team: New Caledonia ... 実はこれ、一つのfor()でも作成できますが、勉強のために2つのfor()文を使いましょう。 for (i in 1:nrow(myDF)) { print(paste0(&quot;=====&quot;, i, &quot;番目の国家情報=====&quot;)) for (j in c(&quot;Team&quot;, &quot;Rank&quot;, &quot;Points&quot;)) { print(paste0(j, &quot;: &quot;, myDF[i, j])) } } 以上のコードを実行すると以下のような結果が表示されます。ここでは全部掲載するのは長いので、最初の2チーム情報のみ掲載します。 ## [1] &quot;=====1番目の国家情報=====&quot; ## [1] &quot;Team: American Samoa&quot; ## [1] &quot;Rank: 192&quot; ## [1] &quot;Points: 900&quot; ## [1] &quot;=====2番目の国家情報=====&quot; ## [1] &quot;Team: Fiji&quot; ## [1] &quot;Rank: 163&quot; ## [1] &quot;Points: 996&quot; それではコードの詳細について説明します。まず、外側のfor()文には任意の変数としてはiを、内側のfor()文に対してはjを用います。Rの場合、コードは上からの順番で処理します（同じ行なら、カッコの中から処理します）。したがって、まず処理されるのは外側のfor()文です。iに割り当てられたベクトルは1:nrow(myDF)です。nrow()は行列またはデータフレームの行数を求める関数で、今回の場合、myDFは10行のデータであるため、1:10になります。つまり、外側のfor()文はiに1, 2, 3…の順で値を格納しながら10回処理を繰り返すことになります。それでは外側for()文の中身を見ましょう。ここではまず、\"=====i番目の国家情報=====\"というメッセージを出力します。最初はiが1ですので、\"=====1番目の国家情報=====\"が表示されます。 次の行からが内側のfor()文になります。ここではjにc(\"Team\", \"Rank\", \"Points\")を格納しながら内側for()文内のコードを3回繰り返します。内側のコード内容は例えば、i = 1の状態で、j = \"Team\"なら、print(paste0(\"Team\", \": \", myDF[1, \"Team\"]))になります。つまり、myDF[1, \"Team\"]は既に第8.4章で説明した通り、myDFのTeam列の1番目の要素を意味します。この処理が終わったら、次はjに\"Rank\"が代入され、同じコードを処理します。そして、j = \"Points\"まで処理が終わったら、内側のfor()文の役目はとりあえず終わりです。 内側のfor()文が終わっても、外側のfor()文はまだ終わっておりません。次はiに2が格納され、\"=====2番目の国家情報=====\"を表示し、また内側のfor()文を最初から処理します。この作業はi = 10の状態で内側のfor()文が終わる時点で、外側のfor()文も止まります。これが多重for()文の動き方です。 もし、チーム名の次に、所属連盟も表示したい場合はどう直せば良いでしょうか。正解はc(\"Team\", \"Rank\", \"Points\")のベクトルにおいて、\"Team\"と\"Rank\"の間に\"Confederation\"を追加するだけです。実際にやってみましょう (結果は紙幅の関係上、最初の2チームのみ掲載します)。 for (i in 1:nrow(myDF)) { print(paste0(&quot;=====&quot;, i, &quot;番目の国家情報=====&quot;)) for (j in c(&quot;Team&quot;, &quot;Confederation&quot;, &quot;Rank&quot;, &quot;Points&quot;)) { print(paste0(j, &quot;: &quot;, myDF[i, j])) } } ## [1] &quot;=====1番目の国家情報=====&quot; ## [1] &quot;Team: American Samoa&quot; ## [1] &quot;Confederation: OFC&quot; ## [1] &quot;Rank: 192&quot; ## [1] &quot;Points: 900&quot; ## [1] &quot;=====2番目の国家情報=====&quot; ## [1] &quot;Team: Fiji&quot; ## [1] &quot;Confederation: OFC&quot; ## [1] &quot;Rank: 163&quot; ## [1] &quot;Points: 996&quot; ちなみに、同じ動きをする別の書き方は以下のとおりです。結果は掲載しませんが、興味のある方は試してみて下さい。cat()関数の使い方については?catを参照してください。ちなみに\\nは改行コードを意味します。 for (i in 1:nrow(myDF)) { cat(paste0(&quot;=====&quot;, i, &quot;番目の国家情報=====\\n&quot;)) cat(paste0(&quot;Team:&quot;, myDF$Team[i], &quot;\\n&quot;, &quot;Rank:&quot;, myDF$Rank[i], &quot;\\n&quot;, &quot;Points:&quot;, myDF$Points[i], &quot;\\n&quot;)) } もう一つの例を見たいと思います。今回はリスト型を対象とした多重反復の例です。複数のベクトルを含むリストの場合、3番目のベクトルの5番目の要素を抽出するにはリスト名[[3]][5]のように2つの位置を指定する必要があります。たとえば、以下の3人で構成された3つのクラスがあるとし、そのグループ構成人の名前が出席番号順で入っているmyListを考えましょう。 myList &lt;- list(Class_A = c(&quot;Yanai&quot;, &quot;Song&quot;, &quot;Hadley&quot;), Class_B = c(&quot;Tanaka&quot;, &quot;Sato&quot;, &quot;Suzuki&quot;), Class_C = c(&quot;Abe&quot;, &quot;Moon&quot;, &quot;Xi&quot;)) ここで、まず各クラスの出席番号1番の人の名字3つを出力し、次は2番の人、最後に3番の人を出すにはどうすれば良いでしょうか。以下のコードを見て下さい。 for (i in 1:3) { for (j in names(myList)) { print(myList[[j]][i]) } print(paste0(&quot;===ここまでが出席番号&quot;, i, &quot;番の人です===&quot;)) } ## [1] &quot;Yanai&quot; ## [1] &quot;Tanaka&quot; ## [1] &quot;Abe&quot; ## [1] &quot;===ここまでが出席番号1番の人です===&quot; ## [1] &quot;Song&quot; ## [1] &quot;Sato&quot; ## [1] &quot;Moon&quot; ## [1] &quot;===ここまでが出席番号2番の人です===&quot; ## [1] &quot;Hadley&quot; ## [1] &quot;Suzuki&quot; ## [1] &quot;Xi&quot; ## [1] &quot;===ここまでが出席番号3番の人です===&quot; 以上のコードは以下のように動きます。 1行目: 任意の変数をiとし、1から3までの数字をiに格納しながら、3回反復作業を行います。 3行目: 任意の変数をjとし、ここにはリストの要素名を格納しながら、リストの長さだけ、処理を繰り返します。names(myList)はc(\"Class_A\", \"Class_B\", \"Class_C\")と同じです。 4行目: myList[[j]][i]の内容を出力します。最初はi = 1、j = \"Class_A\"なので、print(myList[[\"Class_A\"]][1])、つまり、myListから\"Class_A\"を取り出し、そこの1番目の要素を出力するという意味です。 7行目: 各ベクトルからi番目の要素を出力したら、print(paste0(\"===ここまでが出席番号\", i, \"番の人です===\"))を実行し、iに次の要素を入れて、反復作業を続きます。iに格納する要素がなくなったら、反復を中止します。 多重for()文は3重、4重も可能ですが、コードの可読性が低下するため、多くても3つ、できれば最大2つが良いです。3重以上にfor()文を重ねる場合は内側のfor()文を後ほど解説する関数でまとめるのがおすすめです。 9.3.2 while()による反復 for()文は任意の変数にベクトルの要素を1つずつ入れ替えながら、ベクトルの要素を使い尽くすまで反復処理を行います。一方、「ある条件が満たされる限り、反復し続ける」ことも可能であり、この際使う関数がwhile()文です。while()文の書き方はfor()文に非常に似ています。 while (条件) { 条件が満たされた場合の処理内容 } forがwhileに変わり、()内の書き方が(任意の変数 in ベクトル)から(条件)に変わりました。この()内の条件が満たされる間は{}内の内容を処理します。1から5を表示するコードはfor()文を使う場合、以下のようになります。 # for文を使う場合 for (i in 1:5) { print(i) } これをwhile()を使って再現すると以下のようなコードとなります。 # while文を使う場合 i &lt;- 1 while (i &lt;= 5) { print(i) i &lt;- i + 1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 while()内の条件はi &lt;= 5、つまり「iが5以下なら以下の内容を処理する」ことを意味します。注意すべきところはiが5以下か否かの判断は最初から行われるため、予め変数iを指定しておく必要があります。最初に出てくるi &lt;- 1がそれです。そして、{}内にはi &lt;- i + 1を追加し、iを1を足していきます。i = 5の時点ではprint(i)が実行されますが、i = 6になった瞬間、反復は停止します。 もう一つ注意すべきところはi &lt;- i + 1の位置です。以下は先ほどと同じコードですが、i &lt;- i + 1がprint(i)の前に位置するコードです。 i &lt;- 1 while (i &lt;= 5) { i &lt;- i + 1 print(i) } ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 今回は2から6まで出力されました。これはiを出力する前にiに1が足されるからです。そして、i = 5の状態で、iに1が足されることとなり、6が出力されます。もし、i &lt;- i + 1をprint(i)より前に置いたまま、1から5を出力させる場合は、以下のようにコードを修正する必要があります。 i &lt;- 0 while (i &lt;= 4) { i &lt;- i + 1 print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 変更点は1)iの初期値が0となった点と、2) ()内の条件が(i &lt;= 5)から(i &lt;= 4)に変わった点です。 while()による書き方は慣れないとややこしいと感じる方も多いかと思います。また、for()文で代替できるケースも多いです。それでもwhile()文を使うケースはあります。それは先述した通り、「目標が決まっているが、その目標が達成されるまでは何回繰り返せば分からない時」においてwhile()文は効果的です。 たとえば、6面サイコロ投げを考えてみましょう。投げる度に出た目を記録し、その和が30以上に達した瞬間、サイコロ投げを中止します。この場合、何回サイコロを投げる必要があるでしょうか。連続で6が出るなら5回で十分ですが、ずっと1のみが出るなら30回投げる必要があります。このように、「反復処理は行うが、何回行えばいいか分からない。ただし、いつやめるかは知っている」場合にwhile()文を使います。以下はwhile()文を使ったコードです。 Total &lt;- 0 Trial &lt;- 1 while (Total &lt; 30) { Dice &lt;- sample(1:6, 1) Total &lt;- Total + Dice print(paste0(Trial, &quot;回目のサイコロ投げの結果: &quot;, Dice, &quot;(これまでの総和: &quot;, Total, &quot;)&quot;)) # print()文は以下のような書き方も可能 # Result &lt;- sprintf(&quot;%d回目のサイコロ投げの結果: %d (これまでの総和: %d)&quot;, # Trial, Dice, Total) # print(Result) Trial &lt;- Trial + 1 } ## [1] &quot;1回目のサイコロ投げの結果: 2(これまでの総和: 2)&quot; ## [1] &quot;2回目のサイコロ投げの結果: 5(これまでの総和: 7)&quot; ## [1] &quot;3回目のサイコロ投げの結果: 4(これまでの総和: 11)&quot; ## [1] &quot;4回目のサイコロ投げの結果: 3(これまでの総和: 14)&quot; ## [1] &quot;5回目のサイコロ投げの結果: 2(これまでの総和: 16)&quot; ## [1] &quot;6回目のサイコロ投げの結果: 1(これまでの総和: 17)&quot; ## [1] &quot;7回目のサイコロ投げの結果: 5(これまでの総和: 22)&quot; ## [1] &quot;8回目のサイコロ投げの結果: 5(これまでの総和: 27)&quot; ## [1] &quot;9回目のサイコロ投げの結果: 5(これまでの総和: 32)&quot; それでは、コードの説明をします。まず、これまで出た目の和を記録する変数Totalを用意し、初期値として0を格納します。また、何回目の投げかを記録するためのTrial変数を記録し、初期値として1を格納しておきます (コードの1、2行目)。 続いてwhile()文を入れます。反復する条件はTotalが30より小さい場合と設定します。つまり、Totalが30以上になったら反復を終了することを意味します (コードの4行目)。 つづいて、サイコロ投げをし、出た目をDiceという変数に格納します。サイコロ投げは1から6の間の整数から無作為に一つを値を抽出することでできます。そこで使われるのがsample()関数です (コードの5行目)。sample()関数は与えられたベクトル内の要素を無作為に抽出する関数です。sample(c(1, 2, 3, 4, 5, 6), 1)は「c(1, 2, 3, 4, 5, 6)から1つの要素を無作為に抽出せよ」という意味です。むろん、複数の要素を抽出することも可能ですし、数値型ベクトルでなく、文字型ベクトルから抽出することも可能です。サイコロ投げをしたら、その目をTotalの値に足します (コードの6行目)。 つづいて、「1回目のサイコロ投げの結果: 5 (これまでの総和: 5)」のように、現在の処理結果を表示させます (コードの8行目)。最後にTrialの値を1増加させて反復を続けます (コードの14行目)。 むろん、for()文を使って再現することも可能であり、以下はfor()を使ったコードになります。 Total &lt;- 0 for (Trial in 1:30) { Dice &lt;- sample(1:6, 1) Total &lt;- Total + Dice # print()の代わりにsprintf()を使うことも可能 Result &lt;- sprintf(&quot;%d回目のサイコロ投げの結果: %d (これまでの総和: %d)&quot;, Trial, Dice, Total) print(Result) if (Total &gt;= 30) { break() # ()は省略可能 } } ## [1] &quot;1回目のサイコロ投げの結果: 4 (これまでの総和: 4)&quot; ## [1] &quot;2回目のサイコロ投げの結果: 4 (これまでの総和: 8)&quot; ## [1] &quot;3回目のサイコロ投げの結果: 1 (これまでの総和: 9)&quot; ## [1] &quot;4回目のサイコロ投げの結果: 3 (これまでの総和: 12)&quot; ## [1] &quot;5回目のサイコロ投げの結果: 4 (これまでの総和: 16)&quot; ## [1] &quot;6回目のサイコロ投げの結果: 6 (これまでの総和: 22)&quot; ## [1] &quot;7回目のサイコロ投げの結果: 2 (これまでの総和: 24)&quot; ## [1] &quot;8回目のサイコロ投げの結果: 1 (これまでの総和: 25)&quot; ## [1] &quot;9回目のサイコロ投げの結果: 5 (これまでの総和: 30)&quot; まず、サイコロを何回投げれば良いかは分かりませんが6面サイコロの場合、30回以内には必ず合計30になるので、まずTrial in 1:30とします。あとはwhile()文の書き方とほぼ同じですが、今回はiが自動的に更新されるのでi &lt;- i + 1は不要です。ただし、一定の条件が満たされる場合、for()文を停止する必要があります。そこで登場するのが条件分岐とbreak()です。条件分岐は次節で説明しますが、これは「Totalが30以上になった場合、ループから脱出せよ」を意味します。このループからの脱出を指示する関数がbreak()です。ちなみに、break()関数は()を抜いてbreakと書いても問題ありません。また、if(){}内の処理内容は一行ですので、if (Total &gt;= 30) breakのような書き方でも問題ありません。 これは余談ですが、結果の表示に今回はこれまで使ってきたprint()とpaste0() (またはpaste())を使わず、sprintf()を使いました。人によってはこっちの書き方を好む場合もあります。sprintf()内の%dはその位置に指定された変数の値を整数として代入することを意味します。sprintf()はまず、出力する文字列を指定し、続いて代入する変数を順番に引数として入れます。%sは文字型、%fは実数を意味します。%fの場合、少数点の桁数も指定可能であり、小数点2桁まで表示させる場合は%.2fのように表記します。以下のコードは3つの変数の値と文字列を結合する処理をprint(paste0())とsprintf()を用いて書いたものであり、同じ動きをします。 Name &lt;- &quot;Song&quot; Score &lt;- 50 Height &lt;- 176.2 print(paste0(Name, &quot;の数学成績は&quot;, Score, &quot;点で、身長は&quot;, Height, &quot;cmです。&quot;)) ## [1] &quot;Songの数学成績は50点で、身長は176.2cmです。&quot; # %sにNameを、%dにHeightを、%.1fにHeightを小数点1位まで格納し、出力 sprintf(&quot;%sの数学成績は%d点で、身長は%.1fcmです。&quot;, Name, Score, Height) ## [1] &quot;Songの数学成績は50点で、身長は176.2cmです。&quot; ただし、{}内のsprintf()はそのまま出力されないため、一旦、オブジェクトとして保存し、それをprint()を使って出力させる必要があります。詳細は?sprintfで確認してください。 今回は「多くても30回以内に終わる」ことが分かっていましたが、シミュレーションなどではそれが未知であるケースも多いです。目的に合わせてfor()文とwhile()文を使い分けましょう。 9.4 条件分岐 9.4.1 if()、else if()、else()による条件分岐 続いて、条件分岐について説明します。これは何らかの条件が満たされた場合、指定された処理を行うことを意味します。一般的な条件分岐は以下のように書きます。 if (条件) { 条件が満たされた場合の処理内容 } while()文と非常に書き方が似ていることが分かります。ただし、while()文は条件が満たされる限り{}の内容を繰り返して実行する意味を持つ一方、if()文は条件が満たされれば{}の内容を処理して終わるといった違いがあります。たとえば、名前が格納されているオブジェクトNameの中身が\"Song\"なら「アホ」と出力されるコードを考えてみましょう。 Name &lt;- &quot;Song&quot; if (Name == &quot;Song&quot;) { print(&quot;アホ&quot;) } ## [1] &quot;アホ&quot; if()内の条件は「Nameが\"Song\"」の場合、{}内の内容を処理せよということを意味します。もし、Nameの中身が\"Yanai\"ならどうでしょうか。 Name &lt;- &quot;Yanai&quot; if (Name == &quot;Song&quot;) { print(&quot;アホ&quot;) } なんの結果も表示されません。if()文単体だと、条件が満たされない場合の処理内容を指定することができません。ここでelse文の出番です。これはif()とセットで使われるものであり、if()内の条件が満たされなかった場合の処理内容を指定します。elseを加えたコードの書き方は以下の通りです。 if (条件) { 条件が満たされた場合の処理内容 } else { 条件が満たされなかった場合の処理内容 } else文は以下のように改行して入れることも可能です。 if (条件) { 条件が満たされた場合の処理内容 } else { 条件が満たされなかった場合の処理内容 } ただし、一般的なRスクリプトの書き方だと、改行しない方が望ましいです。なぜなら、「このif()文とelseは一つのセットです」ということがより明確になるからです。コードの書き方は人にもよりますが、何らかのこだわりがないなら、改行せずに使いましょう。 それではNameが\"Song\"じゃない場合、「天才」と表示されるコードを書いてみましょう。 Name &lt;- &quot;Song&quot; if (Name == &quot;Song&quot;) { print(&quot;アホ&quot;) } else { print(&quot;天才&quot;) } ## [1] &quot;アホ&quot; Nameが\"Song\"の場合、前と変わらず「アホ」が出力されます。それではNameを\"Yanai\"に変えてみましょう。 Name &lt;- &quot;Yanai&quot; if (Name == &quot;Song&quot;) { print(&quot;アホ&quot;) } else { print(&quot;天才&quot;) } ## [1] &quot;天才&quot; ちゃんと「天才」が表示されます。しかし、世の中はアホと天才のみで構成されておりません。世界に真の天才はYanaiとShinadaのみ、アホはSongのみだとします。それ以外の人は凡才だとします。つまり、今回はパタンが3つあります。この場合はelse if()をif()とelseの間に挿入します。 if (条件1) { 条件1が満たされた場合の処理内容 } else if (条件2) { 条件1が満たされず、条件2が満たされたい場合の処理内容 } else if (条件3) { 条件1, 2が満たされず、条件3が満たされたい場合の処理内容 } else { 条件が全て満たされなかった場合の処理内容 } これはif()文の条件が満たされたら後の{}内容を処理し、満たされなかったら次のelse if()内の条件を判定する。そして、条件が満たされたら{}の内容が実行され、満たされなかったら次のelse if()へ移動する…といった構造となります。それでは実際のコードを書いてみましょう。 Name &lt;- &quot;Song&quot; if (Name == &quot;Song&quot;) { print(&quot;アホ&quot;) } else if (Name == &quot;Yanai&quot; | Name == &quot;Shinada&quot;) { # 以上の文は } else if (Name %in% c(&quot;Yanai&quot;, &quot;Shinada&quot;)) { もOK print(&quot;天才&quot;) } else { print(&quot;凡才&quot;) } ## [1] &quot;アホ&quot; まず、Nameが\"Song\"か否かを判定し、TRUEなら「アホ」を表示します。もし、FALSEなら次のelse if()文へ移動します。ここではNameが\"Yanai\"もしくは\"Shinada\"かを判定します。|は「OR (または)」を意味する論理演算子であり、既に第6章で解説しました。このように条件の中には|や&amp;などの論理演算子を使うことで、複数の条件を指定することができます。また、Name == \"Yanai\" | Name == \"Shinada\"はName %in% c(\"Yanai\", \"Shinada\")に書き換えることができます。x %in% yはxがyに含まれているか否かを判定する演算子です。たとえば、\"A\" %in% c(\"A\", \"B\", \"C\")の結果はTRUEですが、\"Z\" %in% c(\"A\", \"B\", \"C\")の結果はFALSEです。 それではNameを\"Yanai\"、\"Shinada\"、\"Shigemura\"、\"Hakiai\"に変えながら結果を確認してみましょう。 Name &lt;- &quot;Yanai&quot; if (Name == &quot;Song&quot;) { print(&quot;アホ&quot;) } else if (Name %in% c(&quot;Yanai&quot;, &quot;Shinada&quot;)) { print(&quot;天才&quot;) } else { print(&quot;凡才&quot;) } ## [1] &quot;天才&quot; Name &lt;- &quot;Shinada&quot; if (Name == &quot;Song&quot;) { print(&quot;アホ&quot;) } else if (Name %in% c(&quot;Yanai&quot;, &quot;Shinada&quot;)) { print(&quot;天才&quot;) } else { print(&quot;凡才&quot;) } ## [1] &quot;天才&quot; Name &lt;- &quot;Shigemura&quot; if (Name == &quot;Song&quot;) { print(&quot;アホ&quot;) } else if (Name %in% c(&quot;Yanai&quot;, &quot;Shinada&quot;)) { print(&quot;天才&quot;) } else { print(&quot;凡才&quot;) } ## [1] &quot;凡才&quot; Name &lt;- &quot;Hakiai&quot; if (Name == &quot;Song&quot;) { print(&quot;アホ&quot;) } else if (Name %in% c(&quot;Yanai&quot;, &quot;Shinada&quot;)) { print(&quot;天才&quot;) } else { print(&quot;凡才&quot;) } ## [1] &quot;凡才&quot; if()文が単独で使われることは滅多にありません。if()文は主に反復処理を行うfor()またはwhile()文内、もしくは次節で説明する自作関数内に使われる場合がほとんどです。実際、これまで名前からアホ・天才・凡才を判定する度に同じコードを書いてきました。これはあまりにも非効率的です。これを関数としてまとめることが出来るとより使いやすくなります。関数の作成については第9.5で説明します。 ここではfor()文と条件分岐の組み合わせについて考えてみましょう。生徒10人の成績が入っているベクトルScoresがあるとします。そして、成績が60点以上なら「可」を、未満なら「不可」を返すようなコードを書きます。この作業を効率的に行うためにはfor()文とif()文を組み合わせる方法が考えられます。つまり、for()文には任意の変数iに1から10までの数字を入れ替えながら反復を行います。ここでの10はベクトルScoresの長さですので、length(Scores)も問題ありません。そして、Scoresのi番目要素に対して60点以上か否かの判定を行い、「可」または「不可」の結果を返します。以下のコードはその例です。 Scores &lt;- c(58, 100, 81, 97, 71, 61, 47, 60, 73, 85) for (i in 1:length(Scores)) { if (Scores[i] &gt;= 60) { print(paste0(&quot;生徒&quot;, i, &quot;の判定結果: 可&quot;)) } else { print(paste0(&quot;生徒&quot;, i, &quot;の判定結果: 不可&quot;)) } } ## [1] &quot;生徒1の判定結果: 不可&quot; ## [1] &quot;生徒2の判定結果: 可&quot; ## [1] &quot;生徒3の判定結果: 可&quot; ## [1] &quot;生徒4の判定結果: 可&quot; ## [1] &quot;生徒5の判定結果: 可&quot; ## [1] &quot;生徒6の判定結果: 可&quot; ## [1] &quot;生徒7の判定結果: 不可&quot; ## [1] &quot;生徒8の判定結果: 可&quot; ## [1] &quot;生徒9の判定結果: 可&quot; ## [1] &quot;生徒10の判定結果: 可&quot; 1行目: まず、ベクトルScoresを定義します。 3行目: for()文を用います。任意の変数はiとし、ここには1から10を入れ替えながら反復を行います。したがって、i in 1:10でも問題ありませんが、ここではi in 1:length(Scores)にします。こうすることで、Scoresベクトルの長さが変わっても、for()の中身を修正する必要がなくなります。 4, 5行目: Scoresのi番目要素が60点以上かを判定し、TRUEなら「生徒iの判定結果: 可」を出力します。 6-8行目: Scoresのi番目要素が60点以上でない場合、「生徒iの判定結果: 不可」を出力します。 print()内にpaste0()を使うのはコードの可読性がやや落ちるので、sprintf()を使うことも可能です。 Scores &lt;- c(58, 100, 81, 97, 71, 61, 47, 60, 73, 85) for (i in 1:length(Scores)) { if (Scores[i] &gt;= 60) { Result &lt;- sprintf(&quot;生徒%dの判定結果: 可&quot;, i) } else { Result &lt;- sprintf(&quot;生徒%dの判定結果: 不可&quot;, i) } print(Result) } ## [1] &quot;生徒1の判定結果: 不可&quot; ## [1] &quot;生徒2の判定結果: 可&quot; ## [1] &quot;生徒3の判定結果: 可&quot; ## [1] &quot;生徒4の判定結果: 可&quot; ## [1] &quot;生徒5の判定結果: 可&quot; ## [1] &quot;生徒6の判定結果: 可&quot; ## [1] &quot;生徒7の判定結果: 不可&quot; ## [1] &quot;生徒8の判定結果: 可&quot; ## [1] &quot;生徒9の判定結果: 可&quot; ## [1] &quot;生徒10の判定結果: 可&quot; 続いて、結果を出力するのではなく、結果を別途のベクトルに格納する例を考えてみましょう。予め長さ10の空ベクトルPFを用意します。ここに各生徒の判定結果を「可/不可」で格納する処理を行います。以下はその例です。 Scores &lt;- c(58, 100, 81, 97, 71, 61, 47, 60, 73, 85) PF &lt;- rep(NA, length(Scores)) for (i in 1:length(Scores)) { if (Scores[i] &gt;= 60) { PF[i] &lt;- &quot;可&quot; } else { PF[i] &lt;- &quot;不可&quot; } } まず、中身がNAのみで構成されている長さ10の空ベクトルPFを生成します。rep(NA, length(Scores))はNAをlength(Scores)個 (ここでは10個)並べたベクトルを生成する関数です。たとえば、rep(5, 3)はc(5, 5, 5)と同じです。 続いて、条件分岐ですが、今回はメッセージを出力するのではなく、PFのi番目に\"可\"か\"不可\"を入れます。以下はその結果です。 PF ## [1] &quot;不可&quot; &quot;可&quot; &quot;可&quot; &quot;可&quot; &quot;可&quot; &quot;可&quot; &quot;不可&quot; &quot;可&quot; &quot;可&quot; &quot;可&quot; このように、if()文は反復処理を行うfor()またはwhile()文と組み合わせることで本領発揮となります。実は今回の例ですが、後で説明するifelse()を使うと、一行で処理することができます。ただし、複雑な処理を伴う反復と条件分岐の組み合わせの場合は、今回のようにfor()とif()を組み合わせる必要が出てきます。 9.4.2 ifelse()による条件分岐 ifelse()は与えられたベクトル内の要素に対して条件分岐をし、それを全ての要素に対して繰り返す関数です。簡単な条件分岐と反復処理を同時に行う非常に便利な関数です。ifelse()の使い方は以下の通りです。 ifelse(条件, 条件がTRUEの場合の処理、条件がFALSEの場合の処理) たとえば、生徒10人の成績が入っているベクトルScoresに対して、60点以上の場合、合格 (\"Pass\")、未満の場合は不合格 (\"Fail\")の値を割り当て、PFというベクトルに格納するとします。 Scores &lt;- c(58, 100, 81, 97, 71, 61, 47, 60, 73, 85) PF &lt;- ifelse(Scores &gt;= 60, &quot;Pass&quot;, &quot;Fail&quot;) PF ## [1] &quot;Fail&quot; &quot;Pass&quot; &quot;Pass&quot; &quot;Pass&quot; &quot;Pass&quot; &quot;Pass&quot; &quot;Fail&quot; &quot;Pass&quot; &quot;Pass&quot; &quot;Pass&quot; 条件はScoresが60以上か否かであり、60以上なら\"Pass\"を、それ以外なら\"Fail\"を返します。また、返す値は必ず新しい値である必要がありません。一定の条件が満たされたらそのままにし、それ以外なら指定した値を返すことも可能です。たとえば、世論調査では以下のように「答えたくない」または「わからない」を9や99などで記録することがよくあります。この値はこのまま使うのが難しい場合が多く、欠損値として扱う場合があります。 Q. あなたはラーメンが好きですか。 1.非常にそう思う 2.そう思う 3.どちらかと言えばそう思う 9.答えたくない 以上の選択肢に対する10人の回答が格納されているデータフレーム (Ramen.df)があるとします。データフレームは2つの列があり、ID列は回答者のID、Ramen列は以上の質問文に対する答えが入っています。 Ramen.df &lt;- data.frame( ID = 1:10, Ramen = c(1, 1, 2, 1, 3, 1, 9, 2, 1, 9) ) Ramen.df ## ID Ramen ## 1 1 1 ## 2 2 1 ## 3 3 2 ## 4 4 1 ## 5 5 3 ## 6 6 1 ## 7 7 9 ## 8 8 2 ## 9 9 1 ## 10 10 9 ここのRamen列に対して、Ramen == 9ならNAを割り当て、それ以外の場合は元の値を割り当てるとします。そしてその結果をRamen.dfのRamen列に上書きします。これは以下のように書くことができます。 Ramen.df$Ramen &lt;- ifelse(Ramen.df$Ramen == 9, NA, Ramen.df$Ramen) Ramen.df ## ID Ramen ## 1 1 1 ## 2 2 1 ## 3 3 2 ## 4 4 1 ## 5 5 3 ## 6 6 1 ## 7 7 NA ## 8 8 2 ## 9 9 1 ## 10 10 NA これはRamen.df$Ramenの値が9ならNAを、それ以外なら元の値を格納し、結果をRamen.df$Ramenに上書きすることを意味します。 また、ifelse()の中にifelse()を使うことも可能です。Scoresベクトルの例を考えてみましょう。ここで90点以上ならS、80点以上ならA、70点以上ならB、60点以上ならCを割り当て、それ以外はDを返すとします。この結果をGradeという変数に格納してみましょう。 Grade &lt;- ifelse(Scores &gt;= 90, &quot;S&quot;, ifelse(Scores &gt;= 80 &amp; Scores &lt; 90, &quot;A&quot;, ifelse(Scores &gt;= 70 &amp; Scores &lt; 80, &quot;B&quot;, ifelse(Scores &gt;= 60 &amp; Scores &lt; 70, &quot;C&quot;, &quot;D&quot;)))) Grade ## [1] &quot;D&quot; &quot;S&quot; &quot;A&quot; &quot;S&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; これはifelse()の条件がFALSEの場合、次のifelse()で判定する仕組みとなっています。しかし、ifelse()を使いすぎるとコードの可読性が非常に落ちてしまうので、あまり例ではありません。しかもifelse()の中にifelse()を書く場合、&amp;や|を用いることが多く、更に可動性が落ちてしまいます。この場合はdplyrパッケージに含まれているcase_when()関数を推奨します。この関数に関しては第10章で詳細に説明する予定ですが、ここでは上のコードと同じ処理を行うcase_when()関数を書く方を紹介します。 Grade2 &lt;- dplyr::case_when(Scores &gt;= 90 ~ &quot;S&quot;, Scores &gt;= 80 &amp; Scores &lt; 90 ~ &quot;A&quot;, Scores &gt;= 70 &amp; Scores &lt; 80 ~ &quot;B&quot;, Scores &gt;= 60 &amp; Scores &lt; 70 ~ &quot;C&quot;, Scores &lt; 60 ~ &quot;D&quot;) Grade2 ## [1] &quot;D&quot; &quot;S&quot; &quot;A&quot; &quot;S&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; 9.4.3 switch()による条件分岐 switch()は基本的に与えられた長さ1の文字列50を用いた条件分岐となります。これは単体で使われうことがほぼなく、自作関数内に使われる場合があります。したがって、この節はとりあえず飛ばし、関数の節を読んでから戻ってきてください。 ここでは2つの数値xとyの加減乗除を行う関数myCalcを作成します。この関数はx とy以外にもmethod引数があり、このmethodの値によって行う処理が異なります。たとえば、method = \"+\"なら足し算を、method = \"*\"なら掛け算を行う仕組みです。 myCalc &lt;- function(x, y, method) { switch(method, &quot;+&quot; = x + y, &quot;-&quot; = x - y, &quot;*&quot; = x * y, &quot;/&quot; = x / y, stop(&quot;method引数は+, -, *, /のみ使用可能です。&quot;) ) } このコードの中身をみてみましょう。重要なのは2行目から8行目の部分です。switch()文の最初の引数は条件を判定する長さ1のベクトルです。ここではこれがmethod引数となります。そして、method引数によって異なる処理を行うわけです。\"+\" = x + yは「methodの値が\"+\"の場合、x + yを実行する」ことを意味します。これを他の演算子に対しても指定します。最後の引数は条件に合っていない場合の処理内容です。ここでは\"method引数は+, -, *, /のみ使用可能です。\"というメッセージを出力させ、関数を中止させるという意味で、stop(\"method引数は+, -, *, /のみ使用可能です。\")を入れました。 むろん、以上のコードはif()文を使うことも可能です。 myCalc &lt;- function(x, y, method) { if (method == &quot;+&quot;) { return(x + y) } else if (method == &quot;-&quot;) { return(x - y) } else if (method == &quot;*&quot;) { return(x * y) } else if (method == &quot;/&quot;) { return(x / y) } else { stop(&quot;method引数は+, -, *, /のみ使用可能です。&quot;) } } また、match.arg()関数を使って事前に使える引数を指定しておき、該当しない場合は関数の処理を中止させることもできます。基本的には上の書き方より以下の書き方が推奨されます。 myCalc &lt;- function(x, y, method = c(&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;)) { method &lt;- match.arg(method) if (method == &quot;+&quot;) { return(x + y) } else if (method == &quot;-&quot;) { return(x - y) } else if (method == &quot;*&quot;) { return(x * y) } else { return(x / y) } } 異なる点はfunction()の中にmethodのデフォルト値をベクトルとしてした点です。これは「method引数はこれらの値以外は許さない」ということを意味します。むろん、普通のデフォルト値としてベクトルを指定することも可能ですが、このような使い方もあります。そしてmatch.arg()関数についてですが、これはmethod引数が予め指定されていた引数の値と一致するか否かを判断する関数です。もし、予め指定されていた引数と一致しない場合、エラーを表示させ、処理を中断します。ちなみに、match.arg()はswith()文と組み合わせて使うことも可能です。。 今回の例の場合、switch()文の方が読みやすいコードですが、if()でも十分に使えます。また、条件によって行う処理が複雑な場合はswitch()よりもif()の方が使いやすいです。 myCalc(5, 3, &quot;+&quot;) ## [1] 8 myCalc(5, 3, &quot;-&quot;) ## [1] 2 myCalc(5, 3, &quot;*&quot;) ## [1] 15 myCalc(5, 3, &quot;/&quot;) ## [1] 1.666667 それでは\"+\"、\"-\"、\"*\"、\"/\"以外の値をmethodに与えたらどうなるでしょうか。ここでは\"^\"を入れてみましょう。 myCalc(5, 3, &quot;^&quot;) ## Error in myCalc(5, 3, &quot;^&quot;): method引数は+, -, *, /のみ使用可能です。 stop()内に書いたエラーメッセージが表示され、処理は中止されます。 9.4.4 上級者向け apply()群 map() 9.5 関数の作成 これまでclass()や、sum()、print()など様々な関数を使ってきました。関数は関数名(引数)の書き方をします。関数とは()内の引数のデータを関数内部の手続きに沿って処理し、その結果を返す関数です。したがって、関数は「データだけ違って、同じ処理を行いたい」場合に非常に便利です。 ベクトルc(1, 2, 3, 4, 5)の総和を計算する方法について考えてみましょう。まず、1つ目は単純に足し算をする方法があります。 1 + 2 + 3 + 4 + 5 ## [1] 15 他にも反復処理を使うことも可能です。とりわけ、1:100のようなベクトルを1つ目の方法で記述するのは時間の無駄でしょう。for()文を使った方法は以下のようになります。 Result &lt;- 0 for (i in 1:5) { Result &lt;- Result + i } Result ## [1] 15 数個の数字を足すだけなら方法1の方が楽でしょうし、数百個の数字の場合は方法2の方が効率的です。それでもやはりsum()関数の方が数倍は効率的です。また、関数を使うことで、スクリプトの量をへらすこともできます。1から100までの総和なら、方法2のfor (i in 1:5)をfor (i in 1:100)に変えることで対応可能ですが、それでも全体としては数行のコードで書かなくてもなりません。一方、sum(1:100)なら一行で済みます。 sum()はまだマシな方です。たとえば、回帰分析をしたい場合、毎回回帰分析のコードを一から書くのはあまりにも非効率的です。lm()関数を使うと、データや回帰式などを指定するだけで、一連の作業を全て自動的に行い、その結果を返してくれます。中には回帰式の係数も計算してくれますが、他にも残差や決定係数なども計算してくれます。その意味で、lm()という関数は複数の機能を一つの関数としてまとめたものでもあります。 これらの関数は既にR開発チームが書いた関数ですが、ユーザー側から関数を作成することも可能です。長いコードを書く、同じ作業を繰り返す場合、関数の作成はほぼ必須とも言えます。ここではまず、簡単な関数を作成してみましょう。与えられた数字を二乗し、その結果を返すmyPower()関数を作ってみましょう。 myPower &lt;- function(x) { x^2 } # 引数が一つしかないので、myPower(24)も可能 myPower(x = 24) ## [1] 576 それではコードを解説します。関数は以下のように定義されます。 関数名 &lt;- function (引数名) { 処理内容 } まず、関数名をmyPowerとし、それが関数であることを宣言します。そして、この関数の引数の名前はxとします。それが myPower &lt;- function (x) の部分です。続いて、{}内に処理内容を書きます。今回はx^2であり、これはxの2乗を意味します。そして、関数の処理結果が返されますが、{}内の最後の行が結果として返されます。x^2の部分はreturn(x^2)と書き換えることも可能です。return()は「この結果を返せよ」という意味の関数ですが、返す結果が最後の行である場合、省略可能であり、Hadely先生もこのような書き方を推奨しています。 それでは、もうちょっと複雑な関数を作成してみましょう。ベクトルを引数とし、その和を計算するmySum()という関数です。要するにsum()関数を再現したものです。 # mySum関数を定義し、引数はxのみとする mySum &lt;- function(x) { # 結果を格納するベクトルResultを生成し、0を入れておく Result &lt;- 0 # xの要素をiに一つずつ入れながら反復処理 for (i in x) { # Resultに既存のResultの値にiを足した結果を上書きする Result &lt;- Result + i } # Resultを返す Result } mySum(1:5) ## [1] 15 普通のsum()関数と同じ動きをする関数が出来上がりました。よく見ると、上で説明した総和を計算する方法2のコードを丸ごと関数内に入っているだけです。変わったところがあるとすれば、for()文であり、for (i in 1:5)がfor (i in x)に変わっただけです。ここのxはmySum &lt;- function (x)のxを意味します。このように関数を一回作成しておくと、これからは総和を出す作業を1行に短縮することができます。 このmySum()ですが、一つ問題があります。それはxに欠損値が含まれている場合、結果がNAになることです。 mySum(c(1, 2, 3, NA, 5)) ## [1] NA 実際、R内蔵関数であるsum()も同じですが、sum()にはna.rm =というもう一つの引数があり、これをTRUEにすることで欠損値を除いた総和が計算できます。つまり、関数は複数の引数を持つことができます。それでは、mySum()を改良してみましょう。ここにもna.rmという関数を追加し、na.rm引数がTRUEの場合、xから欠損値を除いた上で総和を計算するようにしましょう。 mySum &lt;- function(x, na.rm = FALSE) { if (na.rm == TRUE) { x &lt;- x[!is.na(x)] } Result &lt;- 0 for (i in x) { Result &lt;- Result + i } Result } mySum(c(1, 2, 3, NA, 5)) ## [1] NA mySum(c(1, 2, 3, NA, 5), na.rm = FALSE) ## [1] NA mySum(c(1, 2, 3, NA, 5), na.rm = TRUE) ## [1] 11 変わったところは、まずfunction (x)がfunction (x, na.rm = FALSE)になりました。これはxとna.rmの引数が必要であるが、na.rmのデフォルト値はFALSEであることを意味します。デフォルト値が指定されている場合、関数を使用する際、その引数は省略できます。実際、sum()関数のna.rm引数もFALSEがデフォルトとなっており、省略可能となっています。 次は最初に条件分岐が追加されました。ここではna.rmがTRUEの場合、xから欠損値を抜いたベクトルをxに上書きするように指定しました。もし、FALSEならこの処理は行いません。 これでR開発チームが作成したsum()関数と同じものが出来上がりました。それでは引数の順番について簡単に解説し、もうちょっと複雑な関数を作ってみましょう。引数の順番は基本的にfunction()の()内で定義した順番であるなら、引数名を省略することも可能です。 mySum(c(1, 2, 3, NA, 5), TRUE) ## [1] 11 ただし、順番を逆にすると、以下のようにわけのわからない結果が返されます。 mySum(TRUE, c(1, 2, 3, NA, 5)) ## Warning in if (na.rm == TRUE) {: 条件が長さが 2 以上なので、最初の 1 つだけが使われます ## [1] 1 任意の順番で引数を指定する場合、引数名を指定する必要があります。 mySum(na.rm = TRUE, x = c(1, 2, 3, NA, 5)) ## [1] 11 自分で関数を作成し、他の人にも使ってもらう場合、引数名、順番、デフォルト値を適切に設定しておくことも大事です。 ちょっと複雑な関数を作ってみよう それではちょっとした遊び心を込めた関数を作ってみましょう。その名もドラクエ戦闘シミュレーターです。 以下はドラクエ11のダメージ公式です。 ダメージの基礎値 = (攻撃力 / 2) - (守備力 / 4) 0未満の場合、基礎値は0とする ダメージの幅 = (ダメージの基礎値 / 16) + 1 端数は切り捨てます (floor()関数使用) ダメージの最小値は「ダメージの基礎値 - ダメージの幅」、最大値は「ダメージの基礎値 - ダメージの幅」となります。この最小値が負になることもありますが、その場合は0扱いになります。実際のダメージはこの範囲内でランダムに決まります (runif()関数使用)。 # DQ_Attack関数を定義 DQ_Attack &lt;- function(attack, defence, hp, enemy) { ## 引数一覧 ## attack: 勇者の力 + 武器の攻撃力 (長さ1の数値型ベクトル) ## defence: 敵の守備力 (長さ1の数値型ベクトル) ## hp: 敵のHP (長さ1の数値型ベクトル) ## enemy: 敵の名前 (長さ1の文字型ベクトル) # ダメージの基礎値 DefaultDamage &lt;- (attack / 2) - (defence / 4) # ダメージの基礎値が負の場合、0とする DefaultDamage &lt;- ifelse(DefaultDamage &lt; 0, 0, DefaultDamage) # ダメージの幅 DamageWidth &lt;- floor(DefaultDamage / 16) + 1 # ダメージの最小値 DamageMin &lt;- DefaultDamage - DamageWidth # ダメージの最小値が負の場合、0とする DamageMin &lt;- ifelse(DamageMin &lt; 0, 0, DamageMin) # ダメージの最大値 DamageMax &lt;- DefaultDamage + DamageWidth # 敵の残りHPを格納する CurrentHP &lt;- hp # 残りHPが0より大きい場合、以下の処理を繰り返す while (CurrentHP &gt; 0) { # ダメージの最小値から最大値の間の数値を1つ無作為に抽出する Damage &lt;- runif(n = 1, min = DamageMin, max = DamageMax) # 小数点1位で丸める Damage &lt;- round(Damage, 0) # 残りのHPを更新する CurrentHP &lt;- CurrentHP - Damage # メッセージを表示 print(paste0(enemy, &quot;に&quot;, Damage, &quot;のダメージ!!&quot;)) } # 上記の反復処理が終わったら勝利メッセージを出力 paste0(enemy, &quot;をやっつけた！&quot;) } 初めて見る関数が3つありますね。まず、floor()関数は引数の端数は切り捨てる関数です。たとえば、floor(2.1)もfloor(2.6)も結果は2です。続いて、runif()関数は指定された範囲の一様分布から乱数を生成する関数です。引数は生成する乱数の個数 (n)、最小値 (min)、最大値 (max)の3つです。runif(5, 3, 10)なら最小値3、最大値10の乱数を5個生成するという意味です。正規分布は平均値周辺の値が生成されやすい一方、一様分布の場合、ある値が抽出される確率は同じです。最後にround()関数は四捨五入の関数です。引数は2つあり、1つ目の引数は数値型のベクトルです。2つ目は丸める小数点です。たとえば、round(3.127, 1)の結果は3.1であり、round(3.127, 2)の結果は3.13となります。 それでは「ひのきのぼう」を装備したレベル1の勇者を考えてみましょう。ドラクエ5の場合、Lv1勇者の力は11、「ひのきのぼう」の攻撃力は2ですので、攻撃力は13です。まずは定番のスライムから狩ってみましょう。スライムのHPと守備力は両方7です。 DQ_Attack(13, defence = 7, hp = 7, &quot;スライム&quot;) ## [1] &quot;スライムに5のダメージ!!&quot; ## [1] &quot;スライムに4のダメージ!!&quot; ## [1] &quot;スライムをやっつけた！&quot; まぁ、こんなもんでしょう。それではスライムナイト (=ピエール)はどうでしょう。スライムナイトのHPのは40、守備力は44です。 DQ_Attack(13, defence = 44, hp = 40, &quot;スライムナイト&quot;) ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに0のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトに1のダメージ!!&quot; ## [1] &quot;スライムナイトをやっつけた！&quot; これだと「なんと スライムナイトが おきあがりなかまに なりたそうに こちらをみている！」のメッセージを見る前に勇者ご一行が全滅しますね。エスターク (HP: 9000 / 守備力: 250)は計算するまでもないでしょう… 以上の関数に条件分岐を追加することで「かいしんの いちげき！」を入れることもできますし51、逆に敵からの攻撃を計算して誰が先に倒れるかをシミュレーションすることも可能でしょうね。色々遊んでみましょう。 9.5.1 関数 in 関数 当たり前かも知れまっせんが、自作関数を他の自作関数に含めることもできます。ここでは乱数を生成する関数を作ってみましょう。パソコンだけだと完全な乱数を作成することは不可能ですが52、乱数に近いものは作れます。このようにソフトウェアで生成された乱数は擬似乱数と呼ばれ、様々なアルゴリズムが提案されています。天才、フォン・ノイマン大先生も乱数生成では天才ではなかったらしく、彼が提案した平方採中法 (middle-square method)は使い物になりませんので、ここではもうちょっとマシな方法である線形合同法 (linear congruential generators; 以下、LCG)を採用します。平方採中法よりは式が複雑ですが、それでも非常に簡単な式で乱数が生成可能であり、Rによる実装に関しては平方採中法より簡単です。ちなみに、線形合同法にも様々な問題があり、Rのデフォルトは広島大学の松本眞先生と山形大学の西村拓士先生が開発しましたメルセンヌ・ツイスタ (Mersenne twister)を採用しています。それでは、LCGのアルゴリズムから見ましょう。 乱数の列があるとし、\\(n\\)番目の乱数を\\(X_n\\)とします。この場合、\\(X_{n+1}\\)は以下のように生成されます。 \\[ X_{n+1} = (aX_n + c) \\text{ mod } m \\] \\(\\text{mod}\\)は余りを意味し、\\(5 \\text{mod} 3\\)は5を3で割った際の余りですので、2となります。\\(a\\)と\\(c\\)、\\(m\\)は以下の条件を満たす任意の数です。 \\[\\begin{align} 0 &lt; &amp; m, \\\\ 0 &lt; &amp; a &lt; m, \\\\ 0 \\leq &amp; c &lt; m. \\end{align}\\] ベストな\\(a\\)、\\(c\\)、\\(m\\)も決め方はありませんが、ここではTurbo Cの設定を真似て\\(a = 22695477\\)、\\(c = 1\\)、\\(m = 2^{32}\\)をデフォルト値として設定します53。そして、もう一つ重要なのが最初の数、つまり\\(X_n\\)をどう決めるかですが、これは自由に決めて問題ありません。最初の数 (\\(X_0\\))はシード (seed)と呼ばれ、最終的には使わない数字となります。それではseedという引数からある乱数を生成する関数rng_number()を作ってみましょう。 rng_number &lt;- function(seed, a = 22695477, c = 1, m = 2^32) { (a * seed + c) %% m } 簡単な四則演算のみで構成された関数ですね。ちなみに%%は余りを計算する演算子です。とりあえず、seedを12345に設定し、一つの乱数を生成してみましょう。 rng_number(12345) ## [1] 1002789326 かなり大きい数字が出ました。ちなみに線形合同法で得られる乱数の最大値は\\(m\\)、最小値は0です。次は、今回得られた乱数1.002789310^{9}を新しいseedとし、新しい乱数を作ってみましょう。 rng_number(1002789326) ## [1] 3785644968 この作業を繰り返すと、(疑似)乱数の数列が得られます。続いて、この作業をn回繰り返し、長さnの乱数ベクトルを返す関数LCGを作ってみましょう。いかがコードになります。 LCG &lt;- function(n, seed, a = 22695477, c = 1, m = 2^32) { rng_vec &lt;- rep(NA, n + 1) # seedも入るので長さn+1の空ベクトルを生成 rng_vec[1] &lt;- seed # 1番目の要素にseedを入れる # iに2からn+1までの値を順次的に投入しながら、反復処理 for (i in 2:(n+1)) { # rng_vecのi番目にi-1番目の要素をseedにした疑似乱数を格納 rng_vec[i] &lt;- rng_number(rng_vec[i - 1], a, c, m) } rng_vec &lt;- rng_vec[-1] # 1番目の要素 (seed)を捨てる rng_vec &lt;- rng_vec / m # 最小値0、最大値1になるように、mで割る rng_vec # 結果を返す } それでは、詳細に解説します。 1行目: 関数LCGを定義し、必要な引数としてnとseedを設定する。 2行目: 結果を格納する空ベクトルrng_vecを生成。ただし、1番目にはseedが入るので、長さをn+1とする。 3行目: rng_vecの1番目にseedを格納する。 6行目: 疑似乱数をn回生成し、格納するように反復作業を行う。任意の変数はiとし、iに代入される値は2からn+1までである。 8行目: rng_vecのi-1番目要素をseedにした疑似乱数を生成し、rng_vecのi番目に格納する。1回目の処理だとi=2であるため、rng_vec[1] (= seed)をseedにした疑似乱数が生成され、rng_vec[2]に格納される。 11行目: rng_vecの1番目の要素はseedであるため、捨てる。 12行目: 乱数が最小値0、最大値1になるように、調整する。具体的には得られた乱数をm (デフォルトは\\(2^{32}\\))で割るだけである。 14行目: 結果ベクトルを返す。 それでは、seedを19861008とした疑似乱数10000個を生成し、LCG_Numbersという名のベクトルに格納してみましょう。結果を全て表示させるのは無理があるので、最初の20個のみを確認してみます。 LCG_Numbers &lt;- LCG(10000, 19861008) head(LCG_Numbers, 20) ## [1] 0.58848246 0.09900449 0.21707060 0.89462981 0.23421890 0.72341249 0.55965400 ## [8] 0.59552685 0.96594972 0.69050965 0.98383344 0.20136551 0.25856502 0.37569497 ## [15] 0.50086451 0.03986446 0.89291806 0.24760102 0.27912510 0.24493750 正直、これが乱数かどうかは見るだけでは分かりませんね。簡単な確認方法としては、これらの乱数列のヒストグラムを見れば分かります。得られた数列が本当に乱数(に近いもの)なら、その分布は一様分布に従っているからです。ただし、一様分布に従っていることが乱数を意味するものではありません。 可視化については第14章で解説しますが、ここでは簡単にhist()関数を使ってみましょう。必要な引数はnumeric型のベクトルのみです。以下のコードにあるxlab =などはラベルを指定する引数ですが、省略しても構いません。 hist(LCG_Numbers, xlab = &quot;乱数&quot;, ylab = &quot;度数&quot;, main = &quot;生成された乱数10000個のヒストグラム&quot;) ややギザギザしているように見えますが54、これなら一様分布だと考えて良いでしょう。 9.6 練習問題 問1 3つの6面サイコロ投げを考える。3つの目の和が15になるまでサイコロ投げを繰り返す。どのような目が出て、その合計はいくつか。そして、何回目のサイコロ投げかを出力すること。以下はその例である。 以下の問題をfor()、while()を用いてコードを書くこと。どれも同じ形の結果が得られることを確認した上で、どの方法がより効率的か考察せよ。 ## [1] &quot;1目のサイコロ投げの結果: 4, 2, 6 (合計: 12)&quot; ## [1] &quot;2目のサイコロ投げの結果: 5, 4, 1 (合計: 10)&quot; ## [1] &quot;3目のサイコロ投げの結果: 5, 6, 4 (合計: 15)&quot; 問2 以下のような長さ5の文字型ベクトルCauseがある。「肥満の原因はXXでしょう。」というメッセージを出力し、「XX」の箇所にそれぞれの要素を代入すること。出力されるメッセージは5個でなければならない。 Cause &lt;- c(&quot;喫煙&quot;, &quot;飲酒&quot;, &quot;食べすぎ&quot;, &quot;寝不足&quot;, &quot;ストレス&quot;) ## [1] &quot;肥満の原因は喫煙でしょう。&quot; ## [1] &quot;肥満の原因は飲酒でしょう。&quot; ## [1] &quot;肥満の原因は食べすぎでしょう。&quot; ## [1] &quot;肥満の原因は寝不足でしょう。&quot; ## [1] &quot;肥満の原因はストレスでしょう。&quot; 長さ4の文字型ベクトルEffectが与えられた。続いて、「YYの原因はXXでしょう。」というメッセージを出力し、「YY」にはEffectの要素を、「XX」にはCauseの要素を代入すること。出力されるメッセージは20個でなければならない。 Effect &lt;- c(&quot;肥満&quot;, &quot;ハゲ&quot;, &quot;不人気&quot;, &quot;金欠&quot;) 長さ3の文字型ベクトルSolutionが与えられた。続いて、「YYの原因はXXですが、ZZ改善されるでしょう。」というメッセージを出力し、「YY」にはEffectの要素を、「XX」にはCauseの要素を、「ZZ」にはSolutionの要素を代入すること。出力されるメッセージは60個でなければならない。 Solution &lt;- c(&quot;この薬を飲めば&quot;, &quot;一日一麺すれば&quot;, &quot;Songに100万円振り込めば&quot;) 問3 長さ2のnumericベクトルDataについて考える。条件分岐を用いてDataの1番目の要素 (Data[1])が2番目の要素 (Data[2])より大きい場合、1番目の要素と2番目の順番を逆転させる条件分岐を作成せよ。たとえば、Data &lt;- c(5, 3)なら、条件分岐後のDataの値がc(3, 5)になること。 問4 問3ではベクトルの1番目要素と2番目の要素を比較し、前者が大きい場合において順番を入れ替える条件分岐を行った。これを長さ3以上のベクトルにも適用したい。長さ4のnumeric型ベクトルDataがある場合の計算手順について考えてみよう。 Data[1]とData[2]の要素を比較し、Data[1] &gt; Data[2]の場合、入れ替える。 Data[2]とData[3]の要素を比較し、Data[2] &gt; Data[3]の場合、入れ替える。 Data[3]とData[4]の要素を比較し、Data[3] &gt; Data[4]の場合、入れ替える。この段階でData[4]はDataの最大値が格納される。 続いて、Data[1]とData[2]の要素を比較し、Data[1] &gt; Data[2]の場合、入れ替える。 Data[2]とData[3]の要素を比較し、Data[2] &gt; Data[3]の場合、入れ替える。この段階でData[3]にはDataの2番目に大きい数値が格納される。 最後にData[1]とData[2]の要素を比較し、Data[1] &gt; Data[2]の場合、入れ替える。ここで並び替えは終了 ヒント: 2つのfor()文が必要となる。これは「バブルソート」と呼ばれる最も簡単なソートアルゴリズムである。イメージとしては、長さNのベクトルの場合、n番目の要素とn+1番目の要素を比較しながら、大きい方を後ろの方に追い込む形である。最初は、Data[4]最後の要素に最大値を格納し、続いて、Data[3]に次に大きい数値を、Data[2]に次に大きい数値を入れる仕組みである。 最初はData[1]とData[2]、Data[2]とData[3]、Data[3]とData[4]の3ペアの比較を行う。 続いて、Data[1]とData[2]、Data[2]とData[3]の2ペアの比較を行う 最後に、Data[1]とData[2]の1ペアの比較を行う つまり、外側のfor()文は「Dataの長さ-1」回繰り返すことになる。 内側のfor()文は3, 2, 1ペアの比較を行うことになる。 問5 「問4」の練習問題で作成したコードを関数化せよ。関数名はmySort()であり、引数は長さ2以上のnumeric型ベクトルのみである。引数名は自由に決めても良いし、dataやxなどを使っても良い。 問6 既に作成したDQ_Attack関数を修正してみよう。今の関数は通常攻撃のみであるが、稀に「会心の一撃」が発生するように修正する。 会心の一撃が発生する確率は1/32とする (Hint: 0から1の間の乱数を生成し、その乱数が1/32以下であるか否かで条件分岐させる)。乱数の生成はrunif()または、自作関数のLCG()でも良い。 会心の一撃のダメージの最小値は攻撃力の95%、最大値は105%とする。 会心の一撃が発生したら、\"かいしんのいちげき! スライムに10のダメージ!!\"のようなメッセージを出力させること。 問7 与えられたベクトルxからn個の要素を無作為に抽出する関数、mySample()を定義せよ。mySample()の引数はxとn、seedとし、xは長さ1以上のベクトルとする。nは長さ1の整数型ベクトルである。 以下の場合、エラーメッセージを出力し、処理を中止させること。 nとseedが長さ1ベクトルでない場合、 seedがnumeric型でない場合 nが整数でない場合 (floor(n) == nで判定) ヒント: LCG()関数を用いて乱数を生成した場合、生成された擬似乱数は0以上1以下である。ベクトルxの長さをlength(x)とした場合、擬似乱数にlength(x)を掛けると、擬似乱数は0以上length(x)以下になる。これらの値を切り上げると (ceiling()関数)、その値は1以上length(x)以下の整数となる。 実はチューリング完全 (Turing-complete)な言語の条件に分岐はありません。ifとgotoの条件分岐さえあれば、ループも実行可能だからです。その意味でプログラミングを構成する最小単位は代入と条件分岐のみかも知れませんね。↩︎ プログラミング教育においてこのソートのアルゴリズムは定番中の定番であり、様々なアルゴリズムがあります。↩︎ 実はRはOOPの実装するためにS3クラスをデフォルトで採用していますが、これはオブジェクト指向プログラミング言語としては厳密性に欠いている面があります。ただし、S4やR6などはもうちょっと現代的なOOPに近い感覚でOOPを実装することができます。↩︎ 厳密に言えば、tibble型データ構造は3つのクラスを有しており、その中にdata.frameが含まれています。↩︎ -は引き算の意味にもなるため、統計・データ分析に特化したRとしてはあまり、相性がよくないでしょう。しかし、COBOLやLISPのような言語では一般的に使われる方法です。↩︎ paste()関数を使うと、空白ありで繋ぎます。↩︎ しかし、for()文をあまりにも多く重ねるとコードの可読性が著しく低下しますので、注意しましょう。この場合は反復処理を行う自作関数を作成することで対応できます。↩︎ 長さ1の数値型ベクトルにも使えますが、実際に使われる例はあまりありません。↩︎ 一般的に会心の一撃が出る確率は約3.125% (=1/32)または約1.563% (=1/64)と言われています。↩︎ 特殊なハードウェアを使えば周囲の雑音や電波などのノイズから乱数を生成することも可能です。↩︎ ANSI C標準の場合、\\(a = 1103515245\\)、\\(c = 12345\\)、\\(m = 2^{31}\\)です。↩︎ 1万個ではなく、100万個、1億個など乱数を生成すればするほど、一様分布に近づきます。↩︎ "],
["datahandling1.html", "10. データハンドリング [基礎編: 抽出] 10.1 データハンドリングとtidyverse 10.2 パイプ演算子 (%&gt;%) 10.3 列の抽出 10.4 行の抽出 10.5 行のソート 10.6 練習問題", " 10. データハンドリング [基礎編: 抽出] ここでは比較的綺麗に整形されているデータフレームを扱う方法について考えます。ここでいう「比較的綺麗なデータ」とは、すぐに分析に使えるレベルのデータを意味します。したがって、ここではデータ内の値を変更するような作業は行いません。基本的に分析しやすくなるように列の順番を替えたり、特定の列や行のみを抽出したり、データの順番を並び替える作業に注目します。 本性では以下の3つの内容を中心に解説します。 パイプ演算子 (%&gt;%)に慣れる 特定の行と列の抽出 データのソート 本章で学習する内容でデータを加工した場合、得られる結果物は元のデータの一部 (subset)となります。データの中身の値を変えたり、新しい列を追加したり、平均値などの記述統計量をまとめたりする方法については次の第11章で解説します。 10.1 データハンドリングとtidyverse The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures. (Tidyverseホームページから) Tidyverseとはデータサイエンスのために考案された、強い信念と思想に基づいたRパッケージの集合です。Tidyverseに属するパッケージは思想、文法およびデータ構造を共有しています。Tidyverseの中核をなすパッケージはggplot2(第14章)、dplyr(第10、11章)、tidyr(第13章)、readr(第6.5章)、purrr (第??章)、tibble(第8.4章)、stringr (第16章)、forcats (第12章)があり、このパッケージを支える数十のパッケージが含まれています。これらのパッケージは個別に読み込む必要はなく、tidyverseパッケージを読み込むだけで十分です。 library(tidyverse) Rにおけるデータハンドリング (データ操作)の標準がdplyrとtidyr中心となり、文字列の処理はstringr、factor型の操作はforcats、大量のモデルを自動的に分析し、結果を処理するためにはtibbleとpurrr、可視化はggplot2が主に使われています。これらのパッケージ間、あるいはパッケージ内におけるオブジェクトのやり取りは全てパイプ演算子を通じて行われています。また、これらのパッケージは整然データ (tidydata)を想定するか、整然データの作成するに特化しています。 tidyverseの思想に基づいた「tidyverse流のコーディング」は現在のRそのものと言っても過言ではありません。ただし、tidyverseじゃないと出来ないデータハンドリング、可視化などはありません。tidyverseはデータサイエンスの思想に近いものであり、「異なる思想を持っているからこのような分析はできない」といったものはありません。tidyverseという概念が提唱される前にもRは存在し、tidyverse無き世界で今と同じことをやってきました。ただし、tidyverse流で書かれたRコードは可読性が優れ、コードを書く手間も短くなります。tidyverseの考え方がRのける「標準語」として定着しつつあるのは否めない事実であり、学習する誘引としては十分すぎるでしょう。 10.2 パイプ演算子 (%&gt;%) dplyrパッケージを利用する前にパイプ演算子について説明します。パイプ演算子はdplyrに含まれている演算子ではなく、magrittrという別のパッケージから提供される演算子ですが、tidyverseパッケージを読み込むと自動的に読み込まれます。パイプ演算子はx %&gt;% y()のような書き方となりますが、これは「xをy()の第一引数として渡す」ことを意味します。xの部分はベクトルやデータフレームのようなオブジェクトでも、関数でも構いません。なぜなら、関数から得られた結果もまたベクトルやデータフレームといったものになるからです。つまり、x() %&gt;% y()という使い方も可能です。そして、パイプは無限に繋ぐこともできます。「データdfを関数x()で処理をし、その結果をまた関数y()で処理する」ことは、パイプを使うとdf %&gt;% x() %&gt;% y()のような書き方となります。 たとえば、「paste(3, \"+\", 5, \"=\", 8)を実行し、その結果をrep()関数を使って3回複製し、それをprint()を使って出力する」コードを考えてみましょう。方法としては2つ考えられます。まずは、それぞれの処理を別途のオブジェクトに格納する方法です。そして二つ目は関数の中に関数を使う方法です。 # 方法1: 一関数一オブジェクト Result1 &lt;- paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) Result2 &lt;- rep(Result1, 3) print(Result2) ## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; # 方法2: 関数の中に関数の中に関数 print(rep(paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8), 3)) ## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; どれも結果は同じです。コードを書く手間を考えれば、後者の方が楽かも知れませんが、可読性があまりよくありません。一方、前者は可読性は良いものの、コードも長くなり、オブジェクトを2つも作ってしまうのでメモリの無駄遣いになります。 コードの可読性と書く手間、両方を満足する書き方がパイプ演算子%&gt;%です。まずは、例から見ましょう。 # %&gt;%を使う paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) %&gt;% rep(3) %&gt;% print() ## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; まず、結果は先ほどと同じです。それではコードの説明をしましょう。まずは、paste(3, \"+\", 5, \"=\", 8)を実行します。そしてその結果をそのままrep()関数の第一引数として渡されます。つまり、rep(paste(3, \"+\", 5, \"=\", 8), 3)になるわけです。ここではrep(3)と書きましたが、第一引数が渡されたため、3は第二引数扱いになります (パイプ演算子前のオブジェクトを第二、三引数として渡す方法は適宜説明します。)。そして、これをまたprint()関数に渡します。結果としてはprint(rep(paste(3, \"+\", 5, \"=\", 8), 3))となります。 関数を重ねると読む順番は「カッコの内側から外側へ」になりますが、パイプ演算子を使うと「左 (上)から右 (下)へ」といったより自然な読み方が可能になります。また、以下のコードのように、パイプ演算子後に改行を行うことでより読みやすいコードになります。これからはパイプ演算子の後は必ず改行をします。 # 改行 (+字下げ)したらもっと読みやすくなる paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) %&gt;% rep(3) %&gt;% print() パイプ演算子を使わない方法は図10.1のようにイメージできます。一回の処理ごとに結果を保存し、それをまた次の処理時においてデータとして使うイメージです。 図 10.1: パイプ演算子を使わない場合 一方、図10.2はパイプ演算子を使う場合のプロセスです。処理後の結果を保存せず、すぐに次のプロセスに渡すことで、メモリ (図だとボウル)や時間、コードの無駄を減らすことができます。むろん、図10.1の結果1を使って色々試してみたい場合は、一旦結果1までは格納し、適宜引き出して使った方が効率的でしょう。パイプ演算子はたしかに便利で、「今どき」のRの書き方を象徴するようなものですが、一つの結果を出すまであまりにも多くのパイプ演算子を使うことはあ望ましくありません。 図 10.2: パイプ演算子を使う場合 データハンドリングもこれど同様に、様々な作業を順に沿って行う必要があります。例えば、「(1) 列を選択して、(2) 欠損値を含む列を除去して、 (3) ある変数の値を100倍にして、(4) ある変数の値がが小さい行から大きい順へ並び替える」といった手順です。これらの作業はパイプ演算子を使えば、スムーズに行うことが可能です。 10.3 列の抽出 それでは今回の実習用データを読み込みましょう。Ramen.csvには「ぐるなび」から取得したラーメン屋6292店舗の情報が入っています。具体的には東京、神奈川、千葉、埼玉、大阪、京都、兵庫、奈良、和歌山それぞれ都府県にあるラーメン屋の中から最大1000店舗の情報を抽出したものです。東京都は、ぐるなびに登録したラーメン屋が3000店舗以上ですが、1000店舗の基準はぐるなびの「おすすめ」の順で上位1000店舗となります。また、店側またはぐるなびが登録したカテゴリを基準に抽出したため、実際はラーメン屋ではないにもかかわらずラーメン屋としてデータ内に含まれている可能性があります。 まず、このデータを読み込み、dfという名付けます。 df &lt;- read_csv(&quot;Data/Ramen.csv&quot;) ## Parsed with column specification: ## cols( ## ID = col_character(), ## Name = col_character(), ## Pref = col_character(), ## Zipcode = col_double(), ## Latitude = col_double(), ## Longitude = col_double(), ## Line = col_character(), ## Station = col_character(), ## Walk = col_double(), ## Bus = col_double(), ## Car = col_double(), ## Budget = col_double(), ## ScoreN = col_double(), ## Score = col_double() ## ) データの中身を確認してみましょう。 df ## # A tibble: 6,292 x 14 ## ID Name Pref Zipcode Latitude Longitude Line Station Walk Bus Car Budget ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 東京都… 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 ## 2 gfeb… 本格上海… 東京都… 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA NA 2000 ## 3 ggt5… 食べ飲み… 東京都… 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA NA 2980 ## 4 g181… 博多餃子… 東京都… 1920904 35.7 139. ＪＲ 八王子駅… 1 NA NA 2000 ## 5 ggww… まさ屋 … 東京都… 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA NA 380 ## 6 gdzk… 完全個室… 東京都… 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 ## 7 ga2g… 鶏そば … 東京都… 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA NA 850 ## 8 gg9m… 宴会個室… 東京都… 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA NA 2000 ## 9 gdvk… 中国料理… 東京都… 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA NA 1000 ## 10 gggb… 中国料理… 東京都… 1140002 35.8 140. 地下鉄南… 王子駅 2 NA NA 2000 ## # … with 6,282 more rows, and 2 more variables: ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; 1行目の# A tibble: 2,000 x 12から、ケース数 (店舗数)は2000、変数は12個あることが分かります。各変数の詳細は以下の通りです。 変数名 説明 ID 店舗ID Name 店舗名 Pref 店舗の所在地 (都府県) Zipcode 店舗の郵便番号 Latitude 緯度 Longitude 経度 Line 最寄りの駅の路線 Station 最寄りの駅 Walk 最寄りの駅からの距離 (徒歩; 分) Bus 最寄りの駅からの距離 (バス; 分) Car 最寄りの駅からの距離 (車; 分) Budget 平均予算 (円) ScoreN 口コミの数 Score 口コミ評価の平均値 それではここからはdfを用いたdplyrの様々な機能を紹介していきます。 10.3.1 特定の列を抽出する まずは、データフレームから特定の列のみを残す、除去する方法について紹介します。たとえば、dfからID、Name、Pref、Scoreのみを残すとします。dplyrを使わない方法とdplyrのselect()関数を使った方法を紹介します。 # dplyrを使わない方法 df[, c(&quot;ID&quot;, &quot;Name&quot;, &quot;Pref&quot;, &quot;Score&quot;)] ## # A tibble: 6,292 x 4 ## ID Name Pref Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA ## 5 ggww100 まさ屋 渋谷店 東京都 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 東京都 NA ## 7 ga2g202 鶏そば きらり 東京都 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 3.33 ## 9 gdvk200 中国料理 宝龍 東京都 2.5 ## 10 gggb200 中国料理 天安門 東京都 NA ## # … with 6,282 more rows # dplyr::select()を使う方法 # select(df, ID, Name, Pref, Score)でもOK df %&gt;% select(ID, Name, Pref, Score) ## # A tibble: 6,292 x 4 ## ID Name Pref Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA ## 5 ggww100 まさ屋 渋谷店 東京都 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 東京都 NA ## 7 ga2g202 鶏そば きらり 東京都 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 3.33 ## 9 gdvk200 中国料理 宝龍 東京都 2.5 ## 10 gggb200 中国料理 天安門 東京都 NA ## # … with 6,282 more rows どれも結果は同じですが、select()関数を使った方がより読みやすいコードになっているでしょう。むろん、select()関数を使わない方がスッキリする方も知るかも知れません。実際、自分でパッケージなどを作成する際はselect()を使わない場合が多いです。ただし、一般的な分析の流れではselect()の方がコードも意味も明確となり、パイプ演算子でつなぐのも容易です。 select()関数の使い方は非常に簡単です。第一引数はデータフレームですが、パイプ演算子を使う場合は省略可能です。第二引数以降の引数はデータフレームの変数名です。つまり、ここには残す変数名のみを書くだけで十分です。 また、select()関数を使って列の順番を変えることもできます。たとえば、ID、Pref、Name、Scoreの順で列を残すなら、この順番で引数を書くだけです。 df %&gt;% select(ID, Pref, Name) ## # A tibble: 6,292 x 3 ## ID Pref Name ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 e539604 東京都 居酒屋 龍記 京橋店 ## 2 gfeb600 東京都 本格上海料理 新錦江 上野御徒町本店 ## 3 ggt5900 東京都 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） ## 4 g181340 東京都 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 ## 5 ggww100 東京都 まさ屋 渋谷店 ## 6 gdzk500 東京都 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 ## 7 ga2g202 東京都 鶏そば きらり ## 8 gg9m100 東京都 宴会個室×餃子酒場 北京飯店 秋葉原本店 ## 9 gdvk200 東京都 中国料理 宝龍 ## 10 gggb200 東京都 中国料理 天安門 ## # … with 6,282 more rows 10.3.2 特定の列を抽出し、列名を変更する また、特定の列を残す際、変数名を変更することも可能です。今回もID、Name、Pref、Scoreのみを残しますが、Pref列はPrefectureに変えてみましょう。 df %&gt;% select(ID, Name, Prefecture = Pref, Score) ## # A tibble: 6,292 x 4 ## ID Name Prefecture Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA ## 5 ggww100 まさ屋 渋谷店 東京都 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 東京都 NA ## 7 ga2g202 鶏そば きらり 東京都 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 3.33 ## 9 gdvk200 中国料理 宝龍 東京都 2.5 ## 10 gggb200 中国料理 天安門 東京都 NA ## # … with 6,282 more rows 抽出する際、変数を新しい変数名 = 既存の変数名にするだけで、変数名が簡単に変更できました。もし、特定の列は抽出しないものの、変数名を変えるにはどうすれば良いでしょうか。ここではdfのPrefをPrefectureに、WalkをDistanceに変更してみます。dplyrを使わない場合とdplyrのrename()関数を使う場合を両方紹介します。 まずは、name()関数についてですが、これはデータフレームの変数名をベクトルとして出力する関数です。 names(df) ## [1] &quot;ID&quot; &quot;Name&quot; &quot;Pref&quot; &quot;Zipcode&quot; &quot;Latitude&quot; &quot;Longitude&quot; &quot;Line&quot; ## [8] &quot;Station&quot; &quot;Walk&quot; &quot;Bus&quot; &quot;Car&quot; &quot;Budget&quot; &quot;ScoreN&quot; &quot;Score&quot; 察しの良い読者は気づいたかも知れませんが、names(データフレーム名)の結果はベクトルであり、上書きも可能です。つまり、names(df)の3番目と9番目の要素を\"Prefecture\"と\"Distance\"に上書きすることができるということです。 # dplyrを使わずに列名を変更する方法 names(df)[c(3, 9)] &lt;- c(&quot;Prefecture&quot;, &quot;Distance&quot;) # dfの中身を出力 df ## # A tibble: 6,292 x 14 ## ID Name Prefecture Zipcode Latitude Longitude Line Station Distance Bus Car ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 東京都 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA NA ## 2 gfeb… 本格上海… 東京都 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA NA ## 3 ggt5… 食べ飲み… 東京都 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA NA ## 4 g181… 博多餃子… 東京都 1920904 35.7 139. ＪＲ 八王子駅… 1 NA NA ## 5 ggww… まさ屋 … 東京都 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA NA ## 6 gdzk… 完全個室… 東京都 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA NA ## 7 ga2g… 鶏そば … 東京都 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA NA ## 8 gg9m… 宴会個室… 東京都 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA NA ## 9 gdvk… 中国料理… 東京都 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA NA ## 10 gggb… 中国料理… 東京都 1140002 35.8 140. 地下鉄南… 王子駅 2 NA NA ## # … with 6,282 more rows, and 3 more variables: Budget &lt;dbl&gt;, ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; 簡単に変数名の変更ができました。続いて、dplyrのrename()関数を使った方法です。今回は、PrefectureをPrefに、DistanceをWalkに戻して見ましょう。そして、出力するだけにとどまらず、dfに上書きしましょう。 # dfのPrefectureをPrefに、DistanceをWalkに変更し、上書きする df &lt;- df %&gt;% rename(Pref = Prefecture, Walk = Distance) これで終わりです。実はselect()関数と使い方がほぼ同じです。ただし、残す変数名を指定する必要がなく、名前を変更する変数名と新しい変数名を入れるだけです。変数が少ないデータならselect()でもあまり不便は感じないかも知れませんが、変数が多くなるとrename()関数は非常に便利です。 10.3.3 特定の列を除外する 逆に、一部の変数をデータフレームから除去したい場合もあるでしょう。たとえば、緯度 (Latitude)と経度 (Longitude)はラーメン屋の情報としては不要かもしれません。この2つの変数を除外するためにはどうすれば良いでしょうか。まず考えられるのは、この2つの変数を除いた変数を指定・抽出する方法です。 df %&gt;% select(ID, Name, Pref, Zipcode, Line, Station, Walk, Bus, Car, Budget, ScoreN, Score) ## # A tibble: 6,292 x 12 ## ID Name Pref Zipcode Line Station Walk Bus Car Budget ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e5396… 居酒屋 龍記 京橋店… 東京都… 1040031 地下鉄有楽… 銀座一丁目駅… 3 NA NA 3000 0 NA ## 2 gfeb6… 本格上海料理 新錦江 … 東京都… 1100005 地下鉄日比… 仲御徒町駅… 1 NA NA 2000 2 4.5 ## 3 ggt59… 食べ飲み放題×中華ビス… 東京都… 1250041 ＪＲ常磐線… 金町駅 2 NA NA 2980 0 NA ## 4 g1813… 博多餃子軒 八王子店 … 東京都… 1920904 ＪＲ 八王子駅… 1 NA NA 2000 0 NA ## 5 ggww1… まさ屋 渋谷店… 東京都… 1500042 地下鉄半蔵… 渋谷駅 7 NA NA 380 0 NA ## 6 gdzk5… 完全個室 上海レストラ… 東京都… 1000013 地下鉄銀座… 虎ノ門駅… 3 NA NA 2980 0 NA ## 7 ga2g2… 鶏そば きらり… 東京都… 1760006 西武池袋線… 江古田駅… 2 NA NA 850 0 NA ## 8 gg9m1… 宴会個室×餃子酒場 北… 東京都… 1010021 ＪＲ 秋葉原駅… 4 NA NA 2000 3 3.33 ## 9 gdvk2… 中国料理 宝龍… 東京都… 1000006 ＪＲ 有楽町駅… 1 NA NA 1000 2 2.5 ## 10 gggb2… 中国料理 天安門… 東京都… 1140002 地下鉄南北… 王子駅 2 NA NA 2000 0 NA ## # … with 6,282 more rows かなり長いコードになりましたね。しかし、もっと簡単な方法があります。それは-を使う方法です。 df %&gt;% select(-Latitude, -Longitude) # select(-c(Latitude, Longitude)) ## # A tibble: 6,292 x 12 ## ID Name Pref Zipcode Line Station Walk Bus Car Budget ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e5396… 居酒屋 龍記 京橋店… 東京都… 1040031 地下鉄有楽… 銀座一丁目駅… 3 NA NA 3000 0 NA ## 2 gfeb6… 本格上海料理 新錦江 … 東京都… 1100005 地下鉄日比… 仲御徒町駅… 1 NA NA 2000 2 4.5 ## 3 ggt59… 食べ飲み放題×中華ビス… 東京都… 1250041 ＪＲ常磐線… 金町駅 2 NA NA 2980 0 NA ## 4 g1813… 博多餃子軒 八王子店 … 東京都… 1920904 ＪＲ 八王子駅… 1 NA NA 2000 0 NA ## 5 ggww1… まさ屋 渋谷店… 東京都… 1500042 地下鉄半蔵… 渋谷駅 7 NA NA 380 0 NA ## 6 gdzk5… 完全個室 上海レストラ… 東京都… 1000013 地下鉄銀座… 虎ノ門駅… 3 NA NA 2980 0 NA ## 7 ga2g2… 鶏そば きらり… 東京都… 1760006 西武池袋線… 江古田駅… 2 NA NA 850 0 NA ## 8 gg9m1… 宴会個室×餃子酒場 北… 東京都… 1010021 ＪＲ 秋葉原駅… 4 NA NA 2000 3 3.33 ## 9 gdvk2… 中国料理 宝龍… 東京都… 1000006 ＪＲ 有楽町駅… 1 NA NA 1000 2 2.5 ## 10 gggb2… 中国料理 天安門… 東京都… 1140002 地下鉄南北… 王子駅 2 NA NA 2000 0 NA ## # … with 6,282 more rows 除外したい変数名の前に-を付けただけです。また、-Latitudeと-Longitudeをそれぞれ指定せず、-c(Latitude, Longitude)のようにc()でまとめるのも可能です。 10.3.4 隣接した列を指定する 先ほど、dfから緯度 (Latitude)と経度 (Longitude)を除外する例を考えてみましょう。-を使うと簡単ですが、場合によっては残す変数名を指定する必要もあります。 df %&gt;% select(ID, Name, Pref, Zipcode, Line, Station, Walk, Bus, Car, Budget, ScoreN, Score) よく考えてみれば、IDからZipcodeは隣接した列ですし、LineからScoreまでもそうです。これはnames()関数で確認できます。 names(df) ## [1] &quot;ID&quot; &quot;Name&quot; &quot;Pref&quot; &quot;Zipcode&quot; &quot;Latitude&quot; &quot;Longitude&quot; &quot;Line&quot; ## [8] &quot;Station&quot; &quot;Walk&quot; &quot;Bus&quot; &quot;Car&quot; &quot;Budget&quot; &quot;ScoreN&quot; &quot;Score&quot; ここで便利な演算子が:です。これまで、xからyまでの公差1の等差数列を作成する際にx:yを使って来ましたが、これに非常に似ています。データフレームの「x列からy列まで」の表記もselect()関数内では:と書くことができます。したがって、上記のコードは以下のように短縮化可能です。 df %&gt;% select(ID:Zipcode, Line:Score) 「dfのIDからZipcodeまで、そしてLineからScoreまでの列を選択する」という意味です。非常に便利な演算子ですので、-と合わせて覚えておきましょう。 10.3.5 一部の列の順番だけを変える ある列の位置を替えたいとします。たとえば、ScoreとScoreNをそれぞれ1列目、2列目にしたい場合、どうすれば良いでしょうか。これまで勉強したことを考えると、以下のようなコードで問題ないでしょう。 df %&gt;% select(Score, ScoreN, ID:Budget) ## # A tibble: 6,292 x 14 ## Score ScoreN ID Name Pref Zipcode Latitude Longitude Line Station Walk Bus ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NA 0 e539… 居酒屋 … 東京都… 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA ## 2 4.5 2 gfeb… 本格上海… 東京都… 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA ## 3 NA 0 ggt5… 食べ飲み… 東京都… 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA ## 4 NA 0 g181… 博多餃子… 東京都… 1920904 35.7 139. ＪＲ 八王子駅… 1 NA ## 5 NA 0 ggww… まさ屋 … 東京都… 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA ## 6 NA 0 gdzk… 完全個室… 東京都… 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA ## 7 NA 0 ga2g… 鶏そば … 東京都… 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA ## 8 3.33 3 gg9m… 宴会個室… 東京都… 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA ## 9 2.5 2 gdvk… 中国料理… 東京都… 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA ## 10 NA 0 gggb… 中国料理… 東京都… 1140002 35.8 140. 地下鉄南… 王子駅 2 NA ## # … with 6,282 more rows, and 2 more variables: Car &lt;dbl&gt;, Budget &lt;dbl&gt; しかし、dplyrにはrelocate()というより便利な専用関数を提供しています。relocate()には変数名を指定するだけですが、ここで指定した変数がデータフレームの最初列の方に移動します。 df %&gt;% relocate(Score, ScoreN) ## # A tibble: 6,292 x 14 ## Score ScoreN ID Name Pref Zipcode Latitude Longitude Line Station Walk Bus ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NA 0 e539… 居酒屋 … 東京都… 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA ## 2 4.5 2 gfeb… 本格上海… 東京都… 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA ## 3 NA 0 ggt5… 食べ飲み… 東京都… 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA ## 4 NA 0 g181… 博多餃子… 東京都… 1920904 35.7 139. ＪＲ 八王子駅… 1 NA ## 5 NA 0 ggww… まさ屋 … 東京都… 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA ## 6 NA 0 gdzk… 完全個室… 東京都… 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA ## 7 NA 0 ga2g… 鶏そば … 東京都… 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA ## 8 3.33 3 gg9m… 宴会個室… 東京都… 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA ## 9 2.5 2 gdvk… 中国料理… 東京都… 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA ## 10 NA 0 gggb… 中国料理… 東京都… 1140002 35.8 140. 地下鉄南… 王子駅 2 NA ## # … with 6,282 more rows, and 2 more variables: Car &lt;dbl&gt;, Budget &lt;dbl&gt; relocate()を使うとID:Budgetが省略可能となり、より短いコードになります。もう一つの例は、最初に持ってくるのではなく、「ある変数の前」または「ある変数の後」に移動させるケースです。これもrelocate()で可能ですが、もう一つの引数が必要です。PrefとZipcdoeの順番を変えるなら、まずは以下のような方法が考えられます。 df %&gt;% select(ID:Name, Zipcode, Pref, Latitude:Score) ## # A tibble: 6,292 x 14 ## ID Name Zipcode Pref Latitude Longitude Line Station Walk Bus Car Budget ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 1040031 東京都… 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 ## 2 gfeb… 本格上海… 1100005 東京都… 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA NA 2000 ## 3 ggt5… 食べ飲み… 1250041 東京都… 35.8 140. ＪＲ常磐… 金町駅 2 NA NA 2980 ## 4 g181… 博多餃子… 1920904 東京都… 35.7 139. ＪＲ 八王子駅… 1 NA NA 2000 ## 5 ggww… まさ屋 … 1500042 東京都… 35.7 140. 地下鉄半… 渋谷駅 7 NA NA 380 ## 6 gdzk… 完全個室… 1000013 東京都… 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 ## 7 ga2g… 鶏そば … 1760006 東京都… 35.7 140. 西武池袋… 江古田駅… 2 NA NA 850 ## 8 gg9m… 宴会個室… 1010021 東京都… 35.7 140. ＪＲ 秋葉原駅… 4 NA NA 2000 ## 9 gdvk… 中国料理… 1000006 東京都… 35.7 140. ＪＲ 有楽町駅… 1 NA NA 1000 ## 10 gggb… 中国料理… 1140002 東京都… 35.8 140. 地下鉄南… 王子駅 2 NA NA 2000 ## # … with 6,282 more rows, and 2 more variables: ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; これをrelocate()で書き換えるなら、.afterまたは.before引数が必要になります。relocate(変数名1, .after = 変数名2)は「変数1を変数2の直後に移動させる」 ことを意味します。 df %&gt;% relocate(Pref, .after = Zipcode) ## # A tibble: 6,292 x 14 ## ID Name Zipcode Pref Latitude Longitude Line Station Walk Bus Car Budget ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 1040031 東京都… 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 ## 2 gfeb… 本格上海… 1100005 東京都… 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA NA 2000 ## 3 ggt5… 食べ飲み… 1250041 東京都… 35.8 140. ＪＲ常磐… 金町駅 2 NA NA 2980 ## 4 g181… 博多餃子… 1920904 東京都… 35.7 139. ＪＲ 八王子駅… 1 NA NA 2000 ## 5 ggww… まさ屋 … 1500042 東京都… 35.7 140. 地下鉄半… 渋谷駅 7 NA NA 380 ## 6 gdzk… 完全個室… 1000013 東京都… 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 ## 7 ga2g… 鶏そば … 1760006 東京都… 35.7 140. 西武池袋… 江古田駅… 2 NA NA 850 ## 8 gg9m… 宴会個室… 1010021 東京都… 35.7 140. ＪＲ 秋葉原駅… 4 NA NA 2000 ## 9 gdvk… 中国料理… 1000006 東京都… 35.7 140. ＪＲ 有楽町駅… 1 NA NA 1000 ## 10 gggb… 中国料理… 1140002 東京都… 35.8 140. 地下鉄南… 王子駅 2 NA NA 2000 ## # … with 6,282 more rows, and 2 more variables: ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; .beforeを使うことできます。この場合は「ZipcodeをPrefの直前に移動させる」 ことを指定する必要があります。結果は省略しますが、自分でコードを走らせ、上と同じ結果が得られるかを確認してみてください。 df %&gt;% relocate(Zipcode, .before = Pref) 10.3.6 select()の便利な機能 select()関数は他にも便利な機能がいくつかあります。ここではいくつの機能を紹介しますが、より詳しい内容は?dplyr::selectを参照してください。 starts_with()とends_with()、contains()、num_range(): 特定の文字を含む変数を選択する まずは、特定の文字を含む変数名を指定する方法です。starts_with(\"X\")、ends_with(\"X\")、contains(\"X\")は変数名が\"X\"で始まるか、\"X\"で終わるか、\"X\"を含むかを判断し、条件に合う変数名を返す関数です。実際の例を見ましょう。 # ID、Nameに続いて、Scoreで始まる変数名を抽出 df %&gt;% select(ID, Name, starts_with(&quot;Score&quot;)) ## # A tibble: 6,292 x 4 ## ID Name ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 0 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 2 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 0 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 0 NA ## 5 ggww100 まさ屋 渋谷店 0 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 0 NA ## 7 ga2g202 鶏そば きらり 0 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 3 3.33 ## 9 gdvk200 中国料理 宝龍 2 2.5 ## 10 gggb200 中国料理 天安門 0 NA ## # … with 6,282 more rows # eで終わる変数名を除去 df %&gt;% select(-ends_with(&quot;e&quot;)) # !ends_with(&quot;e&quot;)も可能 ## # A tibble: 6,292 x 8 ## ID Pref Station Walk Bus Car Budget ScoreN ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 東京都 銀座一丁目駅 3 NA NA 3000 0 ## 2 gfeb600 東京都 仲御徒町駅 1 NA NA 2000 2 ## 3 ggt5900 東京都 金町駅 2 NA NA 2980 0 ## 4 g181340 東京都 八王子駅 1 NA NA 2000 0 ## 5 ggww100 東京都 渋谷駅 7 NA NA 380 0 ## 6 gdzk500 東京都 虎ノ門駅 3 NA NA 2980 0 ## 7 ga2g202 東京都 江古田駅 2 NA NA 850 0 ## 8 gg9m100 東京都 秋葉原駅 4 NA NA 2000 3 ## 9 gdvk200 東京都 有楽町駅 1 NA NA 1000 2 ## 10 gggb200 東京都 王子駅 2 NA NA 2000 0 ## # … with 6,282 more rows # reを含む変数名を抽出するが、ScoreNは除去する df %&gt;% select(contains(&quot;re&quot;), -ScoreN) ## # A tibble: 6,292 x 2 ## Pref Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 東京都 NA ## 2 東京都 4.5 ## 3 東京都 NA ## 4 東京都 NA ## 5 東京都 NA ## 6 東京都 NA ## 7 東京都 NA ## 8 東京都 3.33 ## 9 東京都 2.5 ## 10 東京都 NA ## # … with 6,282 more rows 他の使い方としてはX1、X2のような「文字+数字」の変数を選択する際、starts_with()が活躍します。たとえば、以下のようなmyDF1があるとします。 # tibble()でなく、data.frame()も使用可能です。 myDF1 &lt;- tibble( ID = 1:5, X1 = c(2, 4, 6, 2, 7), Y1 = c(3, 5, 1, 1, 0), X1D = c(4, 2, 1, 6, 9), X2 = c(5, 5, 6, 0, 2), Y2 = c(3, 3, 2, 3, 1), X2D = c(8, 9, 5, 0, 1), X3 = c(3, 0, 3, 0, 2), Y3 = c(1, 5, 9, 1, 3), X3D = c(9, 1, 3, 3, 8) ) myDF1 ## # A tibble: 5 x 10 ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 3 4 5 3 8 3 1 9 ## 2 2 4 5 2 5 3 9 0 5 1 ## 3 3 6 1 1 6 2 5 3 9 3 ## 4 4 2 1 6 0 3 0 0 1 3 ## 5 5 7 0 9 2 1 1 2 3 8 このmyDF1からID、Y1、Y2、Y3を抽出するにはどうすれば良いでしょうか。これらの変数は隣接していないため、:も使えませんが、starts_with()を使えば簡単です。 myDF1 %&gt;% select(ID, starts_with(&quot;Y&quot;)) ## # A tibble: 5 x 4 ## ID Y1 Y2 Y3 ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 3 3 1 ## 2 2 5 3 5 ## 3 3 1 2 9 ## 4 4 1 3 1 ## 5 5 0 1 3 それでは、ID、X1、X2、X3はどうでしょうか。starts_with(\"X\")だと、X1cなども選択されてしまいますね。ここで-ends_with()の出番です。つまり、「まずはstarts_with(\"X\")でXで始まる変数を選択し、続いて、Dで終わるものを除外すればいいじゃん？」です。それでは、やってみましょうか。 myDF1 %&gt;% select(ID, starts_with(&quot;X&quot;), -ends_with(&quot;D&quot;)) ## # A tibble: 5 x 3 ## X1 X2 X3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 5 3 ## 2 4 5 0 ## 3 6 6 3 ## 4 2 0 0 ## 5 7 2 2 あらら、IDも同時になくなりましたね55。実はこのような時のために用意された関数があり、それがnum_range()です。num_range()の第一引数はstarts_with()関数と同じですが、第二引数も必要です。この第二引数にはnumeric型のベクトルが必要です。1:3でも、c(1, 2, 3)でも構いません。たとえば、ID、X1、X2、X3するには以下のように書きます。 myDF1 %&gt;% select(ID, num_range(&quot;X&quot;, 1:3)) ## # A tibble: 5 x 4 ## ID X1 X2 X3 ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 5 3 ## 2 2 4 5 0 ## 3 3 6 6 3 ## 4 4 2 0 0 ## 5 5 7 2 2 ぱっぱらぱー！ all_of()とany_of(): 文字型ベクトルを用いた変数の選択 all_of()とany_of()はselect()内の変数名として文字型ベクトルを使う際に用いる関数です。これは抽出したい列名が既にcharacter型ベクトルとして用意されている場合、便利な関数です。たとえば、以下のName_Vecを考えてみましょう。 Name_Vec &lt;- c(&quot;X1&quot;, &quot;X2&quot;, &quot;X3&quot;) このName_Vecの要素と同じ列名を持つ列とID列をmyDF1から抽出する方法は以下の2通りです。 myDF1[, c(&quot;ID&quot;, Name_Vec)] ## # A tibble: 5 x 4 ## ID X1 X2 X3 ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 5 3 ## 2 2 4 5 0 ## 3 3 6 6 3 ## 4 4 2 0 0 ## 5 5 7 2 2 myDF1 %&gt;% select(ID, all_of(Name_Vec)) ## # A tibble: 5 x 4 ## ID X1 X2 X3 ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 5 3 ## 2 2 4 5 0 ## 3 3 6 6 3 ## 4 4 2 0 0 ## 5 5 7 2 2 今の例だと、select()を使わない前者の方が便利かも知れませんが、select()内に外の変数名も指定する場合も多いので、後者の方が汎用性は高いです。私から見れば、今の例でも後者の方が読みやすく、使いやすいと思います。 それでは以下のようなName_Vecはどうでしょう。今回は、myDF1に含まれていないX4とX5もあります。 Name_Vec &lt;- c(&quot;X1&quot;, &quot;X2&quot;, &quot;X3&quot;, &quot;X4&quot;, &quot;X5&quot;) myDF1 %&gt;% select(all_of(Name_Vec)) ## Error: Can&#39;t subset columns that don&#39;t exist. ## [31mx[39m Columns `X4` and `X5` don&#39;t exist. このようにエラーが出てしまします。つまり、all_of()の場合、引数の要素全てがデータフレームに存在する必要があります。もし、ないものは無視して、合致する列だけ取り出したいはどうすれば良いでしょうか。そこで登場するのがany_of()です。 myDF1 %&gt;% select(any_of(Name_Vec)) ## # A tibble: 5 x 3 ## X1 X2 X3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 5 3 ## 2 4 5 0 ## 3 6 6 3 ## 4 2 0 0 ## 5 7 2 2 any_of()の方がより使いやすいと思う方も多いでしょうが、必ずしもそうとは限りません。たとえば、Name_Vecに誤字などが含まれる場合、any_of()だと誤字が含まれている変数は取り出しません。この場合はむしろちゃんとエラーを表示してくれた方が嬉しいですね。 last_col(): 最後の列を選択する 普段あまり使わない機能ですが、最後の列を選択するlast_col()という関数もあります。たとえば、last_col(0)にすると最後の列を選択し、last_col(1)なら最後から2番目の列を選択します。たとえば、dfからIDと最後の列を取り出してみましょう。 # IDと最後の列のみを抽出 df %&gt;% select(ID, last_col(0)) ## # A tibble: 6,292 x 2 ## ID Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 NA ## 2 gfeb600 4.5 ## 3 ggt5900 NA ## 4 g181340 NA ## 5 ggww100 NA ## 6 gdzk500 NA ## 7 ga2g202 NA ## 8 gg9m100 3.33 ## 9 gdvk200 2.5 ## 10 gggb200 NA ## # … with 6,282 more rows 最後の2行分を取り出すことも可能です。この場合はlast_col()の引数を長さ1ベクトルでなく、長さ2以上のベクトルにします。最後の行が0、その手前の行が1ですから、中の引数は1:0となります。0:1でも可能ですが、結果が若干異なります。 # IDと最後の2列分を抽出 (引数を1:0と設定) df %&gt;% select(ID, last_col(1:0)) ## # A tibble: 6,292 x 3 ## ID ScoreN Score ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 0 NA ## 2 gfeb600 2 4.5 ## 3 ggt5900 0 NA ## 4 g181340 0 NA ## 5 ggww100 0 NA ## 6 gdzk500 0 NA ## 7 ga2g202 0 NA ## 8 gg9m100 3 3.33 ## 9 gdvk200 2 2.5 ## 10 gggb200 0 NA ## # … with 6,282 more rows # IDと最後の2列分を抽出 (引数を0:1と設定) df %&gt;% select(ID, last_col(0:1)) ## # A tibble: 6,292 x 3 ## ID Score ScoreN ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 NA 0 ## 2 gfeb600 4.5 2 ## 3 ggt5900 NA 0 ## 4 g181340 NA 0 ## 5 ggww100 NA 0 ## 6 gdzk500 NA 0 ## 7 ga2g202 NA 0 ## 8 gg9m100 3.33 3 ## 9 gdvk200 2.5 2 ## 10 gggb200 NA 0 ## # … with 6,282 more rows last_col()の引数を1:0にするか0:1にするかによって抽出される順番が異なります。1:0はc(1, 0)、0:1はc(0, 1)と同じであることを考えると理由は簡単です。c(1, 0)の場合、last_col(1), last_col(0)の順番で処理をし、c(0, 1)はlast_col(0)、last_col(1)の順番で処理を行うからです。 このlast_col()の引数を空っぽにするとそれは最後の列を意味します。これを利用すれば、「ある変数の最後の列へ移動させる」こともできます。たとえば、IDを最後の列に移動させたい場合、relocate(ID, .after = last_col())のように書きます。 where(): データ型から変数を選択する 最後に、「numeric型の列のみ抽出したい」、「character型の列だけほしい」場合に便利なwhere()関数を紹介します。where()の中に入る引数は一つだけであり、データ型を判定する関数名が入ります。たとえば、numeric型か否かを判断する関数はis.numericです。dfからnumeric型の変数のみを抽出したい場合は以下のように書きます。 # numeric型の列を抽出する df %&gt;% select(where(is.numeric)) ## # A tibble: 6,292 x 9 ## Zipcode Latitude Longitude Walk Bus Car Budget ScoreN Score ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1040031 35.7 140. 3 NA NA 3000 0 NA ## 2 1100005 35.7 140. 1 NA NA 2000 2 4.5 ## 3 1250041 35.8 140. 2 NA NA 2980 0 NA ## 4 1920904 35.7 139. 1 NA NA 2000 0 NA ## 5 1500042 35.7 140. 7 NA NA 380 0 NA ## 6 1000013 35.7 140. 3 NA NA 2980 0 NA ## 7 1760006 35.7 140. 2 NA NA 850 0 NA ## 8 1010021 35.7 140. 4 NA NA 2000 3 3.33 ## 9 1000006 35.7 140. 1 NA NA 1000 2 2.5 ## 10 1140002 35.8 140. 2 NA NA 2000 0 NA ## # … with 6,282 more rows !を使って条件に合致する列を除外することも可能です。もし、character型の列を除外する場合は以下のように!where(is.character)を指定します。 # character型でない列を抽出する df %&gt;% select(!where(is.character)) ## # A tibble: 6,292 x 9 ## Zipcode Latitude Longitude Walk Bus Car Budget ScoreN Score ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1040031 35.7 140. 3 NA NA 3000 0 NA ## 2 1100005 35.7 140. 1 NA NA 2000 2 4.5 ## 3 1250041 35.8 140. 2 NA NA 2980 0 NA ## 4 1920904 35.7 139. 1 NA NA 2000 0 NA ## 5 1500042 35.7 140. 7 NA NA 380 0 NA ## 6 1000013 35.7 140. 3 NA NA 2980 0 NA ## 7 1760006 35.7 140. 2 NA NA 850 0 NA ## 8 1010021 35.7 140. 4 NA NA 2000 3 3.33 ## 9 1000006 35.7 140. 1 NA NA 1000 2 2.5 ## 10 1140002 35.8 140. 2 NA NA 2000 0 NA ## # … with 6,282 more rows &amp;を使って複数の条件を使うことも可能です。たとえば、ID変数に加えて「\"L\"で始まる変数の中でnumeric型の列を抽出」するコードは以下のようになります。 # IDと、Lで始まるnumeric型の列を抽出する df %&gt;% select(ID, starts_with(&quot;L&quot;) &amp; where(is.numeric)) ## # A tibble: 6,292 x 3 ## ID Latitude Longitude ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 35.7 140. ## 2 gfeb600 35.7 140. ## 3 ggt5900 35.8 140. ## 4 g181340 35.7 139. ## 5 ggww100 35.7 140. ## 6 gdzk500 35.7 140. ## 7 ga2g202 35.7 140. ## 8 gg9m100 35.7 140. ## 9 gdvk200 35.7 140. ## 10 gggb200 35.8 140. ## # … with 6,282 more rows 10.4 行の抽出 10.4.1 指定した行を抽出する 他にも特定の行を抽出する場合があります。たとえば、「dfの最初の5行」や「dfの8行目のケース」といった場合です。この操作にはdplyrのslice_*()関数群が便利です。それではそれぞれの関数の使い方について紹介していきます。その前に、実習用データとしてdfから一部の列のみを抽出したselelct.dfを作成します。 select.df &lt;- df %&gt;% select(ID, Name, Pref, Budget, Score) slice(): 指定した番号の行のみ抽出する select.dfから2, 8, 9行目の行を抽出したいとします。このような簡単な操作はパッケージを使わず、以下のように抽出することができます。 # select.dfから2, 8, 9行目の行を抽出し、出力する select.df[c(2, 8, 9),] ## # A tibble: 3 x 5 ## ID Name Pref Budget Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 2000 4.5 ## 2 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 2000 3.33 ## 3 gdvk200 中国料理 宝龍 東京都 1000 2.5 しかし、以下のslice()関数を使うとパイプ演算子を前後に付けることが可能であり56、コードの可読性も高いです。slice()関数には以下のように抽出したい行の番号を入れるだけです。 # select.dfから2, 8, 9行目の行を抽出し、出力する select.df %&gt;% slice(2, 8, 9) # slice(c(2, 8, 9))もOK ## # A tibble: 3 x 5 ## ID Name Pref Budget Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 2000 4.5 ## 2 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 2000 3.33 ## 3 gdvk200 中国料理 宝龍 東京都 1000 2.5 slice(2, 8, 9)でもslice(c(2, 8, 9))でも構いません。また、隣接した行でしたら:を使うことも可能です。たとえば、10行目から15行目まで抽出する場合はslice(10:15)のような書き方も出来ます。 slice_head(): 最初のn行を抽出する # select.dfから最初の3行抽出し、出力する select.df %&gt;% slice_head(n = 3) ## # A tibble: 3 x 5 ## ID Name Pref Budget Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 3000 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 2000 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 2980 NA これはhead(データ名, n = 出力する個数)と同じ動きをする関数です。注意点としては引数n =を必ず付ける点です。たとえば、slice_head(3)にすると、select.dfの3行目のみ抽出されます。 slice_tail(): 最後のn行を抽出する # select.dfから最後の7行を抽出し、出力する select.df %&gt;% slice_tail(n = 7) ## # A tibble: 7 x 5 ## ID Name Pref Budget Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5508852 場鶴 和歌山県 NA NA ## 2 7113351 来来亭 橋本店 和歌山県 NA NA ## 3 6364939 ばり馬 和歌山紀三井寺店 和歌山県 NA NA ## 4 7103349 ramen BIRDMAN 和歌山県 NA NA ## 5 7315303 薩摩ラーメン 斗天王 和歌山県 NA NA ## 6 7703472 まるしげ 和歌山県 NA NA ## 7 6395035 暴豚製麺所 和歌山県 NA NA これはtail(データ名, n = 出力する個数)と同じ動きをする関数です。ちなみに、このn引数もn =を明記する必要があります。 slice_max(): 指定した変数が大きい順でn行抽出する slice_max()は指定した変数が大きい順でn行抽出する関数です。たとえば、Budgetが高い順で4店舗を抽出する場合は以下のように書きます。 # select.dfからScoreの値が高い順で5行を抽出し、出力する select.df %&gt;% slice_max(Budget, n = 4) ## # A tibble: 4 x 5 ## ID Name Pref Budget Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 g670609 横浜ベイシェラトン ホテル＆タワーズ 中国料理 彩龍 神奈川県 8000 NA ## 2 g910420 JASMINE 憶江南 東京都 7000 NA ## 3 7176666 赤坂焼鳥 鳳 東京都 7000 NA ## 4 b612800 羽衣 銀座本店 東京都 6000 NA slice_min(): 指定した変数が小さい順でn行抽出する 一方、slice_min()関数が小さい順で抽出します。 # select.dfからScoreの値が低い順で3行を抽出し、出力する select.df %&gt;% slice_min(Score, n = 3) ## # A tibble: 4 x 5 ## ID Name Pref Budget Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 6384909 葛西大勝軒 東京都 NA 1 ## 2 6929243 由丸 アトレヴィ大塚店 東京都 NA 1 ## 3 5816075 ラーメン戯拉戯拉 千葉県 NA 1 ## 4 5495086 らあめん花月嵐 坂戸わかば店 埼玉県 NA 1 ただし、n = 3と指定したはずなのに、4行が抽出されました。これは同点のケースがあるからです。実際、select.dfにはScoreが1のケースが4つあります。もし、同点の存在によりnに収まらない場合、slice_max()、slice_min()関数はnを超える行を出力します。これを強制的にn行に合わせるためにはwith_ties = FALSE引数を付けます。この場合、データで格納されている順でn個のみ出力されます。 select.df %&gt;% slice_min(Score, n = 3, with_ties = FALSE) ## # A tibble: 3 x 5 ## ID Name Pref Budget Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 6384909 葛西大勝軒 東京都 NA 1 ## 2 6929243 由丸 アトレヴィ大塚店 東京都 NA 1 ## 3 5816075 ラーメン戯拉戯拉 千葉県 NA 1 slice_sample(): 無作為にn行を抽出する 最後に無作為にn行を抽出するslice_sample()関数です。引数はnであり、抽出したい行数を指定します。たとえば、select.dfから無作為に10行抽出したい場合は、 # select.dfから無作為に5行を抽出し、出力する select.df %&gt;% slice_sample(n = 10) ## # A tibble: 10 x 5 ## ID Name Pref Budget Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5026185 ちゃんこらーめん 千葉県 NA NA ## 2 6902253 ラーメンのまめぞう 浦和店 埼玉県 NA NA ## 3 6286600 中華そば 葦屋 千葉県 NA NA ## 4 5808947 来来 兵庫県 NA NA ## 5 7641518 秀 千葉県 NA NA ## 6 7360113 たんめん専門店 百菜 神奈川県 840 NA ## 7 kdc9002 大阪ふくちぁんラーメン 塚本店 大阪府 950 2.75 ## 8 7468406 らぁめんhiro 大阪府 NA NA ## 9 5494530 麺屋匠神 埼玉県 NA 5 ## 10 7661604 けもの道 千葉県 NA NA のように書きます。ブートストラップ法や機械学習における交差検証 (cross-validation)の際に有用な関数ですが、ブートストラップや機械学習のパッケージの多くはサンプル分割の関数を提供しているため、あまり使う機会はないでしょう。また、slice_sample()関数をブートストラップ法のために用いる場合は、ケースを反復抽出する必要があり、replace = TRUEを付けると反復抽出を行います。デフォルト値はFALSEです。 10.4.2 条件に合致する行を抽出する これまで見てきたslice()を用いる行の抽出は、実際あまり使う機会がありません。多くの場合、「何かの条件と合致するケースのみ抽出する」または、「何かの条件と合致しないケースのみを抽出する」やこれらの組み合わせで行の抽出を行います。そこで登場するのがdplyr()パッケージのfilter()関数です。filter()関数の使い方は以下の通りです。 # dplyr::filter()の使い方 filter(データフレーム名, 条件1, 条件2, ...) むろん、第一引数がデータですから、%&gt;%を使うことも可能です。 # dplyr::filter()の使い方 (パイプを使う方法) データフレーム名 %&gt;% filter(条件1, 条件2, ...) まずは、条件が一つの場合を考えてみましょう。ここでは「Prefが\"京都府\"であるケースのみに絞り、NameとStation、Score列のみを出力する」ケースを考えてみましょう。まず、filter()関数で行を抽出し、続いてselect()関数で抽出する列を指定します。むろん、今回の場合、filter()とselect()の順番は替えても構いません。 # dfからPrefが&quot;京都府&quot;であるケースのみ残し、df2という名で保存 df2 &lt;- df %&gt;% filter(Pref == &quot;京都府&quot;) # df2からName, Station, Score列を抽出 df2 %&gt;% select(Name, Station, Score) ## # A tibble: 414 x 3 ## Name Station Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 中国料理 鳳麟 くいな橋駅 NA ## 2 黒毛和牛一頭買い焼肉と 炊き立て土鍋ご飯 市場小路 烏丸店 四条駅 3.19 ## 3 京の中華 ハマムラ みやこみち店 京都駅 NA ## 4 焼肉処 真 桂店 桂駅 NA ## 5 祇園京都ラーメン 祇園四条駅 NA ## 6 創作料理 串カツ トンカツ jiro 新田辺駅 NA ## 7 祇園 晩餐のあと 祇園四条駅 NA ## 8 DETAIL 東山駅 NA ## 9 めんや龍神 北大路駅 NA ## 10 無尽蔵 京都八条家 京都駅 3.5 ## # … with 404 more rows これはdfからPref == \"京都府\"のケースのみ残したものをdf2として格納し、それをまたselect()関数を使って列を抽出するコードです。これでも問題ありませんが、これだとパイプ演算子の便利さが分かりません。パイプ演算子は複数使うことが可能です。 df %&gt;% filter(Pref == &quot;京都府&quot;) %&gt;% select(Name, Station, Score) ## # A tibble: 414 x 3 ## Name Station Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 中国料理 鳳麟 くいな橋駅 NA ## 2 黒毛和牛一頭買い焼肉と 炊き立て土鍋ご飯 市場小路 烏丸店 四条駅 3.19 ## 3 京の中華 ハマムラ みやこみち店 京都駅 NA ## 4 焼肉処 真 桂店 桂駅 NA ## 5 祇園京都ラーメン 祇園四条駅 NA ## 6 創作料理 串カツ トンカツ jiro 新田辺駅 NA ## 7 祇園 晩餐のあと 祇園四条駅 NA ## 8 DETAIL 東山駅 NA ## 9 めんや龍神 北大路駅 NA ## 10 無尽蔵 京都八条家 京都駅 3.5 ## # … with 404 more rows 全く同じ結果ですが、無駄にdf2というデータフレームを作らず済むので、メモリの観点からも嬉しいですし、何よりコードが短く、しかも可読性も上がりました。 今回は==を使って合致するものに絞りましたが、!=を使って合致しないものに絞ることも可能です。または、比較演算子 (&lt;、&gt;、&gt;=、&lt;=など)を使うことも可能です。それでは、組み込み数 (ScoreN)が0ではないケースを取り出し、Name、Station、ScoreN、Score列を出力させてみましょう。 df %&gt;% filter(ScoreN != 0) %&gt;% select(Name, Station, starts_with(&quot;Score&quot;)) ## # A tibble: 1,344 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 本格上海料理 新錦江 上野御徒町本店 仲御徒町駅 2 4.5 ## 2 宴会個室×餃子酒場 北京飯店 秋葉原本店 秋葉原駅 3 3.33 ## 3 中国料理 宝龍 有楽町駅 2 2.5 ## 4 麺達 うま家 高田馬場駅 2 3 ## 5 刀削麺・火鍋・西安料理 XI’AN（シーアン） 後楽園店 後楽園駅 1 NA ## 6 七志らーめん 渋谷道玄坂店 渋谷駅 7 4.5 ## 7 永楽 京成小岩駅 6 4.42 ## 8 よってこや お台場店 お台場海浜公園駅 1 4 ## 9 ラーメン武藤製麺所 竹ノ塚駅 4 3.5 ## 10 桂花ラーメン 新宿末広店 新宿三丁目駅 8 3 ## # … with 1,334 more rows これで口コミ数が1以上の店舗のみに絞ることができました。ただし、店によっては口コミはあっても、評価 (Score)が付いていないところもあります。たとえば、「刀削麺・火鍋・西安料理 XI’AN（シーアン） 後楽園店」の場合、口コミはありますが、評価はありません。したがって、今回は評価が付いている店舗に絞ってみましょう。 df %&gt;% filter(Score != NA) %&gt;% select(Name, Station, starts_with(&quot;Score&quot;)) ## # A tibble: 0 x 4 ## # … with 4 variables: Name &lt;chr&gt;, Station &lt;chr&gt;, ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; あらら、何の結果も表示されませんでした。これはfilter()内の条件に合致するケースが存在しないことを意味します。しかし、先ほどの結果を見ても、評価が付いている店はいっぱいありましたね。これはなぜでしょう。 察しの良い読者さんは気づいているかと思いますが、第7.8章で説明した通り、NAか否かを判定する際は==や!=は使えません。is.na()を使います。filter(is.na(Score))なら「ScoreがNAであるケースに絞る」ことを意味しますが、今回は「ScoreがNAでないケースに絞る」ことが目的ですので、is.na()の前に!を付けます。 df %&gt;% filter(!is.na(Score)) %&gt;% select(Name, Station, starts_with(&quot;Score&quot;)) ## # A tibble: 1,134 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 本格上海料理 新錦江 上野御徒町本店 仲御徒町駅 2 4.5 ## 2 宴会個室×餃子酒場 北京飯店 秋葉原本店 秋葉原駅 3 3.33 ## 3 中国料理 宝龍 有楽町駅 2 2.5 ## 4 麺達 うま家 高田馬場駅 2 3 ## 5 七志らーめん 渋谷道玄坂店 渋谷駅 7 4.5 ## 6 永楽 京成小岩駅 6 4.42 ## 7 よってこや お台場店 お台場海浜公園駅 1 4 ## 8 ラーメン武藤製麺所 竹ノ塚駅 4 3.5 ## 9 桂花ラーメン 新宿末広店 新宿三丁目駅 8 3 ## 10 北斗 新橋店 新橋駅 4 2.5 ## # … with 1,124 more rows これで口コミ評価が登録された店舗に絞ることができました。 続いて、複数の条件を持つケースを考えてみましょう。例えば、「京都府内の店舗で、口コミ評価が3.5以上の店舗」を出力したい場合、以下のようなコードとなります。 df %&gt;% filter(Pref == &quot;京都府&quot;, Score &gt;= 3.5) %&gt;% select(Name, Station, ScoreN, Score) ## # A tibble: 53 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 無尽蔵 京都八条家 京都駅 2 3.5 ## 2 一蘭 京都河原町店 河原町駅 2 3.75 ## 3 ミスター・ギョーザ 西大路駅 8 4.06 ## 4 一蘭 京都八幡店 樟葉駅 3 4 ## 5 中華料理 清華園 京都駅 3 5 ## 6 まがり &lt;NA&gt; 2 4 ## 7 魁力屋 北山店 北大路駅 2 4.25 ## 8 大中BAL横店 &lt;NA&gt; 7 4.1 ## 9 こうちゃん 西舞鶴駅 1 5 ## 10 大黒ラーメン 伏見桃山駅 4 4.25 ## # … with 43 more rows 条件をfilter()内に追加するだけです。今回は!is.na(Score)は不要です。なぜなら、Score &gt;= 3.5という条件で既に欠損値は対象外になるからです。条件文が複数ある場合、ANDかORかを指定する必要があります。つまり、条件文AとBがある場合、「AとB両方満たすものを出力する」か「AとBどちらかを満たすものを出力するか」を指定する必要があります。今の結果ってANDでしたよね。filter()関数は、別途の指定がない場合、全てAND扱いになります。RのAND演算子は&amp;ですので、以上のコードは以下のコードと同じです。 df %&gt;% filter(Pref == &quot;京都府&quot; &amp; Score &gt;= 3.5) %&gt;% select(Name, Station, ScoreN, Score) ## # A tibble: 53 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 無尽蔵 京都八条家 京都駅 2 3.5 ## 2 一蘭 京都河原町店 河原町駅 2 3.75 ## 3 ミスター・ギョーザ 西大路駅 8 4.06 ## 4 一蘭 京都八幡店 樟葉駅 3 4 ## 5 中華料理 清華園 京都駅 3 5 ## 6 まがり &lt;NA&gt; 2 4 ## 7 魁力屋 北山店 北大路駅 2 4.25 ## 8 大中BAL横店 &lt;NA&gt; 7 4.1 ## 9 こうちゃん 西舞鶴駅 1 5 ## 10 大黒ラーメン 伏見桃山駅 4 4.25 ## # … with 43 more rows AND演算子 (&amp;)が使えるということはOR演算子 (|)も使えることを意味します。たとえば、Stationが\"高田馬場駅\"か\"三田駅\"の条件を指定したい場合、 df %&gt;% filter(Station == &quot;高田馬場駅&quot; | Station == &quot;三田駅&quot;) %&gt;% select(Name, Station, ScoreN, Score) ## # A tibble: 14 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 麺達 うま家 高田馬場駅 2 3 ## 2 らぁ麺 やまぐち 高田馬場駅 7 4.08 ## 3 博多一瑞亭 三田店 三田駅 0 NA ## 4 つけ麺屋 ひまわり 高田馬場駅 4 2.75 ## 5 石器ラーメン 高田馬場 高田馬場駅 0 NA ## 6 旨辛らーめん 表裏 高田馬場駅 0 NA ## 7 三歩一 高田馬場駅 8 4.56 ## 8 えぞ菊 戸塚店 高田馬場駅 4 3.62 ## 9 麺屋 宗 高田馬場駅 5 4.2 ## 10 とんこつラーメン 博多風龍 高田馬場店 高田馬場駅 2 3 ## 11 横浜家系ラーメン 馬場壱家 高田馬場駅 0 NA ## 12 らーめん よし丸 高田馬場駅 1 5 ## 13 札幌ラーメン どさん子 三田店 三田駅 0 NA ## 14 天下一品 三田店 三田駅 0 NA のように書きます（ちなみに高田馬場の「やまぐち」は本当に美味しいです）。むろん、複数の変数を用いたORも可能です。たとえば、「Prefが\"京都府\"かScoreが3以上」のような条件も可能ですが (Pref == \"京都府\" | Score &gt;= 3)、実際、このような例はあまりありません。よく使うのは「変数Xがaかbかcか」のような例です。ただし、この場合は|を使わないもっと簡単な方法があります。それは第9.4章で紹介した%in%演算子です。以下のコードは上のコードと同じものです。 df %&gt;% filter(Station %in% c(&quot;高田馬場駅&quot;, &quot;三田駅&quot;)) %&gt;% select(Name, Station, ScoreN, Score) ## # A tibble: 14 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 麺達 うま家 高田馬場駅 2 3 ## 2 らぁ麺 やまぐち 高田馬場駅 7 4.08 ## 3 博多一瑞亭 三田店 三田駅 0 NA ## 4 つけ麺屋 ひまわり 高田馬場駅 4 2.75 ## 5 石器ラーメン 高田馬場 高田馬場駅 0 NA ## 6 旨辛らーめん 表裏 高田馬場駅 0 NA ## 7 三歩一 高田馬場駅 8 4.56 ## 8 えぞ菊 戸塚店 高田馬場駅 4 3.62 ## 9 麺屋 宗 高田馬場駅 5 4.2 ## 10 とんこつラーメン 博多風龍 高田馬場店 高田馬場駅 2 3 ## 11 横浜家系ラーメン 馬場壱家 高田馬場駅 0 NA ## 12 らーめん よし丸 高田馬場駅 1 5 ## 13 札幌ラーメン どさん子 三田店 三田駅 0 NA ## 14 天下一品 三田店 三田駅 0 NA 結局、|が使われるケースがかなり限定されます。あるとすれば、「変数Xがa以下か、b以上か」のようなケースですね。ただし、&amp;と|を同時に使うケースは考えられます。たとえば、大阪駅と京都駅周辺のうまいラーメン屋を調べるとします。問題は美味しさの基準ですが、3.5点以上としましょう。ただし、京都府民はラーメンに非常に厳しく、3点以上なら美味しいと仮定します。この場合、「(Stationが\"大阪駅\"かつScore &gt;= 3.5)、または(Stationが\"京都駅\"かつScore &gt;= 3)」のような条件が必要になります。()は「()の中から判定せよ」という、普通の算数での使い方と同じです。それでは、実際に検索してみましょう。 df %&gt;% filter((Station == &quot;大阪駅&quot; &amp; Score &gt;= 3.5) | (Station == &quot;京都駅&quot; &amp; Score &gt;= 3)) %&gt;% select(Name, Station, Walk, ScoreN, Score) ## # A tibble: 6 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Lei can ting 大阪ルクア店 大阪駅 3 3 4 ## 2 神座 ルクア大阪店 大阪駅 1 10 3.94 ## 3 みつか坊主 醸 大阪駅 10 4 5 ## 4 無尽蔵 京都八条家 京都駅 5 2 3.5 ## 5 中華料理 清華園 京都駅 10 3 5 ## 6 ますたに 京都拉麺小路店 京都駅 9 3 3.67 Songが大好きな神座がヒットして嬉しいです。 10.5 行のソート 続いて、行のソートについて解説します。「食べログ」などのレビューサービスを利用する場合、口コミ評価が高い順で見るのが一般的でしょう57。また、サッカーのランキングも多くは1位から下の順位で掲載されるのが一般的です。ここではこのようにある変数の値順に行を並び替える方法について説明します。 ソートにはdplyrパッケージのarrange()関数を使います。引数は変数名のみです。たとえば、奈良県のラーメン屋を検索してみましょう。並び替える順は駅から近い店舗を上位に、遠い店舗を下位に並べます。このような順は昇順 (ascending)と呼ばれ、ランキング表などでよく見ます。駅から近い順にソートするので、まず最寄りの駅情報が欠損でないことが必要です。また、ラーメン屋の評価も気になるので口コミが1つ以上付いている店舗に絞りましょう。表示する列は店舗名、最寄りの駅、徒歩距離、口コミ数、点数です。 df %&gt;% filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;% select(Name, Station, Walk, ScoreN, Score) %&gt;% arrange(Walk) %&gt;% print(n = Inf) ## # A tibble: 24 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 麺屋 あまのじゃく 本店 富雄駅 2 2 4.5 ## 2 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅 4 1 4 ## 3 ラーメン家 みつ葉 富雄駅 4 1 3.5 ## 4 天下一品 新大宮店 新大宮駅 6 1 3 ## 5 麺屋 一徳 天理駅 7 1 3 ## 6 丸源ラーメン 橿原店 金橋駅 8 1 3.5 ## 7 らーめん食堂 よってこや 平群店 元山上口駅 10 1 4 ## 8 天理スタミナラーメン本店 櫟本駅 11 2 3.25 ## 9 博多長浜らーめん夢街道 奈良土橋店 真菅駅 11 1 3.5 ## 10 ぶ～け 奈良駅 11 1 5 ## 11 つけめん らーめん元喜神 押熊店 学研奈良登美ヶ丘駅 12 4 4.12 ## 12 彩華ラーメン 本店 前栽駅 12 5 3.6 ## 13 力皇 天理駅 13 1 3.5 ## 14 らーめん きみちゃん 京終駅 14 2 4.5 ## 15 無鉄砲がむしゃら 帯解駅 15 2 4 ## 16 彩華ラーメン 田原本店 石見駅 15 1 4 ## 17 神座 大和高田店 大和高田駅 17 2 3.75 ## 18 彩華ラーメン 奈良店 尼ヶ辻駅 17 3 4.33 ## 19 彩華ラーメン 桜井店 大福駅 18 1 3 ## 20 天下一品 東生駒店 東生駒駅 19 1 3.5 ## 21 まりお流ラーメン 新大宮駅 20 1 5 ## 22 どうとんぼり神座 奈良柏木店 西ノ京駅 22 1 3 ## 23 河童ラーメン本舗 押熊店 学研奈良登美ヶ丘駅 28 1 4 ## 24 博多長浜らーめん 夢街道 四条大路店 新大宮駅 29 4 2.88 3行まではこれまで習ってきたもので、4行目がソートの関数、arrange()です。引数はソートの基準となる変数で、今回は最寄りの駅からの徒歩距離を表すWalkです。5行目は省略可能ですが、tibbleクラスの場合、10行までしか出力されないので、print(n = Inf)で「すべての行を表示」させます。nを指定することで出力される行数が調整可能です。奈良県のラーメン屋の中で最寄りの駅から最も近い店は「麺屋 あまのじゃく 本店」で徒歩2分でした。京田辺店も駅から約2分ですし、近いですね。ちなみにSongはここの塩とんこつが好きです。世界一こってりなラーメンとも言われる「チョモランマ」で有名な「まりお流ラーメン」は新大宮駅から徒歩20分でかなり遠いことが分かります。 続いて、駅からの距離ではなく、評価が高い順にしてみましょう。評価が高いほど上に来るので、今回は昇順でなく、降順 (descending)でソートする必要があります。arrange()関数は基本的に、指定された変数を基準に昇順でソートします。降順にするためにはdesc()関数を更に用います。たとえば、arrange(desc(変数名))のようにです。それでは実際にやってみましょう。上のコードの4行目をarange(Walk)からarrange(desc(Score))にちょっと修正するだけです。 df %&gt;% filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;% select(Name, Station, Walk, ScoreN, Score) %&gt;% arrange(desc(Score)) %&gt;% print(n = Inf) ## # A tibble: 24 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 まりお流ラーメン 新大宮駅 20 1 5 ## 2 ぶ～け 奈良駅 11 1 5 ## 3 麺屋 あまのじゃく 本店 富雄駅 2 2 4.5 ## 4 らーめん きみちゃん 京終駅 14 2 4.5 ## 5 彩華ラーメン 奈良店 尼ヶ辻駅 17 3 4.33 ## 6 つけめん らーめん元喜神 押熊店 学研奈良登美ヶ丘駅 12 4 4.12 ## 7 河童ラーメン本舗 押熊店 学研奈良登美ヶ丘駅 28 1 4 ## 8 無鉄砲がむしゃら 帯解駅 15 2 4 ## 9 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅 4 1 4 ## 10 彩華ラーメン 田原本店 石見駅 15 1 4 ## 11 らーめん食堂 よってこや 平群店 元山上口駅 10 1 4 ## 12 神座 大和高田店 大和高田駅 17 2 3.75 ## 13 彩華ラーメン 本店 前栽駅 12 5 3.6 ## 14 天下一品 東生駒店 東生駒駅 19 1 3.5 ## 15 力皇 天理駅 13 1 3.5 ## 16 博多長浜らーめん夢街道 奈良土橋店 真菅駅 11 1 3.5 ## 17 ラーメン家 みつ葉 富雄駅 4 1 3.5 ## 18 丸源ラーメン 橿原店 金橋駅 8 1 3.5 ## 19 天理スタミナラーメン本店 櫟本駅 11 2 3.25 ## 20 麺屋 一徳 天理駅 7 1 3 ## 21 どうとんぼり神座 奈良柏木店 西ノ京駅 22 1 3 ## 22 彩華ラーメン 桜井店 大福駅 18 1 3 ## 23 天下一品 新大宮店 新大宮駅 6 1 3 ## 24 博多長浜らーめん 夢街道 四条大路店 新大宮駅 29 4 2.88 よく考えてみれば、「評価が同点の場合、どうなるの?」と疑問を抱く方がいるかも知れません。たとえば、7行目の「河童ラーメン本舗 押熊店」と8行目の「無鉄砲がむしゃら」はどれも評価が4点ですが、「河童ラーメン本舗 押熊店」が先に表示されます。そのこれは簡単です。同点の場合、データセット内で上に位置する行が先に表示されます。これを確認するにはwhich()関数を使います。()内に条件文を指定することで、この条件に合致する要素の位置を返します。もし、条件に合致するものが複数あった場合は全ての位置を返します58。 which(df$Name == &quot;河童ラーメン本舗 押熊店&quot;) ## [1] 6021 which(df$Name == &quot;無鉄砲がむしゃら&quot;) ## [1] 6040 データ内に「河童ラーメン本舗 押熊店」がより上に位置することが分かります。「もし同点なら口コミ評価数が多いところにしたい」場合はどうすれば良いでしょうか。これはarrange()内に変数名を足すだけで十分です。 df %&gt;% filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;% select(Name, Station, Walk, ScoreN, Score) %&gt;% arrange(desc(Score), desc(ScoreN)) %&gt;% print(n = Inf) ## # A tibble: 24 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 まりお流ラーメン 新大宮駅 20 1 5 ## 2 ぶ～け 奈良駅 11 1 5 ## 3 麺屋 あまのじゃく 本店 富雄駅 2 2 4.5 ## 4 らーめん きみちゃん 京終駅 14 2 4.5 ## 5 彩華ラーメン 奈良店 尼ヶ辻駅 17 3 4.33 ## 6 つけめん らーめん元喜神 押熊店 学研奈良登美ヶ丘駅 12 4 4.12 ## 7 無鉄砲がむしゃら 帯解駅 15 2 4 ## 8 河童ラーメン本舗 押熊店 学研奈良登美ヶ丘駅 28 1 4 ## 9 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅 4 1 4 ## 10 彩華ラーメン 田原本店 石見駅 15 1 4 ## 11 らーめん食堂 よってこや 平群店 元山上口駅 10 1 4 ## 12 神座 大和高田店 大和高田駅 17 2 3.75 ## 13 彩華ラーメン 本店 前栽駅 12 5 3.6 ## 14 天下一品 東生駒店 東生駒駅 19 1 3.5 ## 15 力皇 天理駅 13 1 3.5 ## 16 博多長浜らーめん夢街道 奈良土橋店 真菅駅 11 1 3.5 ## 17 ラーメン家 みつ葉 富雄駅 4 1 3.5 ## 18 丸源ラーメン 橿原店 金橋駅 8 1 3.5 ## 19 天理スタミナラーメン本店 櫟本駅 11 2 3.25 ## 20 麺屋 一徳 天理駅 7 1 3 ## 21 どうとんぼり神座 奈良柏木店 西ノ京駅 22 1 3 ## 22 彩華ラーメン 桜井店 大福駅 18 1 3 ## 23 天下一品 新大宮店 新大宮駅 6 1 3 ## 24 博多長浜らーめん 夢街道 四条大路店 新大宮駅 29 4 2.88 ソートの基準はarrange()内において先に指定された変数の順番となります。「口コミ評価も評価数も同じなら、駅から近いところにしたい」場合は変数が3つとなり、Score、ScoreN、Walkの順で入れます。 df %&gt;% filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;% select(Name, Station, Walk, ScoreN, Score) %&gt;% arrange(desc(Score), desc(ScoreN), Walk) %&gt;% print(n = Inf) ## # A tibble: 24 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ぶ～け 奈良駅 11 1 5 ## 2 まりお流ラーメン 新大宮駅 20 1 5 ## 3 麺屋 あまのじゃく 本店 富雄駅 2 2 4.5 ## 4 らーめん きみちゃん 京終駅 14 2 4.5 ## 5 彩華ラーメン 奈良店 尼ヶ辻駅 17 3 4.33 ## 6 つけめん らーめん元喜神 押熊店 学研奈良登美ヶ丘駅 12 4 4.12 ## 7 無鉄砲がむしゃら 帯解駅 15 2 4 ## 8 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅 4 1 4 ## 9 らーめん食堂 よってこや 平群店 元山上口駅 10 1 4 ## 10 彩華ラーメン 田原本店 石見駅 15 1 4 ## 11 河童ラーメン本舗 押熊店 学研奈良登美ヶ丘駅 28 1 4 ## 12 神座 大和高田店 大和高田駅 17 2 3.75 ## 13 彩華ラーメン 本店 前栽駅 12 5 3.6 ## 14 ラーメン家 みつ葉 富雄駅 4 1 3.5 ## 15 丸源ラーメン 橿原店 金橋駅 8 1 3.5 ## 16 博多長浜らーめん夢街道 奈良土橋店 真菅駅 11 1 3.5 ## 17 力皇 天理駅 13 1 3.5 ## 18 天下一品 東生駒店 東生駒駅 19 1 3.5 ## 19 天理スタミナラーメン本店 櫟本駅 11 2 3.25 ## 20 天下一品 新大宮店 新大宮駅 6 1 3 ## 21 麺屋 一徳 天理駅 7 1 3 ## 22 彩華ラーメン 桜井店 大福駅 18 1 3 ## 23 どうとんぼり神座 奈良柏木店 西ノ京駅 22 1 3 ## 24 博多長浜らーめん 夢街道 四条大路店 新大宮駅 29 4 2.88 10.6 練習問題 実はselect(starts_with(\"X\"), -ends_with(\"D\"), ID)のように順番を変えるとIDは最後の列になりますが、とりあえず残ります。なぜなら、select()関数は左側から右側の方へコードを実行するからです。↩︎ 実はselect.df[, c(2, 8, 9)]でも前後にパイプ演算子を使うことは可能ですが、コードが読みにくくなるため、推奨しません。↩︎ サービスによってはこの機能が有料になっていたりもしますね。↩︎ たとえば、データ内に「ラーメンショップ」という店舗は3店舗あり、この場合、長さ3のベクトルが返されます。↩︎ "],
["datahandling2.html", "11. データハンドリング [基礎編: 拡張] 11.1 記述統計量の計算 11.2 グルーピング 11.3 変数の計算 11.4 行単位の操作 11.5 データの結合 11.6 練習問題", " 11. データハンドリング [基礎編: 拡張] 前章ではデータの一部 (subset)を抽出する方法について説明しましたが、本章はデータを拡張する、あるいは全く別のデータが得られるような処理について解説します。後者は主に元のデータを要約し (記述統計量)、その結果を出力する方法で、前者はデータ内の変数に基づき、指定された計算を行った結果を新しい列として追加する方法です。今回も前章と同じデータを使用します。 # データのパスは適宜修正すること # 文字化けが生じる場合、以下のコードに書き換える。 # df &lt;- read_csv(&quot;Data/Ramen.csv&quot;, locale = locale(encoding = &quot;utf8&quot;)) df &lt;- read_csv(&quot;Data/Ramen.csv&quot;) ## Parsed with column specification: ## cols( ## ID = col_character(), ## Name = col_character(), ## Pref = col_character(), ## Zipcode = col_double(), ## Latitude = col_double(), ## Longitude = col_double(), ## Line = col_character(), ## Station = col_character(), ## Walk = col_double(), ## Bus = col_double(), ## Car = col_double(), ## Budget = col_double(), ## ScoreN = col_double(), ## Score = col_double() ## ) データの詳細については第10.3章を参照してください。 11.1 記述統計量の計算 11.1.1 summarise()による記述統計量の計算 ある変数の平均値や標準偏差、最小値、最大値などの記述統計量 (要約統計量)を計算することも可能です。これはsummarize()またはsummarise()関数を使いますが、この関数は後で紹介するgroup_by()関数と組み合わせることで力を発揮します。ここではグルーピングを考えずに、全データの記述統計量を計算する方法を紹介します。 summarise()関数の使い方は以下の通りです。 # summarise()関数の使い方 データフレーム名 %&gt;% summarise(新しい変数名 = 関数名(計算の対象となる変数名)) もし、Score変数の平均値を計算し、その結果をMeanという列にしたい場合は以下のようなコードになります。 df %&gt;% summarise(Mean = mean(Score)) ## # A tibble: 1 x 1 ## Mean ## &lt;dbl&gt; ## 1 NA ただし、mean()関数は欠損値が含まれるベクトルの場合、NAを返します。この場合方法は2つ考えられます。 filter()関数を使ってScoreが欠損しているケースを予め除去する。 na.rm引数を指定し、欠損値を除去した平均値を求める。 ここでは2番目の方法を使います。 df %&gt;% summarise(Mean = mean(Score, na.rm = TRUE)) ## # A tibble: 1 x 1 ## Mean ## &lt;dbl&gt; ## 1 3.66 dfのScore変数の平均値はNAであることが分かります。また、summarise()関数は複数の記述統計量を同時に計算することも可能です。以下はScore変数の平均値、中央値、標準偏差、最小値、最大値、第一四分位点、第三四分位点を計算し、Score.Descという名のデータフレームに格納するコードです。 Score.Desc &lt;- df %&gt;% summarize(Mean = mean(Score, na.rm = TRUE), # 平均値 Median = median(Score, na.rm = TRUE), # 中央値 SD = sd(Score, na.rm = TRUE), # 標準偏差 Min = min(Score, na.rm = TRUE), # 最小値 Max = max(Score, na.rm = TRUE), # 最大値 Q1 = quantile(Score, 0.25, na.rm = TRUE), # 第一四分位点 Q3 = quantile(Score, 0.75, na.rm = TRUE)) # 第三四分位点 Score.Desc ## # A tibble: 1 x 7 ## Mean Median SD Min Max Q1 Q3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3.66 3.58 0.719 1 5 3 4 むろん、複数の変数に対して記述統計量を計算することも可能です。たとえば、平均予算 (Budget)、口コミ数 (ScoreN)、口コミ評価 (Score)の平均値を求めるとしたら、 df %&gt;% summarize(Budget_Mean = mean(Budget, na.rm = TRUE), # 平均予算の平均値 SocreN_Mean = mean(ScoreN, na.rm = TRUE), # 口コミ数の平均値 Score_Mean = mean(Score, na.rm = TRUE)) # 評価の平均値 ## # A tibble: 1 x 3 ## Budget_Mean SocreN_Mean Score_Mean ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1232. 0.537 3.66 のように書きます。実はsummarise()はこれくらいで十分便利です。ただし、以上の操作はもっと簡単なコードに置換できます。ただし、ラムダ式など、やや高度な内容になるため、以下の内容は飛ばして、次の節 (グルーピング)を読んでいただいても構いません。 まずは、複数の変数に対して同じ記述統計量を求める例を考えてみましょう。たとえば、Budget、ScoreN、Scoreに対して平均値を求める例です。これはacross()関数を使うとよりコードが短くなります。まずはacross()関数の書き方から見ましょう。 # across()の使い方 データフレーム名 %&gt;% summarise(across(変数名のベクトル, 記述統計を計算する関数名, 関数の引数)) 変数名のベクトルは長さ1以上のベクトルです。たとえば、Budget、ScoreN、Scoreの場合c(Budget, ScoreN, Score)になります。これはdf内で隣接する変数ですからBudget:Scoreの書き方も使えます。また、where()やany_of()、starts_with()のような関数を使って変数を指定することも可能です。関数名はmeanやsdなどの関数名です。ここは関数名()でななく、関数名であることに注意してください。引数は前の関数に必要な引数です。引数を必要としない関数なら省略可能ですが、na.rm = TRUEなどの引数が必要な場合は指定する必要があります。それではBudget、ScoreN、Scoreの平均値を計算してみましょう。 df %&gt;% summarize(across(Budget:Score, mean, na.rm = TRUE)) ## # A tibble: 1 x 3 ## Budget ScoreN Score ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1232. 0.537 3.66 across()使わない場合、4行必要だったコードが2行になりました。変数が少ない場合はacross()を使わない方が、可読性が高くなる場合もあります。しかし、変数が多くなる場合、可読性がやや落ちてもacross()を使った方が効率的でしょう。 次は、ある変数に対して複数の記述統計量を計算したい場合について考えます。Budget、ScoreN、Score変数の第一四分位点と第三四分位点をacross()を使わずに計算すると家のような7行のコードになります。 df %&gt;% summarize(Budget_Q1 = quantile(Budget, 0.25, na.rm = TRUE), Budget_Q3 = quantile(Budget, 0.75, na.rm = TRUE), ScoreN_Q1 = quantile(ScoreN, 0.25, na.rm = TRUE), ScoreN_Q3 = quantile(ScoreN, 0.75, na.rm = TRUE), Score_Q1 = quantile(Score, 0.25, na.rm = TRUE), Score_Q3 = quantile(Score, 0.75, na.rm = TRUE)) ## # A tibble: 1 x 6 ## Budget_Q1 Budget_Q3 ScoreN_Q1 ScoreN_Q3 Score_Q1 Score_Q3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 800 1000 0 0 3 4 この作業もacross()を使ってより短縮することができます。ここではラムダ式の知識が必要になります。ラムダ関数とは関数名を持たない無名関数 (anonymous functions)を意味しますが、詳細は割愛します。興味のある読者はWikipediaなどを参照してください。簡単にいうとその場で即席に関数を作成し、計算が終わったら破棄する関数です。ただ、Rは基本的にラムダ式を提供しているのではなく、purrrパッケージのラムダ式スタイルを使用します。まずは、書き方から確認します。 # ラムダ式を用いたacross()の使い方 データフレーム名 %&gt;% summarise(across(変数名のベクトル, .fns = list(結果の変数名 = ラムダ式))) 先ほどの書き方と似ていますが、関数を複数書く必要があるため、今回は関数名をlist型にまとめ、.fns引数に指定します。そして、結果の変数名は結果として出力されるデータフレームの列名を指定する引数です。たとえば、Meanにすると結果は元の変数名1_Mean、元の変数名2_Mean…のように出力されます。そして、ラムダ式が実際の関数が入る箇所です。とりあえず今回はコードを走らせ、結果から確認してみましょう。 df %&gt;% summarize(across(Budget:Score, .fns = list(Q1 = ~quantile(.x, 0.25, na.rm = TRUE), Q3 = ~quantile(.x, 0.75, na.rm = TRUE)))) ## # A tibble: 1 x 6 ## Budget_Q1 Budget_Q3 ScoreN_Q1 ScoreN_Q3 Score_Q1 Score_Q3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 800 1000 0 0 3 4 結果の列名がBudget_Q1、Budget_Q3、ScoreN_Q1…のようになり、それぞれの変数の第一四分位点と第三四分位点が出力されます。問題はラムダ式の方ですが、普通の関数に非常に近いことが分かります。across()内のラムダ式は~関数名(.x, その他の引数)のような書き方になります。関数名の前に~が付いていることに注意してください。分位数を求める関数はquantile()であり、quantile(ベクトル, 分位数)であり、必要に応じてna.rmを付けます。この分位数が0.25なら第一四分位点、0.5なら第二四分位点 (=中央値)、0.75なら第三四分位点になります。それではラムダ式~quantile(.x, 0.25, na.rm = TRUE)はどういう意味でしょうか。これは.xの箇所にBudgetやScoreN、Scoreが入ることを意味します。.xという書き方は決まりです。.yとか.Song-san-Daisukiなどはダメです。そして、0.25を付けることによって第一四分位点を出力するように指定します。また、Budget、ScoreN、Scoreに欠損値がある場合、無視するようにna.rm = TRUEを付けます。 ラムダ式を第9章で解説した自作関数で表現すると、以下のようになります。 # 以下の3つは同じ機能をする関数である # ラムダ式 ~quantile(.x, 0.25, na.rm = TRUE) # 一般的な関数の書き方1 名無し関数 &lt;- function(x) { quantile(x, 0.25, na.rm = TRUE) } # 一般的な関数の書き方2 名無し関数 &lt;- function(x) quantile(x, 0.25, na.rm = TRUE) この3つは全て同じですが、ラムダ式は関数名を持たず、その場で使い捨てる関数です。むろん、ラムダ式を使わずに事前に第一四分位点と第三四分位点を求める関数を予め作成し、ラムダ式の代わりに使うことも可能です。まずは第一四分位点と第三四分位点を求める自作関数FuncQ1とFuncQ2を作成します。 # ラムダ式を使わない場合は事前に関数を定義しておく必要がある FuncQ1 &lt;- function(x) { quantile(x, 0.25, na.rm = TRUE) } FuncQ3 &lt;- function(x) { quantile(x, 0.75, na.rm = TRUE) } 後は先ほどのほぼ同じ書き方ですが、今回はラムダ式を使わないため関数名に~を付けず、関数名のみで十分です。()も不要です。 # やっておくと、summarise()文は簡潔になる df %&gt;% summarize(across(Budget:Score, list(Q1 = FuncQ1, Q3 = FuncQ3))) ## # A tibble: 1 x 6 ## Budget_Q1 Budget_Q3 ScoreN_Q1 ScoreN_Q3 Score_Q1 Score_Q3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 800 1000 0 0 3 4 事前に関数を用意するのが面倒ですが、across()の中身はかなりスッキリしますね。もし、このような作業を何回も行うなら、ラムダ式を使わず、自作関数を用いることも可能です。ただし、自作関数であっても引数が2つ以上必要な場合はラムダ式を使います。 11.1.2 summarise()に使える便利な関数 以下の内容は後で説明するgroup_by()関数を使っているため、まだgroup_by()に馴染みのない読者はまずはここを読み飛ばし、グルーピングの節にお進みください。 IQR(): 四分位範囲を求める 四分位範囲は第三四分位点から第一四分位点を引いた値であり、Rの内蔵関数であるIQR()を使えば便利です。この関数はmeanやsd()関数と同じ使い方となります。 df %&gt;% filter(!is.na(Walk)) %&gt;% # 予め欠損したケースを除くと、後でna.rm = TRUEが不要 group_by(Pref) %&gt;% summarise(Mean = mean(Walk), SD = sd(Walk), IQR = IQR(Walk), N = n(), .groups = &quot;drop&quot;) %&gt;% arrange(Mean) ## # A tibble: 9 x 5 ## Pref Mean SD IQR N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 東京都 4.29 4.49 4 919 ## 2 大阪府 5.92 6.08 6 932 ## 3 神奈川県 8.21 7.91 10 878 ## 4 京都府 8.38 6.95 9 339 ## 5 兵庫県 8.52 7.27 10 484 ## 6 奈良県 10.6 6.59 10 123 ## 7 千葉県 10.6 8.21 12 776 ## 8 埼玉県 11.6 8.99 14 817 ## 9 和歌山県 12.8 6.83 9 107 first()、last()、nth(): n番目の要素を求める 稀なケースかも知れませんが、データ内、またはグループ内のn番目の行を抽出する時があります。たとえば、市区町村の情報が格納されているデータセットで、人口が大きい順でデータがソートされているとします。各都道府県ごとに最も人口が大きい市区町村のデータ、あるいは最も少ない市区町村のデータが必要な際、first()とlast()関数が有効です。 それでは各都道府県ごとに「最も駅から遠いラーメン屋」の店舗名と最寄りの駅からの徒歩距離を出力したいとします。まずは、徒歩距離のデータが欠損しているケースを除去し、データを徒歩距離順でソートします。これはfilter()とarrange()関数を使えば簡単です。続いて、group_by()を使って都府県単位でデータをグループ化します。最後にsummarise()関数内にlast()関数を使います。データは駅から近い順に鳴っているため、各都府県内の最後の行は駅から最も遠い店舗になるからです。 df %&gt;% filter(!is.na(Walk)) %&gt;% arrange(Walk) %&gt;% group_by(Pref) %&gt;% summarise(Farthest = last(Name), Distance = last(Walk)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 9 x 3 ## Pref Farthest Distance ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 京都府 熱烈らぁめん 30 ## 2 埼玉県 札幌ラーメン どさん子 小鹿野店 116 ## 3 神奈川県 札幌ラーメン どさん子 中津店 73 ## 4 千葉県 札幌ラーメン どさん子 佐原51号店 59 ## 5 大阪府 河童ラーメン本舗 岸和田店 38 ## 6 東京都 てんがら 青梅新町店 30 ## 7 奈良県 博多長浜らーめん 夢街道 四条大路店 29 ## 8 兵庫県 濃厚醤油 中華そば いせや 玉津店 43 ## 9 和歌山県 中華そば まる乃 30 このlast()をfirst()に変えると、最寄りの駅から最も近い店舗情報が表示されます。また、「n番目の情報」が必要な際はnth()関数を使います。nth(Name, 2)に変えることで2番目の店舗名が抽出できます。 n_distinct(): ユニーク値の個数を求める n_distinct()は何種類の要素が含まれているかを計算する関数であり、length(unique())関数と同じ機能をします。たとえば、以下のmyVec1に対して何種類の要素があるかを確認してみましょう。 myVec1 &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;D&quot;, &quot;A&quot;, &quot;B&quot;, &quot;D&quot;, &quot;C&quot;, &quot;A&quot;) unique(myVec1) ## [1] &quot;A&quot; &quot;B&quot; &quot;D&quot; &quot;C&quot; myVec1は\"A\"、\"B\"、\"D\"、\"C\"の要素で構成されていることが分かります。これがmyVec1のユニーク値 (unique values)です。そして、このユニーク値の個数を調べるためにlength()を使います。 length(unique(myVec1)) ## [1] 4 これでmyVec1は4種類の値が存在することが分かります。これと全く同じ機能をする関数がn_distinct()です。 n_distinct(myVec1) ## [1] 4 この関数をsummarise()に使うことで、都府県ごとに駅の個数が分かります。あるいは「東京都内の選挙区に、これまでの衆院選において何人の候補者が存在したか」も分かります。ここではdf内の都府県ごとに駅の個数を計算してみましょう。最後の駅数が多い順でソートします。 df %&gt;% filter(!is.na(Station)) %&gt;% # 最寄りの駅が欠損しているケースを除去 group_by(Pref) %&gt;% summarise(N_Station = n_distinct(Station), .groups = &quot;drop&quot;) %&gt;% arrange(desc(N_Station)) ## # A tibble: 9 x 2 ## Pref N_Station ## &lt;chr&gt; &lt;int&gt; ## 1 東京都 368 ## 2 大阪府 341 ## 3 千葉県 241 ## 4 神奈川県 240 ## 5 兵庫県 199 ## 6 埼玉県 185 ## 7 京都府 123 ## 8 奈良県 52 ## 9 和歌山県 46 当たり前かも知れませんが、駅数が最も多いのは東京都で次が大阪府であることが分かります。 any()、all(): 条件に合致するか否かを求める any()とall()はベクトル内の全要素に対して条件に合致するか否かを判定する関数です。ただし、any()は一つの要素でも条件に合致すればTRUEを、全要素が合致しない場合FALSEを返します。一方、all()は全要素に対して条件を満たせばTRUE、一つでも満たさない要素があればFALSEを返します。以下はany()とall()の例です。 myVec1 &lt;- c(1, 2, 3, 4, 5) myVec2 &lt;- c(1, 3, 5, 7, 11) any(myVec1 %% 2 == 0) # myVec1を2で割った場合、一つでも余りが0か ## [1] TRUE all(myVec1 %% 2 == 0) # myVec1を2で割った場合、全ての余りが0か ## [1] FALSE all(myVec2 %% 2 != 0) # myVec2を2で割った場合、全ての余りが0ではないか ## [1] TRUE それでは実際にdfに対してany()とall()関数を使ってみましょう。一つ目は「ある都府県に最寄りの駅から徒歩60分以上の店舗が一つでもあるか」であり、二つ目は「ある都府県の店舗は全て最寄りの駅から徒歩30分以下か」です。それぞれの結果をOver60とWithin30という列で出力してみましょう。 df %&gt;% group_by(Pref) %&gt;% summarise(Over60 = any(Walk &gt;= 60, na.rm = TRUE), Within30 = all(Walk &lt;= 30, na.rm = TRUE), .groups = &quot;drop&quot;) ## # A tibble: 9 x 3 ## Pref Over60 Within30 ## &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; ## 1 京都府 FALSE TRUE ## 2 埼玉県 TRUE FALSE ## 3 神奈川県 TRUE FALSE ## 4 千葉県 FALSE FALSE ## 5 大阪府 FALSE FALSE ## 6 東京都 FALSE TRUE ## 7 奈良県 FALSE TRUE ## 8 兵庫県 FALSE FALSE ## 9 和歌山県 FALSE TRUE 埼玉県と神奈川県において、最寄りの駅から徒歩60以上の店がありました。また、京都府、東京都、奈良県、和歌山県の場合、全店舗が最寄りの駅から徒歩30分以下ということが分かります。当たり前ですがOver60がTRUEならWithin30は必ずFALSEになりますね。 11.2 グルーピング 11.2.1 group_by()によるグループ化 先ほどのsummarise()関数は確かに便利ですが、特段に便利とも言いにくいです。dfのScoreの平均値を計算するだけなら、summarise()関数を使わない方が楽です。 # これまでのやり方 df %&gt;% summarise(Mean = mean(Score, na.rm = TRUE)) ## # A tibble: 1 x 1 ## Mean ## &lt;dbl&gt; ## 1 3.66 # 普通にこれでええんちゃう? mean(df$Score, na.rm = TRUE) ## [1] 3.663457 しかし、これをグループごとに計算するならどうでしょう。たとえば、Scoreの平均値を都府県ごとに計算するとします。この場合、以下のようなコードになります。 mean(df$Score[df$Pref == &quot;東京都&quot;], na.rm = TRUE) ## [1] 3.674256 mean(df$Score[df$Pref == &quot;神奈川県&quot;], na.rm = TRUE) ## [1] 3.533931 mean(df$Score[df$Pref == &quot;千葉県&quot;], na.rm = TRUE) ## [1] 3.715983 mean(df$Score[df$Pref == &quot;埼玉県&quot;], na.rm = TRUE) ## [1] 3.641573 mean(df$Score[df$Pref == &quot;大阪府&quot;], na.rm = TRUE) ## [1] 3.765194 mean(df$Score[df$Pref == &quot;京都府&quot;], na.rm = TRUE) ## [1] 3.684976 mean(df$Score[df$Pref == &quot;兵庫県&quot;], na.rm = TRUE) ## [1] 3.543936 mean(df$Score[df$Pref == &quot;奈良県&quot;], na.rm = TRUE) ## [1] 3.854762 mean(df$Score[df$Pref == &quot;和歌山県&quot;], na.rm = TRUE) ## [1] 3.96999 変わったのはdf$Scoreがdf$Score[df$Pref == \"東京都\"]に変わっただけです。df$Prefが\"東京都\"であるか否かをTRUEとFALSEで判定し、これを基準にdf$Scoreを抽出する仕組みです。df$Scoreとdf$Prefは同じデータフレームですから、このような書き方で問題ありません。 これだけでもかなり書くのが面倒ですが、これが47都道府県なら、あるいは200ヶ国ならかなり骨の折れる作業でしょう。ここで大活躍するのがdplyrパッケージのgroup_by()関数です。引数はグループ化する変数名だけです。先ほどの作業をdplyrを使うならPref変数でグループ化し、summarise()関数で平均値を求めるだけです。今回はScoreだけでなく、ScoreNの平均値も求めてみましょう。そして、評価が高い順にソートもしてみます。 # ScoreNとScoreの平均値をPrefごとに求める df %&gt;% group_by(Pref) %&gt;% summarise(ScoreN_Mean = mean(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE)) %&gt;% arrange(desc(Score_Mean)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 9 x 3 ## Pref ScoreN_Mean Score_Mean ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 和歌山県 0.593 3.97 ## 2 奈良県 0.306 3.85 ## 3 大阪府 0.516 3.77 ## 4 千葉県 0.259 3.72 ## 5 京都府 0.522 3.68 ## 6 東京都 1.16 3.67 ## 7 埼玉県 0.278 3.64 ## 8 兵庫県 0.389 3.54 ## 9 神奈川県 0.587 3.53 評判が最も高い都府県は和歌山県、最も低いのは神奈川県ですね。Songも和歌山ラーメンは井出系も車庫前系も好きです。しかし、大事なのは「井出系」と「車庫前系」といった分類が正しいかどうかではありません。コードが非常に簡潔となり、ソートなども自由自在であることです。都府県ごとにScoreNとScoreの平均値を求める場合、dplyr()を使わなかったら18行のコードとなり、ソートも自分でやる必要があります。一方、group_by()関数を使うことによってコードが5行になりました。 また、これは2020年6月に公開されたdplyr1.0.0からの問題ですが、group_by()の後にsummarise()を使うと以下のようなメッセージが出力されます。 ## `summarise()` ungrouping output (override with `.groups` argument) これはgroup_by()で指定された変数のグループ化が自動的に解除されたことを意味します。なぜならsummarise()をする際はPrefをグループ変数として使いましたが、出力された結果のPref変数はもはやグループとして機能できなくなるからです。元のdfにはPrefが\"東京都\"だったケースが1000行、\"京都府\"だったのが414行あったので、Pref変数でグループ化する意味がありました。しかし、summarise()から得られたデータフレームはPref == \"東京都\"の行が1つしかありません。これはグループ化する意味がなくなったことを意味します。したがって、自動的にグループを解除してくれます。自動的にやってくれるのはありがたいことですが、可能ならば関数内に自分で明記することが推奨されます。そこで使う引数が.groupsであり、\"drop\"を指定すると全てのグループ化変数を解除します。以下のようなコードだと先ほどのメッセージが表示されません。今後、意識的に入れるようにしましょう。 # ScoreNとScoreの平均値をPrefごとに求める df %&gt;% group_by(Pref) %&gt;% summarise(ScoreN_Mean = mean(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(desc(Score_Mean)) ## # A tibble: 9 x 3 ## Pref ScoreN_Mean Score_Mean ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 和歌山県 0.593 3.97 ## 2 奈良県 0.306 3.85 ## 3 大阪府 0.516 3.77 ## 4 千葉県 0.259 3.72 ## 5 京都府 0.522 3.68 ## 6 東京都 1.16 3.67 ## 7 埼玉県 0.278 3.64 ## 8 兵庫県 0.389 3.54 ## 9 神奈川県 0.587 3.53 続いて、一つ便利な関数を紹介します。それはグループのサイズを計算する関数、n()です。この関数をsummarise()内に使うと、各グループに属するケース数を出力します。先ほどのコードを修正し、各グループのサイズをNという名の列として追加してみましょう。そしてソートの順番はNを最優先とし、同じ場合はScore_Meanが高い方を上に出力させます。また、ScoreN_Meanの前に、口コミ数の合計も出してみましょう。 # Prefごとに口コミ数の合計、口コミ数の平均値、評価の平均値、店舗数を求める # 店舗数-評価の平均値順でソートする df %&gt;% group_by(Pref) %&gt;% summarise(ScoreN_Sum = sum(ScoreN, na.rm = TRUE), ScoreN_Mean = mean(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), N = n(), .groups = &quot;drop&quot;) %&gt;% arrange(desc(N), desc(Score_Mean)) ## # A tibble: 9 x 5 ## Pref ScoreN_Sum ScoreN_Mean Score_Mean N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 大阪府 516 0.516 3.77 1000 ## 2 千葉県 259 0.259 3.72 1000 ## 3 東京都 1165 1.16 3.67 1000 ## 4 埼玉県 278 0.278 3.64 1000 ## 5 神奈川県 587 0.587 3.53 1000 ## 6 兵庫県 230 0.389 3.54 591 ## 7 京都府 216 0.522 3.68 414 ## 8 奈良県 45 0.306 3.85 147 ## 9 和歌山県 83 0.593 3.97 140 記述統計をグループごとに求めるのは普通にあり得るケースですし、実験データの場合はほぼ必須の作業でう。統制群と処置群間においてグループサイズが均一か、共変量のバラツキが十分に小さいかなどを判断する際にgroup_by()とsummarise()関数の組み合わせは非常に便利です。 11.2.2 複数の変数を用いたグループ化 グループ化変数は2つ以上指定することも可能です。たとえば、都府県 (Pref)と最寄りの駅の路線 (Line)でグループ化することも可能です。それではPrefとLineでグループ化し、店舗数と口コミ数、評価の平均値を計算し、ソートの順番は店舗数、店舗数が同じなら評価の平均値が高い順にしましょう。今回もsummarise()内に.group = \"drop\"を指定し、グループ化を解除します。今回はTop 20まで出してみましょう。 # ScoreNとScoreの平均値をPrefごとに求める df %&gt;% filter(!is.na(Line)) %&gt;% # Lineが欠損していないケースのみ残す group_by(Pref, Line) %&gt;% # PrefとLineでグループ化 summarise(N = n(), ScoreN_Sum = sum(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(desc(N), desc(Score_Mean)) %&gt;% print(n = 20) ## # A tibble: 523 x 5 ## Pref Line N ScoreN_Sum Score_Mean ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 埼玉県 東武東上線 122 27 3.68 ## 2 東京都 ＪＲ 104 231 3.56 ## 3 神奈川県 小田急小田原線 96 31 3.59 ## 4 埼玉県 東武伊勢崎線 96 18 3.51 ## 5 神奈川県 横浜市営ブルーライン 82 77 3.66 ## 6 千葉県 京成本線 82 29 3.34 ## 7 神奈川県 京急本線 68 40 3.33 ## 8 千葉県 東武野田線 63 2 4.75 ## 9 神奈川県 小田急江ノ島線 62 8 3.79 ## 10 大阪府 阪急京都本線 53 32 3.67 ## 11 大阪府 南海本線 52 11 4.22 ## 12 兵庫県 阪神本線 52 23 3.80 ## 13 埼玉県 JR高崎線 51 5 4 ## 14 兵庫県 山陽電鉄本線 51 15 2.98 ## 15 千葉県 JR総武本線（東京-銚子） 47 8 4 ## 16 埼玉県 西武新宿線 45 8 4.17 ## 17 埼玉県 秩父鉄道線 43 10 3.82 ## 18 大阪府 京阪本線 43 10 3.69 ## 19 千葉県 新京成電鉄 43 6 3.6 ## 20 京都府 阪急京都本線 43 27 3.5 ## # … with 503 more rows ぐるなびに登録されているラーメン屋が最も多い路線は埼玉県内の東武東上線で122店舗があります。東武東上線は東京都と埼玉県をまたがる路線ですので、東武東上線だけならもっと多いかも知れませんね。 ここで一つ考えたいのはsummarise()内の.groups引数です。前回はグループ化に使った変数ごとに1行しか残っていなかったのでグループ化を全て解除しました。しかし、今回は状況がやや異なります。グループ化変数に使ったPrefを考えると、まだPref == \"東京都\"であるケースがいくつかあります。やろうとすればまだグループ化出来る状態です。これはLineについても同じです。Line == \"東武東上線\"の行はここには表示されていないものの、まだデータに残っています。もし、これ以上グループ化しないなら今のように.groups = \"drop\"が正しいですが、もしもう一回グループ化したい場合はどうすればよいでしょうか。方法は2つ考えられます。 もう一度パイプ演算子を使ってgroup_by()関数を使う (以下の9行目)。 結果を見ると## # Groups: Pref, Line [523]で、ちゃんとグループ化されていることが分かります。 df %&gt;% filter(!is.na(Line)) %&gt;% group_by(Pref, Line) %&gt;% summarise(N = n(), ScoreN_Sum = sum(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(desc(N), desc(Score_Mean)) %&gt;% group_by(Pref, Line) %&gt;% # group_by()、もう一度 print(n = 5) ## # A tibble: 523 x 5 ## # Groups: Pref, Line [523] ## Pref Line N ScoreN_Sum Score_Mean ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 埼玉県 東武東上線 122 27 3.68 ## 2 東京都 ＪＲ 104 231 3.56 ## 3 神奈川県 小田急小田原線 96 31 3.59 ## 4 埼玉県 東武伊勢崎線 96 18 3.51 ## 5 神奈川県 横浜市営ブルーライン 82 77 3.66 ## # … with 518 more rows .groups引数を何とかする。 推奨される方法は2番です。具体的には.groups = \"keep\"を指定するだけであり、こっちの方が無駄なコードを省けることができます。 df %&gt;% filter(!is.na(Line)) %&gt;% group_by(Pref, Line) %&gt;% summarise(N = n(), ScoreN_Sum = sum(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), .groups = &quot;keep&quot;) %&gt;% arrange(desc(N), desc(Score_Mean)) %&gt;% print(n = 5) ## # A tibble: 523 x 5 ## # Groups: Pref, Line [523] ## Pref Line N ScoreN_Sum Score_Mean ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 埼玉県 東武東上線 122 27 3.68 ## 2 東京都 ＪＲ 104 231 3.56 ## 3 神奈川県 小田急小田原線 96 31 3.59 ## 4 埼玉県 東武伊勢崎線 96 18 3.51 ## 5 神奈川県 横浜市営ブルーライン 82 77 3.66 ## # … with 518 more rows .groups引数は\"drop\"と\"keep\"以外にも\"drop_last\"があります。実はsummarise()に.groups引数を指定したい場合のデフォルト値は.groups == \"drop_last\"または\"keep\"ですが、ここがややこしいです。主なケースにおいてデフォルト値は\"drop\"となりますとなります。.groups == \"drop_last\"これは最後のグループ化変数のみ解除する意味です。今回の例だと、2番目のグループ化変数であるLineがグループ化変数から外され、Prefのみがグループ化変数として残る仕組みです。 それではデフォルト値が\"keep\"になるのはいつでしょうか。それは記述統計量の結果が長さ2以上のベクトルである場合です。平均値を求めるmean()、標準偏差を求めるsd()などは、結果として長さ1のベクトルを返します。しかし、長さ2以上ののベクトルを返す関数もあります。たとえば、分位数を求めるquantile()関数があります。quantile(ベクトル名, 0.25)の場合、第一四分位点のみ返すため、結果は長さ1のベクトルです。しかし、quantile(ベクトル名, c(0.25, 0.5, 0.75))のように第一四分位点から第三四分位点を同時に計算し、長さ3のベクトルが返されるケースもありますし、第二引数を省略すると、最小値・第一四分位点・第二四分位点・第三四分位点・最大値、つまり、長さ5のベクトルが返される場合があります。 # 第一四分位点のみを求める (長さ1のベクトル) quantile(df$Walk, 0.25, na.rm = TRUE) ## 25% ## 2 # 引数を省略する (長さ5のベクトル) quantile(df$Walk, na.rm = TRUE) ## 0% 25% 50% 75% 100% ## 1 2 5 12 116 .groupsのデフォルト値が\"keep\"になるのは、このように長さ2以上のベクトルが返されるケースです。たとえば、都府県と最寄りの駅の路線でグループ化し、店舗までの徒歩距離の平均値を求めるとします。デフォルト値の変化を見るために、ここではあえて.groups引数を省略しました。 df %&gt;% filter(!is.na(Walk)) %&gt;% group_by(Pref, Line) %&gt;% summarise(Mean = mean(Walk)) ## `summarise()` regrouping output by &#39;Pref&#39; (override with `.groups` argument) ## # A tibble: 509 x 3 ## # Groups: Pref [9] ## Pref Line Mean ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 京都府 ＪＲ 4 ## 2 京都府 ＪＲ京都線 10 ## 3 京都府 ＪＲ嵯峨野線 5 ## 4 京都府 ＪＲ山陰本線 19 ## 5 京都府 ＪＲ山陰本線（京都-米子） 9.23 ## 6 京都府 JR山陰本線（京都-米子） 8.67 ## 7 京都府 JR小浜線 16.5 ## 8 京都府 ＪＲ小浜線 9 ## 9 京都府 ＪＲ東海道本線（米原-神戸） 11.2 ## 10 京都府 JR東海道本線（米原-神戸） 16.3 ## # … with 499 more rows 最初はPrefとLineでグループ化しましたが、summarise()の後、Lineがグループ化変数から外されました。つまり、引数が\"drop_last\"になっていることです。 それでは、平均値に加えて、第一四分位点と第三四分位点も計算し、Quantileという名で格納してみましょう。 df %&gt;% filter(!is.na(Walk)) %&gt;% group_by(Pref, Line) %&gt;% summarise(Mean = mean(Walk), Quantile = quantile(Walk, c(0.25, 0.75))) ## `summarise()` regrouping output by &#39;Pref&#39;, &#39;Line&#39; (override with `.groups` argument) ## # A tibble: 1,018 x 4 ## # Groups: Pref, Line [509] ## Pref Line Mean Quantile ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 京都府 ＪＲ 4 1.25 ## 2 京都府 ＪＲ 4 5 ## 3 京都府 ＪＲ京都線 10 10 ## 4 京都府 ＪＲ京都線 10 10 ## 5 京都府 ＪＲ嵯峨野線 5 4.5 ## 6 京都府 ＪＲ嵯峨野線 5 6 ## 7 京都府 ＪＲ山陰本線 19 19 ## 8 京都府 ＪＲ山陰本線 19 19 ## 9 京都府 ＪＲ山陰本線（京都-米子） 9.23 3 ## 10 京都府 ＪＲ山陰本線（京都-米子） 9.23 13 ## # … with 1,008 more rows 同じPref、Lineのケースが2つずつ出来ています。最初に来る数値は第一四分位点、次に来るのが第三四分位点です。そして最初のグループ化変数であったPrefとLineが、summarise()後もグループ化変数として残っていることが分かります。 .groups引数は記述統計量だけを計算する意味ではあまり意識する必要がありません。しかし、得られた記述統計量から何らかの計算をしたり、さらにもう一回記述統計量を求めたりする際、予期せぬ結果が得られる可能性があるため注意する必要があります。出来る限り.groups引数は指定するようにしましょう。 11.3 変数の計算 11.3.1 mutate()関数の使い方 続いて、データフレーム内の変数を用いて計算を行い、その結果を新しい列として格納するmutate()関数について紹介します。まず、mutate()関数の書き方からです。 # mutate()関数の使い方 データフレーム名 %&gt;% mutate(新しい変数名 = 処理内容) これは何らかの処理を行い、その結果を新しい変数としてデータフレームに追加することを意味します。新しく出来た変数は、基本的に最後の列になります。ここでは分単位であるWalkを時間単位に変換したWalk_Hour変数を作成するとします。処理内容はWalk / 60です。最後に、都府県名、店舗名、徒歩距離 (分)、徒歩距離 (時間)のみを残し、遠い順にソートします。 df %&gt;% filter(!is.na(Walk)) %&gt;% mutate(Walk_Hour = Walk / 60) %&gt;% select(Pref, Name, Walk, Walk_Hour) %&gt;% arrange(desc(Walk_Hour)) ## # A tibble: 5,375 x 4 ## Pref Name Walk Walk_Hour ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 埼玉県 札幌ラーメン どさん子 小鹿野店 116 1.93 ## 2 神奈川県 札幌ラーメン どさん子 中津店 73 1.22 ## 3 千葉県 札幌ラーメン どさん子 佐原51号店 59 0.983 ## 4 神奈川県 札幌ラーメン どさん子 山際店 50 0.833 ## 5 千葉県 札幌ラーメン どさん子 関宿店 49 0.817 ## 6 兵庫県 濃厚醤油 中華そば いせや 玉津店 43 0.717 ## 7 大阪府 河童ラーメン本舗 岸和田店 38 0.633 ## 8 埼玉県 ラーメン山岡家 上尾店 35 0.583 ## 9 兵庫県 濃厚醤油 中華そば いせや 大蔵谷店 35 0.583 ## 10 大阪府 河童ラーメン本舗 松原店 31 0.517 ## # … with 5,365 more rows mutate()は3行目に登場しますが、これはWalkを60に割った結果をWalk_Hourとしてデータフレームの最後の列として格納することを意味します。もし、最後の列でなく、ある変数の前、または後にしたい場合は、.beforeまたは.after引数を追加します。これはselect()関数の.beforeと.afterと同じ使い方です。たとえば、新しく出来たWalk_HourをIDとNameの間に入れたい場合は # コードの3行名を修正 (.before使用) mutate(Walk_Hour = Walk / 60, .before = Name) # コードの3行名を修正 (.after使用) mutate(Walk_Hour = Walk / 60, .after = ID) のようにコードを修正します。 むろん、変数間同士の計算も可能です。たとえば、以下のようなdf2があり、1店舗当たりの平均口コミ数を計算し、ScoreN_Meanという変数名でScoreN_Sumの後に格納うするとします。この場合、ScoreN_Sum変数をNで割るだけです。 df2 &lt;- df %&gt;% group_by(Pref) %&gt;% summarise(Budget_Mean = mean(Budget, na.rm = TRUE), ScoreN_Sum = sum(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), N = n(), .groups = &quot;drop&quot;) df2 %&gt;% mutate(ScoreN_Mean = ScoreN_Sum / N, .after = ScoreN_Sum) ## # A tibble: 9 x 6 ## Pref Budget_Mean ScoreN_Sum ScoreN_Mean Score_Mean N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 京都府 1399. 216 0.522 3.68 414 ## 2 埼玉県 1147. 278 0.278 3.64 1000 ## 3 神奈川県 1239. 587 0.587 3.53 1000 ## 4 千葉県 1124. 259 0.259 3.72 1000 ## 5 大阪府 1203. 516 0.516 3.77 1000 ## 6 東京都 1283. 1165 1.16 3.67 1000 ## 7 奈良県 1169. 45 0.306 3.85 147 ## 8 兵庫県 1197. 230 0.389 3.54 591 ## 9 和歌山県 1252 83 0.593 3.97 140 このように、データ内の変数を用いた計算結果を新しい列として追加する場合は、mutate()が便利です。これをmutate()を使わずに処理する場合、以下のようなコードになりますが、可読性が相対的に低いことが分かります。 df2$ScoreN_Mean &lt;- df2$ScoreN_Sum / df2$N df2 &lt;- df2[, c(&quot;Pref&quot;, &quot;Budget_Mean&quot;, &quot;Walk_Mean&quot;, &quot;ScoreN_Sum&quot;, &quot;ScoreN_Mean&quot;, &quot;Score_Mean&quot;, &quot;N&quot;)] むろんですが、計算には+や/のような演算子だけでなく、関数を使うことも可能です。たとえば、Budgetが1000円未満なら\"Cheap\"、1000円以上なら\"Expensive\"と示す変数Budget2を作成する場合はifelse()関数が使えます。 df %&gt;% mutate(Budget2 = ifelse(Budget &lt; 1000, &quot;Cheap&quot;, &quot;Expensive&quot;)) %&gt;% filter(!is.na(Budget2)) %&gt;% # Budget2が欠損した店舗を除外 group_by(Pref, Budget2) %&gt;% # PrefとBudget2でグループ化 summarise(N = n(), # 店舗数を表示 .groups = &quot;drop&quot;) ## # A tibble: 18 x 3 ## Pref Budget2 N ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 京都府 Cheap 22 ## 2 京都府 Expensive 28 ## 3 埼玉県 Cheap 37 ## 4 埼玉県 Expensive 45 ## 5 神奈川県 Cheap 66 ## 6 神奈川県 Expensive 54 ## 7 千葉県 Cheap 64 ## 8 千葉県 Expensive 72 ## 9 大阪府 Cheap 104 ## 10 大阪府 Expensive 115 ## 11 東京都 Cheap 206 ## 12 東京都 Expensive 236 ## 13 奈良県 Cheap 11 ## 14 奈良県 Expensive 10 ## 15 兵庫県 Cheap 39 ## 16 兵庫県 Expensive 27 ## 17 和歌山県 Cheap 10 ## 18 和歌山県 Expensive 5 これは各都府県ごとの予算1000円未満の店と以上の店の店舗数をまとめた表となります。もし、500円未満なら\"Cheap\"、500円以上~1000円未満なら\"Reasonable\"、1000円以上なら\"Expensive\"になるBudget3変数を作るにはどうすればよいでしょうか。第9章で紹介しましたifelse()を重ねることも出来ますが、ここではcase_when()関数が便利です。まずは、ifelse()を使ったコードは以下の通りです。 # ifelse()を使う場合 df %&gt;% mutate(Budget3 = ifelse(Budget &lt; 500, &quot;Cheap&quot;, ifelse(Budget &gt;= 500 &amp; Budget &lt; 1000, &quot;Reasonable&quot;, &quot;Expensive&quot;))) %&gt;% filter(!is.na(Budget3)) %&gt;% group_by(Pref, Budget3) %&gt;% summarise(N = n(), .groups = &quot;drop&quot;) case_when()を使うと以下のような書き方になります。 # ifelse()を使う場合 df %&gt;% mutate(Budget3 = case_when(Budget &lt; 500 ~ &quot;Cheap&quot;, Budget &gt;= 500 &amp; Budget &lt; 1000 ~ &quot;Reasonable&quot;, Budget &gt;= 1000 ~ &quot;Expensive&quot;), # 新しく出来た変数をfactor型にその場で変換することも可能 Budget3 = factor(Budget3, levels = c(&quot;Cheap&quot;, &quot;Reasonable&quot;, &quot;Expensive&quot;))) %&gt;% filter(!is.na(Budget3)) %&gt;% group_by(Pref, Budget3) %&gt;% summarise(N = n(), .groups = &quot;drop&quot;) 書く手間の観点ではcase_when()はifelse()と大きく違いはないかも知れませんが、コードが非常に読みやすくなっています。case_when()関数の書き方は以下の通りです。 # case_when()の使い方 データフレーム名 %&gt;% mutate(新変数名 = case_when(条件1 ~ 条件1を満たす場合の結果値, 条件2 ~ 条件2を満たす場合の結果値, 条件3 ~ 条件3を満たす場合の結果値, ...)) 似たような機能をする関数としてrecode()関数があります。これは変数の値を単純に置換したい場合に便利な関数です。たとえば、都府県名をローマ字に変換するケースを考えてみましょう。 # recode()を使う場合 df2 %&gt;% mutate(Pref2 = recode(Pref, &quot;東京都&quot; = &quot;Tokyo&quot;, &quot;神奈川県&quot; = &quot;Kanagawa&quot;, &quot;千葉県&quot; = &quot;Chiba&quot;, &quot;埼玉県&quot; = &quot;Saitama&quot;, &quot;大阪府&quot; = &quot;Osaka&quot;, &quot;京都府&quot; = &quot;Kyoto&quot;, &quot;兵庫県&quot; = &quot;Hyogo&quot;, &quot;奈良県&quot; = &quot;Nara&quot;, &quot;和歌山県&quot; = &quot;Wakayama&quot;, .default = &quot;NA&quot;)) ## # A tibble: 9 x 6 ## Pref Budget_Mean ScoreN_Sum Score_Mean N Pref2 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; ## 1 京都府 1399. 216 3.68 414 Kyoto ## 2 埼玉県 1147. 278 3.64 1000 Saitama ## 3 神奈川県 1239. 587 3.53 1000 Kanagawa ## 4 千葉県 1124. 259 3.72 1000 Chiba ## 5 大阪府 1203. 516 3.77 1000 Osaka ## 6 東京都 1283. 1165 3.67 1000 Tokyo ## 7 奈良県 1169. 45 3.85 147 Nara ## 8 兵庫県 1197. 230 3.54 591 Hyogo ## 9 和歌山県 1252 83 3.97 140 Wakayama 使い方は非常に直感的です。 # case_when()の使い方 データフレーム名 %&gt;% mutate(新変数名 = recode(元の変数名, 元の値1 = 新しい値1, 元の値2 = 新しい値2, 元の値3 = 新しい値3, ..., .default = 該当しない場合の値)) 最後の.default引数は、もし該当する値がない場合に返す値を意味し、長さ1のベクトルを指定します。もし、指定しない場合はNAが表示されます。また、ここには紹介しておりませんでしたが、.missing引数もあり、これは欠損値の場合に返す値を意味します。 もう一つ注意すべきところは、今回はcharacter型変数をcharacter型へ変換したため、「\"東京都\" = \"Tokyo\"」のような書き方をしました。しかし、numeric型からcharacter型に変換する場合は数字の部分を`で囲む必要があります。たとえば、「`1` = \"Tokyo\"」といった形式です。ただし、character型からnumeric型への場合は「\"東京都\" = 1」で構いません。 recode()は値をまとめる際にも便利です。たとえば、EastJapanという変数を作成し、関東なら1を、それ以外なら0を付けるとします。そして、これはPref変数の後に位置づけます。 # 都府県を関東か否かでまとめる df2 %&gt;% mutate(EastJapan = recode(Pref, &quot;東京都&quot; = 1, &quot;神奈川県&quot; = 1, &quot;千葉県&quot; = 1, &quot;埼玉県&quot; = 1, &quot;大阪府&quot; = 0, &quot;京都府&quot; = 0, &quot;兵庫県&quot; = 0, &quot;奈良県&quot; = 0, &quot;和歌山県&quot; = 0, .default = 0), .after = Pref) ## # A tibble: 9 x 6 ## Pref EastJapan Budget_Mean ScoreN_Sum Score_Mean N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 京都府 0 1399. 216 3.68 414 ## 2 埼玉県 1 1147. 278 3.64 1000 ## 3 神奈川県 1 1239. 587 3.53 1000 ## 4 千葉県 1 1124. 259 3.72 1000 ## 5 大阪府 0 1203. 516 3.77 1000 ## 6 東京都 1 1283. 1165 3.67 1000 ## 7 奈良県 0 1169. 45 3.85 147 ## 8 兵庫県 0 1197. 230 3.54 591 ## 9 和歌山県 0 1252 83 3.97 140 ただし、関東以外は全て0になるため、以下のように省略することも可能です。 # .default引数を指定する場合 df3 &lt;- df2 %&gt;% mutate(EastJapan = recode(Pref, &quot;東京都&quot; = 1, &quot;神奈川県&quot; = 1, &quot;千葉県&quot; = 1, &quot;埼玉県&quot; = 1, .default = 0), .after = Pref) df3 ## # A tibble: 9 x 6 ## Pref EastJapan Budget_Mean ScoreN_Sum Score_Mean N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 京都府 0 1399. 216 3.68 414 ## 2 埼玉県 1 1147. 278 3.64 1000 ## 3 神奈川県 1 1239. 587 3.53 1000 ## 4 千葉県 1 1124. 259 3.72 1000 ## 5 大阪府 0 1203. 516 3.77 1000 ## 6 東京都 1 1283. 1165 3.67 1000 ## 7 奈良県 0 1169. 45 3.85 147 ## 8 兵庫県 0 1197. 230 3.54 591 ## 9 和歌山県 0 1252 83 3.97 140 新しく出来たEastJapanのデータ型はなんでしょうか。 class(df3$EastJapan) ## [1] &quot;numeric&quot; EastJapanはnumeric型ですね。もし、これをfactor型にしたい場合はどうすればよいでしょうか。それはmutate()内でEastJapanを生成した後にfactor()関数を使うだけです。 # EastJapan変数をfactor型にする df3 &lt;- df2 %&gt;% mutate(EastJapan = recode(Pref, &quot;東京都&quot; = 1, &quot;神奈川県&quot; = 1, &quot;千葉県&quot; = 1, &quot;埼玉県&quot; = 1, .default = 0), EastJapan = factor(EastJapan, levels = c(0, 1)), .after = Pref) df3$EastJapan ## [1] 0 1 1 1 0 1 0 0 0 ## Levels: 0 1 EastJapanがfactor型になりました。実は、recodeは再コーディングと同時にfactor化をしてくれる機能があります。ただし、recode()関数でなく、recode_factor()関数を使います。 # recode_factor()を使う方法 df3 &lt;- df2 %&gt;% mutate(EastJapan = recode_factor(Pref, &quot;東京都&quot; = 1, &quot;神奈川県&quot; = 1, &quot;千葉県&quot; = 1, &quot;埼玉県&quot; = 1, .default = 0), .after = Pref) df3$EastJapan ## [1] 0 1 1 1 0 1 0 0 0 ## Levels: 1 0 ただし、levelの順番はrecode_factor()内で定義された順番になることに注意してください。factor型のより詳細な扱いについては第12章で解説します。 11.4 行単位の操作 ここでは行単位の操作について考えたいと思います。第10.3章で使ったmyDF1を見てみましょう。 myDF1 &lt;- data.frame( ID = 1:5, X1 = c(2, 4, 6, 2, 7), Y1 = c(3, 5, 1, 1, 0), X1D = c(4, 2, 1, 6, 9), X2 = c(5, 5, 6, 0, 2), Y2 = c(3, 3, 2, 3, 1), X2D = c(8, 9, 5, 0, 1), X3 = c(3, 0, 3, 0, 2), Y3 = c(1, 5, 9, 1, 3), X3D = c(9, 1, 3, 3, 8) ) myDF1 ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D ## 1 1 2 3 4 5 3 8 3 1 9 ## 2 2 4 5 2 5 3 9 0 5 1 ## 3 3 6 1 1 6 2 5 3 9 3 ## 4 4 2 1 6 0 3 0 0 1 3 ## 5 5 7 0 9 2 1 1 2 3 8 ここでX1とX2とX3の平均値を計算し、X_Meanという名の変数にする場合、以下のような書き方が普通でしょう。 myDF1 %&gt;% mutate(X_Mean = mean(c(X1, X2, X3))) ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D X_Mean ## 1 1 2 3 4 5 3 8 3 1 9 3.133333 ## 2 2 4 5 2 5 3 9 0 5 1 3.133333 ## 3 3 6 1 1 6 2 5 3 9 3 3.133333 ## 4 4 2 1 6 0 3 0 0 1 3 3.133333 ## 5 5 7 0 9 2 1 1 2 3 8 3.133333 あら、なんかおかしくありませんか。1行目の場合、X1とX2、X3それぞれ2、5、3であり、平均値は3.333であるはずなのに3.133になりました。これは2行目以降も同じです。なぜでしょうか。 実はdplyrは行単位の計算が苦手です。実際、データフレームというのは既に説明したとおり、縦ベクトルを横に並べたものです。列をまたがる場合、データ型が異なる場合も多いため、そもそも使う場面も多くありません。したがって、以下のような書き方が必要でした。 myDF1 %&gt;% mutate(X_Mean = (X1 + X2 + X3) / 3) ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D X_Mean ## 1 1 2 3 4 5 3 8 3 1 9 3.3333333 ## 2 2 4 5 2 5 3 9 0 5 1 3.0000000 ## 3 3 6 1 1 6 2 5 3 9 3 5.0000000 ## 4 4 2 1 6 0 3 0 0 1 3 0.6666667 ## 5 5 7 0 9 2 1 1 2 3 8 3.6666667 先ほどのmean(c(X1, X2, X3))は(X1列とX2列、X3列)の平均値です。X1は長さ1のベクトルではなく、その列全体を指すものです。つまり、mean(c(X1, X2, X3))はmean(c(myD1F$X1, myDF1$X2, myDF1$X3))と同じことになります。だから全て3.133という結果が得られました。ただし、後者はベクトル同士の加減乗除になるため問題ありません。実際c(1, 2, 3) + c(3, 5, 0)は同じ位置の要素同士の計算になることを既に第8.2章で説明しました。 ここでmean()関数を使う場合には全ての演算を、一行一行に分けて行う必要があります。ある一行のみに限定する場合、mean(c(X1, X2, X3))のX1などは長さ1のベクトルになるため、(X1 + X2 + X3) / 3と同じことになります。この「一行単位で処理を行う」ことを指定する関数がrowwise()関数です。これは行単位の作業を行う前に指定するだけです。 myDF1 %&gt;% rowwise() %&gt;% mutate(X_Mean = mean(c(X1, X2, X3))) ## # A tibble: 5 x 11 ## # Rowwise: ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D X_Mean ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 3 4 5 3 8 3 1 9 3.33 ## 2 2 4 5 2 5 3 9 0 5 1 3 ## 3 3 6 1 1 6 2 5 3 9 3 5 ## 4 4 2 1 6 0 3 0 0 1 3 0.667 ## 5 5 7 0 9 2 1 1 2 3 8 3.67 これで問題なく行単位の処理ができるようになりました。今回は変数が3つのみだったので、これで問題ありませんが、変数が多くなると:やstarts_with()、num_range()などを使って変数を選択したくなります。この場合は計算する関数内にc_across()を入れます。ここではX1列からX3D列までの平均値を求めてみましょう。 myDF1 %&gt;% rowwise() %&gt;% mutate(X_Mean = mean(X1:X3D)) ## # A tibble: 5 x 11 ## # Rowwise: ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D X_Mean ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 3 4 5 3 8 3 1 9 5.5 ## 2 2 4 5 2 5 3 9 0 5 1 2.5 ## 3 3 6 1 1 6 2 5 3 9 3 4.5 ## 4 4 2 1 6 0 3 0 0 1 3 2.5 ## 5 5 7 0 9 2 1 1 2 3 8 7.5 実はrowwise()関数、2020年6月に公開されたdplyr 1.0.0で注目された関数ですが、昔のdplyrにもrowwise()関数はありました。ただし、purrrパッケージやtidyrパッケージのnest()関数などにより使い道がなくなりましたが、なぜか華麗に復活しました。データ分析に使うデータは基本単位は列であるため、実際にrowwise()が使われる場面は今の段階では多くないでしょう。また、簡単な作業ならX1 + X2のような演算でも対応できます。それでも、覚えておけば便利な関数であることには間違いありません。 11.5 データの結合 11.5.1 行の結合 まずは、複数のデータフレームまたはtibbleを縦に結合する方法について解説します。イメージとしては図11.1のようなものです。 図 11.1: 行の結合 行を結合する際にはdplyrパッケージのbind_rows()関数を使います。この関数の使い方は以下の通りです。 # 新しいデータ名ではなく、既にあるデータ名にすると上書きとなる 新しいデータ名 &lt;- bind_rows(データ1, データ2, ...) それでは早速実際に使ってみましょう。実習のために、4つのtibbleを作成します (tibbleでなくデータフレームでも問題ありません)。 # tibble()の代わりにdata.frame()も可 rbind_df1 &lt;- tibble(X1 = 1:3, X2 = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), X3 = c(T, T, F)) # TRUEとFALSEはTはFと省略可能 rbind_df2 &lt;- tibble(X1 = 4:6, X2 = c(&quot;D&quot;, &quot;E&quot;, &quot;F&quot;), X3 = c(F, T, F)) rbind_df3 &lt;- tibble(X1 = 7:9, X3 = c(T, T, T), X2 = c(&quot;G&quot;, &quot;H&quot;, &quot;I&quot;)) rbind_df4 &lt;- tibble(X1 = 10:12, X2 = c(&quot;J&quot;, &quot;K&quot;, &quot;L&quot;), X5 = c(&quot;Song&quot;, &quot;Yanai&quot;, &quot;Hadley&quot;)) rbind_df1 # rbind_df1を出力 ## # A tibble: 3 x 3 ## X1 X2 X3 ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 1 A TRUE ## 2 2 B TRUE ## 3 3 C FALSE rbind_df2 # rbind_df2を出力 ## # A tibble: 3 x 3 ## X1 X2 X3 ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 4 D FALSE ## 2 5 E TRUE ## 3 6 F FALSE rbind_df3 # rbind_df3を出力 ## # A tibble: 3 x 3 ## X1 X3 X2 ## &lt;int&gt; &lt;lgl&gt; &lt;chr&gt; ## 1 7 TRUE G ## 2 8 TRUE H ## 3 9 TRUE I rbind_df4 # rbind_df4を出力 ## # A tibble: 3 x 3 ## X1 X2 X5 ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 10 J Song ## 2 11 K Yanai ## 3 12 L Hadley まずは、rbind_df1とrbind_df2を結合してみます。この2つのデータは同じ変数が同じ順番で並んでいますね。 Binded_df1 &lt;- bind_rows(rbind_df1, rbind_df2) Binded_df1 ## # A tibble: 6 x 3 ## X1 X2 X3 ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 1 A TRUE ## 2 2 B TRUE ## 3 3 C FALSE ## 4 4 D FALSE ## 5 5 E TRUE ## 6 6 F FALSE 2つのデータが結合されたことが確認できます。それではrbind_df1とrbind_df2、rbind_df3はどうでしょうか。確かに3つのデータは同じ変数を持ちますが、rbind_df3は変数の順番がX1、X3、X2になっています。このまま結合するとエラーが出るでしょうか。とりあえず、やってみます。 Binded_df2 &lt;- bind_rows(rbind_df1, rbind_df2, rbind_df3) Binded_df2 ## # A tibble: 9 x 3 ## X1 X2 X3 ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 1 A TRUE ## 2 2 B TRUE ## 3 3 C FALSE ## 4 4 D FALSE ## 5 5 E TRUE ## 6 6 F FALSE ## 7 7 G TRUE ## 8 8 H TRUE ## 9 9 I TRUE このように変数の順番が異なっても、先に指定したデータの変数順で問題なく結合できました。これまでの作業はdplyrパッケージのbind_rows()を使わずに、R内蔵関数のrbind()でも同じやり方でできます。bind_rows()の特徴は、変数名が一致しない場合、つまり今回の例だとrbind_df4が含まれる場合です。rbind_df1からrbind_df3までは順番が違ってもX1、X2、X3変数で構成されていました。一方、rbind_dr4にはX3がなく、新たにX4という変数があります。これをrbind()関数で結合するとエラーが出力されます。 # rbind()を使う場合 rbind(rbind_df1, rbind_df2, rbind_df3, rbind_df4) ## Error in match.names(clabs, names(xi)): names do not match previous names 一方、bind_rows()はどうでしょうか。 Binded_df3 &lt;- bind_rows(rbind_df1, rbind_df2, rbind_df3, rbind_df4) Binded_df3 ## # A tibble: 12 x 4 ## X1 X2 X3 X5 ## &lt;int&gt; &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; ## 1 1 A TRUE &lt;NA&gt; ## 2 2 B TRUE &lt;NA&gt; ## 3 3 C FALSE &lt;NA&gt; ## 4 4 D FALSE &lt;NA&gt; ## 5 5 E TRUE &lt;NA&gt; ## 6 6 F FALSE &lt;NA&gt; ## 7 7 G TRUE &lt;NA&gt; ## 8 8 H TRUE &lt;NA&gt; ## 9 9 I TRUE &lt;NA&gt; ## 10 10 J NA Song ## 11 11 K NA Yanai ## 12 12 L NA Hadley X1からX4まで全ての列が生成され、元のデータにはなかった列に関してはNAで埋められています。 ならば、bind_rows()の完全勝利かというと、そうとは限りません。自分で架空した複数のデータフレーム、またはtibbleを結合する際、「このデータは全て同じ変数を持っているはず」と事前に分かっているならrbind()の方が効果的です。なぜなら、変数名が異なる場合、エラーが出力されるからです。bind_rows()を使うと、コーディングミスなどにより、列名の相違がある場合でも結合してくれてしまうので、分析の結果を歪ませる可能性があります。 11.5.2 列の結合 実はデータ分析においてデータの結合といえば、列の結合が一般的です。これは図11.2のような操作を意味します。 図 11.2: 列の結合 まずは、本章で作成したdf2をもう一回作ってみます。 df2 &lt;- df %&gt;% group_by(Pref) %&gt;% summarise(Budget_Mean = mean(Budget, na.rm = TRUE), ScoreN_Sum = sum(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), N = n(), .groups = &quot;drop&quot;) df2 ## # A tibble: 9 x 5 ## Pref Budget_Mean ScoreN_Sum Score_Mean N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 京都府 1399. 216 3.68 414 ## 2 埼玉県 1147. 278 3.64 1000 ## 3 神奈川県 1239. 587 3.53 1000 ## 4 千葉県 1124. 259 3.72 1000 ## 5 大阪府 1203. 516 3.77 1000 ## 6 東京都 1283. 1165 3.67 1000 ## 7 奈良県 1169. 45 3.85 147 ## 8 兵庫県 1197. 230 3.54 591 ## 9 和歌山県 1252 83 3.97 140 ラーメン屋の店舗ですが、たしかにデータには埼玉、東京、大阪などは1000店舗しか入っておりません。実はもっと多いですが、ぐるなびAPIの仕様上、最大1000店舗しか情報取得が出来ないからです。ここに実際の店舗数が入っている新しいデータセット、Ramen2.csvがあります。これを読み込み、df3という名で格納しましょう。 df3 &lt;- read_csv(&quot;Data/Ramen2.csv&quot;) ## Parsed with column specification: ## cols( ## Pref = col_character(), ## Pop = col_number(), ## Area = col_number(), ## RamenN = col_double(), ## Turnout = col_double(), ## LDP = col_double(), ## CDP = col_double(), ## DPFP = col_double(), ## Komei = col_double(), ## JIP = col_double(), ## JCP = col_double(), ## SDP = col_double(), ## Reiwa = col_double(), ## NHK = col_double(), ## HRP = col_double() ## ) df3 ## # A tibble: 47 x 15 ## Pref Pop Area RamenN Turnout LDP CDP DPFP Komei JIP JCP SDP Reiwa ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 北海道… 5.38e6 83424. 1454 53.8 32.3 20.8 6.65 11.7 7.78 11.6 1.31 3.85 ## 2 青森県… 1.31e6 9646. 336 42.9 39.8 22.0 7.24 11.3 3.4 8.31 2.36 3.23 ## 3 岩手県… 1.28e6 15275. 285 56.5 35.5 17.8 12.5 8.22 4.36 10.4 3.83 4.1 ## 4 宮城県… 2.33e6 7282. 557 51.2 39.6 17.8 9.02 11.1 4.6 7.89 2.1 4.41 ## 5 秋田県… 1.02e6 11638. 301 56.3 44.5 13.5 8.64 10.6 4.48 8.09 3.77 3.33 ## 6 山形県… 1.12e6 9323. 512 60.7 45.2 14.9 7.37 9.87 4.28 6.51 5.08 3.88 ## 7 福島県… 1.91e6 13784. 550 52.4 38.2 13.6 12.1 12.8 5.31 7.99 3.01 4.04 ## 8 茨城県… 2.92e6 6097. 663 45.0 39.3 15.2 7.15 15.1 6.73 7.73 1.46 4.09 ## 9 栃木県… 1.97e6 6408. 595 44.1 40.3 18.9 9.94 12.8 4.9 5.04 1.03 3.82 ## 10 群馬県… 1.97e6 6362. 488 48.2 40.6 16.4 9.76 12.4 4.67 7.58 1.87 3.71 ## # … with 37 more rows, and 2 more variables: NHK &lt;dbl&gt;, HRP &lt;dbl&gt; 変数名 説明 Pref 都道府県名 Pop 日本人人口 (2015年国勢調査) Area 面積 (2015年国勢調査) RamenN ぐるなびに登録されたラーメン屋の店舗数 Turnout 2019年参院選: 投票率 (比例) LDP 2019年参院選: 自民党の得票率 (比例) CDP 2019年参院選: 立憲民主党の得票率 (比例) DPFP 2019年参院選: 国民民主党の得票率 (比例) Komei 2019年参院選: 公明党の得票率 (比例) JIP 2019年参院選: 日本維新の会の得票率 (比例) JCP 2019年参院選: 日本共産党の得票率 (比例) SDP 2019年参院選: 社会民主党の得票率 (比例) Reiwa 2019年参院選: れいわ新選組の得票率 (比例) NHK 2019年参院選: NHKから国民を守る党の得票率 (比例) HRP 2019年参院選: 幸福実現党の得票率 (比例) 本データは都道府県ごとの人口、面積、ぐるなびに登録されたラーメン屋の店舗数、2019年参議院議員通常選挙の結果が格納されています。人口と面積は2015年国勢調査、ぐるなびの情報は2020年6月時点での情報です。 df2にデータ上の店舗数ではなく、実際の店舗数を新しい列として追加したい場合はどうすれば良いでしょうか。簡単な方法としてはdf3から情報を取得し、それを自分で入れる方法です。 df3 %&gt;% # df2のPrefベクトルの要素と一致するものに絞る filter(Pref %in% df2$Pref) %&gt;% # 都道府県名とラーメン屋の店舗数のみ抽出 select(Pref, RamenN) ## # A tibble: 9 x 2 ## Pref RamenN ## &lt;chr&gt; &lt;dbl&gt; ## 1 埼玉県 1106 ## 2 千葉県 1098 ## 3 東京都 3220 ## 4 神奈川県 1254 ## 5 京都府 415 ## 6 大阪府 1325 ## 7 兵庫県 591 ## 8 奈良県 147 ## 9 和歌山県 140 そして、この情報をdf2$RamenN &lt;- c(415, 1106, 1254, ...)のように追加すればいいですね。 しかし、このような方法は非効率的です。そもそもdf3から得られた結果の順番とdf2の順番も一致しないので、一々対照しながらベクトルを作ることになります。ここで登場する関数がdplyrの*_join()関数群です。この関数群には4つの関数が含まれており、以下のような使い方になります。 # 新しいデータ名ではなく、データ1またはデータ2の名前に格納すると上書きとなる # 1. データ1を基準に結合 新しいデータ名 &lt;- left_join(データ1, データ2, by = &quot;共通変数名&quot;) # 2. データ2を基準に結合 新しいデータ名 &lt;- right_join(データ1, データ2, by = &quot;共通変数名&quot;) # 3. データ1とデータ2両方に共通するケースのみ結合 新しいデータ名 &lt;- inner_join(データ1, データ2, by = &quot;共通変数名&quot;) # 4. データ1とデータ2、どれかに存在するケースを結合 新しいデータ名 &lt;- full_join(データ1, データ2, by = &quot;共通変数名&quot;) 4つの関数の違いについて説明する前に、by引数について話したいと思います。これは主にキー (key)変数と呼ばれる変数で、それぞれのデータに同じ名前の変数がある必要があります。df2とdf3だとそれがPref変数です。どの*_join()関数でも、Prefの値が同じもの同士を結合することになります。 データのキー変数名が異なる場合もあります。たとえば、データ1の都道府県名はPrefという列に、データ2の都道府県名はPrefectureという列になっている場合、by = \"Pref\"でなく、by = c(\"データ1のキー変数名\" = \"データ2のキー変数名\")、つまり、by = c(\"Pref\" = \"Prefecture\")と指定します。 それでは、df3から都道府県名とラーメン屋の店舗数だけ抽出し、df4として格納しておきます。 df4 &lt;- df3 %&gt;% select(Pref, RamenN) df4 ## # A tibble: 47 x 2 ## Pref RamenN ## &lt;chr&gt; &lt;dbl&gt; ## 1 北海道 1454 ## 2 青森県 336 ## 3 岩手県 285 ## 4 宮城県 557 ## 5 秋田県 301 ## 6 山形県 512 ## 7 福島県 550 ## 8 茨城県 663 ## 9 栃木県 595 ## 10 群馬県 488 ## # … with 37 more rows これから共通変数名の値をキー (key)と呼びます。今回の例だとPrefがdf2とdf4のキー変数であり、その値である\"東京都\"、\"北海道\"などがキーです。 まずは、inner_join()の仕組みについて考えます。これはdf2とdf4に共通するキーを持つケースのみ結合する関数です。df4には\"北海道\"というキーがありますが、df2にはありません。したがって、キーが\"北海道\"のケースは結合から除外されます。これをイメージにしたものが図11.3です59。それぞれ3 \\(\\times\\) 2 (3行2列)のデータですが、キーが一致するケースは2つしかないため、結合後のデータは3 \\(\\times\\) 2となります。 図 11.3: inner_join()の仕組み 実際にやってみましょう。 inner_join(df2, df4, by = &quot;Pref&quot;) ## # A tibble: 9 x 6 ## Pref Budget_Mean ScoreN_Sum Score_Mean N RamenN ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 京都府 1399. 216 3.68 414 415 ## 2 埼玉県 1147. 278 3.64 1000 1106 ## 3 神奈川県 1239. 587 3.53 1000 1254 ## 4 千葉県 1124. 259 3.72 1000 1098 ## 5 大阪府 1203. 516 3.77 1000 1325 ## 6 東京都 1283. 1165 3.67 1000 3220 ## 7 奈良県 1169. 45 3.85 147 147 ## 8 兵庫県 1197. 230 3.54 591 591 ## 9 和歌山県 1252 83 3.97 140 140 共通するキーは9つのみであり、結果として返されたデータの大きさも9 \\(\\times\\) 6です。df2に足されたdf4は2列のデータですが、キー変数であるPrefは共通するため、1列のみ足されました。キー変数を両方残す場合はkeep = TRUE引数を追加してください。 一方、full_join()は、すべてのキーに対して結合を行います (図11.4)。たとえば、df2には\"北海道\"というキーがありません。それでも新しく出来上がるデータには北海道の列が追加されます。ただし、道内店舗の平均予算、口コミ数などの情報はないため、欠損値が代入されます。 図 11.4: full_join()の仕組み それでは実際、結果を確認してみましょう。今回は結合後、RamenNが大きい順で出力します。 full_join(df2, df4, by = &quot;Pref&quot;) %&gt;% arrange(desc(RamenN)) # ぐるなびに登録された店舗の多い都道府県から出力 ## # A tibble: 47 x 6 ## Pref Budget_Mean ScoreN_Sum Score_Mean N RamenN ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 東京都 1283. 1165 3.67 1000 3220 ## 2 北海道 NA NA NA NA 1454 ## 3 大阪府 1203. 516 3.77 1000 1325 ## 4 愛知県 NA NA NA NA 1255 ## 5 神奈川県 1239. 587 3.53 1000 1254 ## 6 埼玉県 1147. 278 3.64 1000 1106 ## 7 千葉県 1124. 259 3.72 1000 1098 ## 8 福岡県 NA NA NA NA 985 ## 9 新潟県 NA NA NA NA 705 ## 10 静岡県 NA NA NA NA 679 ## # … with 37 more rows df2にはなかった北海道や愛知県などの行ができました。そして、df2にはない情報はすべて欠損値 (NA)となりました。 続いて、left_join()ですが、これは先に指定したデータに存在するキーのみで結合を行います (図11.5)。今回はdf2が先に指定されていますが、df2のキーはdf4のキーの部分集合であるため、inner_join()と同じ結果が得られます。 図 11.5: left_join()の仕組み 一方、right_join()はleft_join()と逆の関数であり、後に指定したデータに存在するキーを基準に結合を行います (図11.6)。後に指定されたdf4のキーはdf2のキーを完全に含むので、full_join()と同じ結果が得られます。 図 11.6: right_join()の仕組み これからはdf2とdf4を結合することになりますが、この2つのtibbleの大きさが異なります。df2は9つの都府県のみであるに対し、df4は47都道府県全てのデータが入っているからです。 ここまではキー変数が一つである場合についてのみ考えましたが、複数のキー変数が必要な場合もあります。たとえば、市区町村の人口・面積データと市区町村の投票率データを結合するとします。各自治体に与えられている「全国地方公共団体コード」が両データに含まれている場合は、このコードをキー変数として使えば問題ありませんが、市区町村名をキー変数として使わざる得ないケースもあるでしょう。しかし、キー変数が複数ある場合もあります。たとえば、府中市は東京都と広島県にありますし、太子町は大阪府と兵庫県にあります。この場合、市区町村名のみでケースをマッチングすると、重複されてマッチングされる恐れがあります。この場合はキー変数を増やすことで対処できます。たとえば、同じ都道府県なら同じ市区町村は存在しないでしょう60。キー変数を複数指定する方法は簡単です。たとえば、市区町村名変数がMunip、都道府県名変数がPrefならby = c(\"Munip\", \"Pref\")と指定するだけです。 最後に、キー変数以外の変数名が重複する場合について考えましょう。これはパネルデータを結合する時によく直面する問題です。同じ回答者に2回の調査を行った場合、回答者のIDでデータを結合することになります。ただし、それぞれのデータにおいて回答者の性別に関する変数がF1という名前の場合、どうなるでしょうか。同じデータの同じ名前の変数が複数あると、非常に扱いにくくなります。実際の結果を見てみましょう。 Wave1_df &lt;- tibble(ID = c(1, 2, 3, 4, 5), F1 = c(1, 1, 0, 0, 1), F2 = c(18, 77, 37, 50, 41), Q1 = c(1, 5, 2, 2, 3)) Wave2_df &lt;- tibble(ID = c(1, 3, 4, 6, 7), F1 = c(1, 0, 0, 0, 1), F2 = c(18, 37, 50, 20, 62), Q1 = c(1, 2, 2, 5, 4)) full_join(Wave1_df, Wave2_df, by = &quot;ID&quot;) ## # A tibble: 7 x 7 ## ID F1.x F2.x Q1.x F1.y F2.y Q1.y ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 18 1 1 18 1 ## 2 2 1 77 5 NA NA NA ## 3 3 0 37 2 0 37 2 ## 4 4 0 50 2 0 50 2 ## 5 5 1 41 3 NA NA NA ## 6 6 NA NA NA 0 20 5 ## 7 7 NA NA NA 1 62 4 それぞれの変数名の後に.xと.yが付きます。この接尾辞 (suffix)はsuffix引数を指定することで、分析側からカスタマイズ可能です。たとえば、接尾辞を_W1、_W2にしたい場合は full_join(Wave1_df, Wave2_df, by = &quot;ID&quot;, suffix = c(&quot;_W1&quot;, &quot;_W2&quot;)) ## # A tibble: 7 x 7 ## ID F1_W1 F2_W1 Q1_W1 F1_W2 F2_W2 Q1_W2 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 18 1 1 18 1 ## 2 2 1 77 5 NA NA NA ## 3 3 0 37 2 0 37 2 ## 4 4 0 50 2 0 50 2 ## 5 5 1 41 3 NA NA NA ## 6 6 NA NA NA 0 20 5 ## 7 7 NA NA NA 1 62 4 のように、データ1とデータ2それぞれの接尾辞を指定するだけです。 11.6 練習問題 これらの図はGarrett Grolemund and Hadley Wickham. 2017. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. O’Reilly.を参考にしました。↩︎ 行政区も含むなら多くの政令指定都市にある「南区」とか「北区」が重複しますが、ここでは考えないことにしましょう。↩︎ "],
["factor.html", "12. データハンドリング [基礎編: factor型] 12.1 名目変数を含むグラフを作成する際の注意点 12.2 forcatsパッケージについて 12.3 練習問題", " 12. データハンドリング [基礎編: factor型] 12.1 名目変数を含むグラフを作成する際の注意点 ここからは楽しい可視化、つまりグラフの作成について解説します。ただし、その前に、名目変数の扱いと簡潔データ構造について話したいと思います。本章では名目変数の扱いについて解説し、次章は簡潔データ構造について解説します。 横軸、または縦軸が気温、成績、身長のような連続変数ではなく、都道府県や国、企業のような名目変数になる場合があります。たとえば、棒グラフの横軸は図12.1のように、一般的に名目変数になる場合が多いです。 図 12.1: 横軸が名目変数の棒グラフ ここでは横軸の順番に注目してください。京都府、埼玉県、神奈川県、…の順番になっていますね。「この順番で大満足だよ!」という方がいるかも知れませんが、そうでない方もおおいでしょう。普通考えられるものとしては、都道府県コードの順か、縦軸が高い順 (低い順)でしょう。都道府県コードの順だと、埼玉県、千葉県、東京都、神奈川県、京都府、大阪府、兵庫県、奈良県、和歌山県の順番になります。または、縦軸 (口コミ評価の平均値)が高い順なら和歌山県、奈良県、大阪府、…の順番になります。あるいは50音順も考えられるでしょう。アメリカの場合、州を並べる際、アルファベット順で並べます。 自分でこの順番をコントロールするには可視化の前の段階、つまりデータハンドリングの段階で順番を決めなくてはなりません。これを決めておかない場合、Rが勝手に順番を指定します。具体的にはロケール (locale)というパソコン内の空間に文字情報が含まれているわけですが、そこに保存されている文字の順番となります。たとえば、日本語ロケールには「京」が「埼」よりも先に保存されているわけです。 したがって、名目変数がグラフに含まれる場合は、名目変数の表示順番を決める必要があり、そこで必要なのがfactor型です。名目変数がcharacter型の場合、ロケールに保存されている順でソートされますが、factor型の場合、予め指定した順番でソートされます。 たとえば、前章で使用したデータを用いて、都道府県ごとの口コミ評価の平均値を計算し、その結果をScore_dfとして保存します。 # tidyverseパッケージの読み込み library(tidyverse) # データの読み込み df &lt;- read_csv(&quot;Data/Ramen.csv&quot;) Score_df &lt;- df %&gt;% group_by(Pref) %&gt;% summarise(Score = mean(Score, na.rm = TRUE), .groups = &quot;drop&quot;) Score_df ## # A tibble: 9 x 2 ## Pref Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 京都府 3.68 ## 2 埼玉県 3.64 ## 3 神奈川県 3.53 ## 4 千葉県 3.72 ## 5 大阪府 3.77 ## 6 東京都 3.67 ## 7 奈良県 3.85 ## 8 兵庫県 3.54 ## 9 和歌山県 3.97 この時点で勝手にロケール順になります。実際、表示されたScore_dfを見るとPrefの下に`&lt;chr&gt;と表記されており、Prefはcharacter型であることが分かります。これをこのまま棒グラフに出してみましょう。可視化の方法はこれから詳細に解説するので、ここでは結果だけに注目してください。 Score_df %&gt;% ggplot() + geom_bar(aes(x = Pref, y = Score), stat = &quot;identity&quot;) + labs(x = &quot;都府県&quot;, y = &quot;口コミ評価の平均値 (1~5)&quot;) + theme_gray(base_family = &quot;HiraKakuProN-W3&quot;) + theme(text = element_text(size = 12)) 図 12.2: Prefがcharacter型の場合 (1) 横軸の順番があまり直感的ではありませんね。それでは、Score_dfをScoreが高い順にソートし、Score_df2で保存してから、もう一回試してみます。 Score_df2 &lt;- Score_df %&gt;% arrange(desc(Score)) Score_df2 ## # A tibble: 9 x 2 ## Pref Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 和歌山県 3.97 ## 2 奈良県 3.85 ## 3 大阪府 3.77 ## 4 千葉県 3.72 ## 5 京都府 3.68 ## 6 東京都 3.67 ## 7 埼玉県 3.64 ## 8 兵庫県 3.54 ## 9 神奈川県 3.53 ここでもPrefはcharacter型ですが、とりあえず、これで図を出してみます。 Score_df2 %&gt;% ggplot() + geom_bar(aes(x = Pref, y = Score), stat = &quot;identity&quot;) + labs(x = &quot;都府県&quot;, y = &quot;口コミ評価の平均値 (1~5)&quot;) + theme_gray(base_family = &quot;HiraKakuProN-W3&quot;) + theme(text = element_text(size = 12)) 図 12.3: Prefがcharacter型の場合 (2) 結果は全く変わっておりません。それでは、Score_dfのPref列をfactor型に変換し、順番は口コミ評価の平均値が高い順番にしてみましょう。結果はScore_df_f1という名で保存します。 Score_df_f1 &lt;- Score_df %&gt;% mutate(Pref = factor(Pref, levels = c(&quot;和歌山県&quot;, &quot;奈良県&quot;, &quot;大阪府&quot;, &quot;千葉県&quot;, &quot;京都府&quot;, &quot;東京都&quot;, &quot;埼玉県&quot;, &quot;兵庫県&quot;, &quot;神奈川県&quot;))) Score_df_f1 ## # A tibble: 9 x 2 ## Pref Score ## &lt;fct&gt; &lt;dbl&gt; ## 1 京都府 3.68 ## 2 埼玉県 3.64 ## 3 神奈川県 3.53 ## 4 千葉県 3.72 ## 5 大阪府 3.77 ## 6 東京都 3.67 ## 7 奈良県 3.85 ## 8 兵庫県 3.54 ## 9 和歌山県 3.97 表示される順番はScore_dfとScore_df_f1も同じですが、Prefのデータ型が&lt;fct&gt;、つまりfactor型であることが分かります。実際、Pref列だけ抽出した場合、factor型として、和歌山県から神奈川県の順になっていることが確認できます。 Score_df_f1$Pref ## [1] 京都府 埼玉県 神奈川県 千葉県 大阪府 東京都 奈良県 兵庫県 和歌山県 ## Levels: 和歌山県 奈良県 大阪府 千葉県 京都府 東京都 埼玉県 兵庫県 神奈川県 このScore_df_f1データを使って、図12.2と全く同じコードを実行した結果が図12.4です。 図 12.4: Prefがfactor型の場合 (1) これまでの話をまとめるの以下の2点が分かります。 変数がcharacter型である場合、自動的にロケール順でソートされる。 変数がfactor型である場合、データ内の順番やロケール順と関係なく、指定されたレベル (水準)の順でソートされる。 とくに2番目の点についてですが、これは必ずしも順序付きfactorである必要はありません。順序付きfactor型でなくても、factor()内で指定した順にソートされます。むろん、順序付きfactor型なら指定された順序でソートされます。 これからはfactor型変換の際に便利な関数をいくつか紹介しますが、その前に数値として表現された名目変数について話します。たとえば、Score_df_f1に関東地域なら1を、その他の地域なら0を付けたKantoという変数があるとします。 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Kanto = ifelse(Pref %in% c(&quot;東京都&quot;, &quot;神奈川県&quot;, &quot;千葉県&quot;, &quot;埼玉県&quot;), 1, 0)) Score_df_f1 ## # A tibble: 9 x 3 ## Pref Score Kanto ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 京都府 3.68 0 ## 2 埼玉県 3.64 1 ## 3 神奈川県 3.53 1 ## 4 千葉県 3.72 1 ## 5 大阪府 3.77 0 ## 6 東京都 3.67 1 ## 7 奈良県 3.85 0 ## 8 兵庫県 3.54 0 ## 9 和歌山県 3.97 0 Kanto変数のデータ型は、&lt;dbl&gt;、つまりnumeric型です。しかし、これは明らかに名目変数ですね。これをこのままKantoを横軸にした図を出すと図12.5のようになります。 図 12.5: Kantoがnumeric型の場合 この場合、図の横軸はKantoの値が小さい順でソートされます。ただし、このような図は非常に見にくいため、1に\"関東\"、0に\"関西\"とラベルを付けたfactor型に変換した方が望ましいです。numeric型をラベル付きのfactor型にするためには、levels引数には元の数値を、labels引数にはそれぞれの数値に対応したラベルを指定します。また、関東の方を先に出したいので、factor()内のlevels引数はc(0, 1)でなく、c(1, 0)にします。 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Kanto = factor(Kanto, levels = c(1, 0), labels = c(&quot;関東&quot;, &quot;その他&quot;))) Score_df_f1 ## # A tibble: 9 x 3 ## Pref Score Kanto ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 京都府 3.68 その他 ## 2 埼玉県 3.64 関東 ## 3 神奈川県 3.53 関東 ## 4 千葉県 3.72 関東 ## 5 大阪府 3.77 その他 ## 6 東京都 3.67 関東 ## 7 奈良県 3.85 その他 ## 8 兵庫県 3.54 その他 ## 9 和歌山県 3.97 その他 Kanto変数がfactor型に変換されたことが分かります。 Score_df_f1$Kanto ## [1] その他 関東 関東 関東 その他 関東 その他 その他 その他 ## Levels: 関東 その他 また、\"関東\"、\"その他\"の順になっていますね。これを図として出力した結果が図12.6です。 図 12.6: Kantoがfactor型の場合 このように数値型名目変数でも、factor化することによって、自由に横軸の順番を変えることができます。それでは、factor化に使える便利な関数をいくつか紹介します。 12.2 forcatsパッケージについて 実はfactor型への変換や、順番に変更などは全てR内蔵のfactor()関数で対応可能ですが、ここではforcatsパッケージが提供しているfct_*()関数を使用します。forcatsパッケージはtidyverseを読み込む際、自動的に読み込まれるため、既にtidyverseを読み込んでいる場合、別途のコードは要りません。 12.2.1 fct_relevel(): 水準の順番を変更する Score_df_f1のf1はScoreが高い順になっています。これを50音順に変更する際、fct_relevel()関数を使います。 # 新しい変数名と元となる変数名が一致すると上書きになる データフレーム名 %&gt;% mutate(新しい変数名 = fct_releve(元となる変数名, &quot;水準1&quot;, &quot;水準2&quot;, &quot;水準3&quot;, ...)) ここでは、Pref変数を再調整したPref2変数を作ってみましょう。 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Pref2 = fct_relevel(Pref, &quot;大阪府&quot;, &quot;神奈川県&quot;, &quot;京都府&quot;, &quot;埼玉県&quot;, &quot;千葉県&quot;, &quot;東京都&quot;, &quot;奈良県&quot;, &quot;兵庫県&quot;, &quot;和歌山県&quot;)) Score_df_f1 ## # A tibble: 9 x 4 ## Pref Score Kanto Pref2 ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; ## 1 京都府 3.68 その他 京都府 ## 2 埼玉県 3.64 関東 埼玉県 ## 3 神奈川県 3.53 関東 神奈川県 ## 4 千葉県 3.72 関東 千葉県 ## 5 大阪府 3.77 その他 大阪府 ## 6 東京都 3.67 関東 東京都 ## 7 奈良県 3.85 その他 奈良県 ## 8 兵庫県 3.54 その他 兵庫県 ## 9 和歌山県 3.97 その他 和歌山県 一見、PrefとPref2変数は同じように見えますが、水準はどうなっているでしょうか。 levels(Score_df_f1$Pref) # Prefの水準 ## [1] &quot;和歌山県&quot; &quot;奈良県&quot; &quot;大阪府&quot; &quot;千葉県&quot; &quot;京都府&quot; &quot;東京都&quot; &quot;埼玉県&quot; ## [8] &quot;兵庫県&quot; &quot;神奈川県&quot; levels(Score_df_f1$Pref2) # Pref2の水準 ## [1] &quot;大阪府&quot; &quot;神奈川県&quot; &quot;京都府&quot; &quot;埼玉県&quot; &quot;千葉県&quot; &quot;東京都&quot; &quot;奈良県&quot; ## [8] &quot;兵庫県&quot; &quot;和歌山県&quot; 問題なく50音順になっていることが分かります。他にもfct_relevel()には全ての水準名を指定する必要がありません。一部の水準名も可能です。たとえば、「関東が関西の先に来るなんでけしからん！」と思う読者もいるでしょう。この場合、関西の府県名を入れると、指定した水準が最初に位置するようになります。 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Pref3 = fct_relevel(Pref, &quot;京都府&quot;, &quot;大阪府&quot;, &quot;兵庫県&quot;, &quot;奈良県&quot;, &quot;和歌山県&quot;)) levels(Score_df_f1$Pref3) # Pref3の水準 ## [1] &quot;京都府&quot; &quot;大阪府&quot; &quot;兵庫県&quot; &quot;奈良県&quot; &quot;和歌山県&quot; &quot;千葉県&quot; &quot;東京都&quot; ## [8] &quot;埼玉県&quot; &quot;神奈川県&quot; 一部の水準名のみを指定するとその水準が最初に移動されますが、after引数を指定すると、位置を調整することも可能です。after = 2の場合、元となる変数の1、3番目の水準は維持され、3番目以降に指定した水準、それに続いて指定されていない水準の順番になります。Prefは和歌山、奈良、大阪の順ですが、ここで京都と東京を、奈良と大阪の間に移動するなら、 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Pref4 = fct_relevel(Pref, &quot;京都府&quot;, &quot;東京都&quot;, after = 2)) levels(Score_df_f1$Pref4) # Pref4の水準 ## [1] &quot;和歌山県&quot; &quot;奈良県&quot; &quot;京都府&quot; &quot;東京都&quot; &quot;大阪府&quot; &quot;千葉県&quot; &quot;埼玉県&quot; ## [8] &quot;兵庫県&quot; &quot;神奈川県&quot; のように書きます。afterを指定しない場合のデフォルト値は0であるため、最初に移動します。 12.2.2 fct_recode(): 水準のラベルを変更する fct_recode()は水準のラベルを変更する時に使う関数で、以下のように使います。 # 新しい変数名と元となる変数名が一致すると上書きになる データフレーム名 %&gt;% mutate(新しい変数名 = fct_recode(元となる変数名, 新しいラベル1 = &quot;既存のラベル1&quot;, 新しいラベル2 = &quot;既存のラベル2&quot;, 新しいラベル3 = &quot;既存のラベル3&quot;, ...)) 注意点としては新しいラベルは\"で囲まず、既存のラベルは\"で囲む点です。それでは、Prefのラベルをローマ字に変更してみましょう。 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Pref5 = fct_recode(Pref, Saitama = &quot;埼玉県&quot;, Wakayama = &quot;和歌山県&quot;, Kyoto = &quot;京都府&quot;, Osaka = &quot;大阪府&quot;, Tokyo = &quot;東京都&quot;, Nara = &quot;奈良県&quot;, Kanagawa = &quot;神奈川県&quot;, Hyogo = &quot;兵庫県&quot;, Chiba = &quot;千葉県&quot;)) Score_df_f1 ## # A tibble: 9 x 7 ## Pref Score Kanto Pref2 Pref3 Pref4 Pref5 ## &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 京都府 3.68 その他 京都府 京都府 京都府 Kyoto ## 2 埼玉県 3.64 関東 埼玉県 埼玉県 埼玉県 Saitama ## 3 神奈川県 3.53 関東 神奈川県 神奈川県 神奈川県 Kanagawa ## 4 千葉県 3.72 関東 千葉県 千葉県 千葉県 Chiba ## 5 大阪府 3.77 その他 大阪府 大阪府 大阪府 Osaka ## 6 東京都 3.67 関東 東京都 東京都 東京都 Tokyo ## 7 奈良県 3.85 その他 奈良県 奈良県 奈良県 Nara ## 8 兵庫県 3.54 その他 兵庫県 兵庫県 兵庫県 Hyogo ## 9 和歌山県 3.97 その他 和歌山県 和歌山県 和歌山県 Wakayama fct_recode()の中に指定する水準の順番は無視されます。つまり、水準の順番はそのまま維持されるため、好きな順番で結構です。また、全ての水準を指定せず、一部のみ変更することも可能です。それではPref5の順番がPrefの順番と同じかを確認してみましょう。 levels(Score_df_f1$Pref) # Prefの水準 ## [1] &quot;和歌山県&quot; &quot;奈良県&quot; &quot;大阪府&quot; &quot;千葉県&quot; &quot;京都府&quot; &quot;東京都&quot; &quot;埼玉県&quot; ## [8] &quot;兵庫県&quot; &quot;神奈川県&quot; levels(Score_df_f1$Pref5) # Pref5の水準 ## [1] &quot;Wakayama&quot; &quot;Nara&quot; &quot;Osaka&quot; &quot;Chiba&quot; &quot;Kyoto&quot; &quot;Tokyo&quot; &quot;Saitama&quot; ## [8] &quot;Hyogo&quot; &quot;Kanagawa&quot; 12.2.3 fct_rev(): 水準の順番を反転させる 水準の順番を反転することは非常によくあります。たとえば、グラフの読みやすさのために、左右または上下を反転するケースがあります。既に何回も強調しましたように、名目変数は基本的にfactor型にすべきであり、ここでfct_rev()関数が非常に便利です。たとえば、Pref2の水準は50音順でありますが、これを反転し、Pref6という名の列として追加してみましょう。 Score_df_f1 &lt;- Score_df_f1 %&gt;% mutate(Pref6 = fct_rev(Pref2)) levels(Score_df_f1$Pref6) ## [1] &quot;和歌山県&quot; &quot;兵庫県&quot; &quot;奈良県&quot; &quot;東京都&quot; &quot;千葉県&quot; &quot;埼玉県&quot; &quot;京都府&quot; ## [8] &quot;神奈川県&quot; &quot;大阪府&quot; 関数一つで水準の順番が反転されました。 12.2.4 fct_infreq(): 頻度順に順番を変更する 続いて、水準の順番を頻度順に合わせるfct_infreq()関数です。たとえば、Scoreが欠損でないケースのみで構成されたdf2を考えてみましょう。 df2 &lt;- df %&gt;% filter(!is.na(Score)) そして、都府県ごとのケース数を計算します。 table(df2$Pref) ## ## 京都府 埼玉県 神奈川県 千葉県 大阪府 東京都 奈良県 兵庫県 和歌山県 ## 79 118 219 108 175 298 28 85 24 ここでPrefをfactor化しますが、水準の順番を店舗数が多い方を先にするにはどうすれば良いでしょうか。fct_infreq()関数は指定された変数の各値の個数を計算し、多い順にfactorの水準を調整します。 df2 &lt;- df2 %&gt;% # 多く出現した値順でfactor化する mutate(Pref = fct_infreq(Pref)) levels(df2$Pref) # df2のPref変数の水準を出力 ## [1] &quot;東京都&quot; &quot;神奈川県&quot; &quot;大阪府&quot; &quot;埼玉県&quot; &quot;千葉県&quot; &quot;兵庫県&quot; &quot;京都府&quot; ## [8] &quot;奈良県&quot; &quot;和歌山県&quot; \"東京都\"、\"神奈川県\"、\"大阪府\"、…の順で水準の順番が調整され、これはtable(df$Pref2)の順位とも一致します。 12.2.5 fct_inorder(): データ内の出現順番に順番を変更する 続いて、fct_inorder()ですが、これは意外と頻繁に使われる関数です。たとえば、自分でデータフレームなどを作成し、ケースの順番も綺麗に整えたとします。しかし、既に指摘した通り、データフレーム (または、tibble)での順番とグラフにおける順番は一致するとは限りません。データフレームに格納された順番でfactorの水準が設定できれば非常に便利でしょう。そこで使うのがfct_inorder()です。 たとえば、dfのPrefは\"東京都\"が1000個並び、続いて\"神奈川県\"が1000個、\"千葉県\"が1000個、…の順番で格納されています。この順番をそのままfactorの順番にするには以下のように書きます。 df3 &lt;- df %&gt;% # Pref変数をfactor化し、水準は出現順とする # 変換後の結果はPrefに上書きする mutate(Pref = fct_inorder(Pref)) levels(df3$Pref) ## [1] &quot;東京都&quot; &quot;神奈川県&quot; &quot;千葉県&quot; &quot;埼玉県&quot; &quot;大阪府&quot; &quot;京都府&quot; &quot;兵庫県&quot; ## [8] &quot;奈良県&quot; &quot;和歌山県&quot; 12.2.6 fct_shift(): 水準の順番をずらす 続いて、水準の順番をずらすfct_shift()関数を紹介します。たとえば、「1:そう思う」〜「5:そう思わない」、「9:答えたくない」の6水準で構成された変数があるとします。 df4 &lt;- tibble( ID = 1:10, Q1 = c(1, 5, 3, 2, 9, 2, 4, 9, 5, 1) ) df4 &lt;- df4 %&gt;% mutate(Q1 = factor(Q1, levels = c(1:5, 9), labels = c(&quot;そう思う&quot;, &quot;どちらかと言えばそう思う&quot;, &quot;どちらとも言えない&quot;, &quot;どちらかと言えばそう思わない&quot;, &quot;そう思わない&quot;, &quot;答えたくない&quot;))) df4 ## # A tibble: 10 x 2 ## ID Q1 ## &lt;int&gt; &lt;fct&gt; ## 1 1 そう思う ## 2 2 そう思わない ## 3 3 どちらとも言えない ## 4 4 どちらかと言えばそう思う ## 5 5 答えたくない ## 6 6 どちらかと言えばそう思う ## 7 7 どちらかと言えばそう思わない ## 8 8 答えたくない ## 9 9 そう思わない ## 10 10 そう思う 水準の順番も「そう思う」〜「答えたくない」順で綺麗に整っています。この水準を反転するにはfct_rev()関数が便利です。Q1の水準を反転した変数をQ1_Rという新しい列として追加し、水準を確認してみましょう。 df4 &lt;- df4 %&gt;% mutate(Q1_R = fct_rev(Q1)) df4 ## # A tibble: 10 x 3 ## ID Q1 Q1_R ## &lt;int&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 そう思う そう思う ## 2 2 そう思わない そう思わない ## 3 3 どちらとも言えない どちらとも言えない ## 4 4 どちらかと言えばそう思う どちらかと言えばそう思う ## 5 5 答えたくない 答えたくない ## 6 6 どちらかと言えばそう思う どちらかと言えばそう思う ## 7 7 どちらかと言えばそう思わない どちらかと言えばそう思わない ## 8 8 答えたくない 答えたくない ## 9 9 そう思わない そう思わない ## 10 10 そう思う そう思う levels(df4$Q1_R) ## [1] &quot;答えたくない&quot; &quot;そう思わない&quot; ## [3] &quot;どちらかと言えばそう思わない&quot; &quot;どちらとも言えない&quot; ## [5] &quot;どちらかと言えばそう思う&quot; &quot;そう思う&quot; 「答えたくない」が最初の順番に来ましてね。できれば、「そう思わない」〜「そう思う」、「答えたくない」の順番にしたいところです。ここで使うのがfct_shift()ですが、書き方がややこしいので、噛み砕いて解説します。 # fct_shift()の使い方 データ名 %&gt;% mutate(新しい変数名 = fct_shift(元の変数名, n = 左方向へずらす個数)) 問題はn =引数ですが、その挙動については以下の表を参照してください。 水準の順番 1番目 2番目 3番目 4番目 5番目 6番目 n = -2 E F A B C D n = -1 F A B C D E n = 0 A B C D E F n = 1 B C D E F A n = 2 C D E F A B 具体的には水準は左方向へn個移動します。元の水準がA, B, C, …, Fの順で、n = 1の場合、AがFの後ろへ移動し、B, C, D, E, Fが前の方へ1つずつ移動します。逆に右側へ1つ移動したい場合はn = -1のように書きます。今回は最初の水準を最後に移動させたいので、n = 1と指定します。 df4 &lt;- df4 %&gt;% # Q1_Rの水準を左方向で1ずらす mutate(Q1_R = fct_shift(Q1_R, n = 1)) levels(df4$Q1_R) ## [1] &quot;そう思わない&quot; &quot;どちらかと言えばそう思わない&quot; ## [3] &quot;どちらとも言えない&quot; &quot;どちらかと言えばそう思う&quot; ## [5] &quot;そう思う&quot; &quot;答えたくない&quot; これで水準の反転が完了しました。fct_shift()はこのように世論調査データの処理に便利ですが、他にも曜日の処理に使えます。例えば、1週間の始まりを月曜にするか日曜にするかによって、fct_shift()を使うケースがあります。 12.2.7 fct_shuffle(): 水準の順番をランダム化する あまり使わない機能ですが、水準の順番をランダム化することも可能です。使い方は非常に簡単で、fct_shuffle()に元の変数名を入れるだけです。たとえば、Score_dfのPrefの順番をランダム化し、Pref2として追加します。同じことをもう2回繰り返し、それぞれPref3とPref4という名前で追加してみましょう。 Score_df &lt;- Score_df %&gt;% mutate(Pref2 = fct_shuffle(Pref), Pref3 = fct_shuffle(Pref), Pref4 = fct_shuffle(Pref)) Score_df ## # A tibble: 9 x 5 ## Pref Score Pref2 Pref3 Pref4 ## &lt;chr&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 京都府 3.68 京都府 京都府 京都府 ## 2 埼玉県 3.64 埼玉県 埼玉県 埼玉県 ## 3 神奈川県 3.53 神奈川県 神奈川県 神奈川県 ## 4 千葉県 3.72 千葉県 千葉県 千葉県 ## 5 大阪府 3.77 大阪府 大阪府 大阪府 ## 6 東京都 3.67 東京都 東京都 東京都 ## 7 奈良県 3.85 奈良県 奈良県 奈良県 ## 8 兵庫県 3.54 兵庫県 兵庫県 兵庫県 ## 9 和歌山県 3.97 和歌山県 和歌山県 和歌山県 levels(Score_df$Pref2) ## [1] &quot;千葉県&quot; &quot;和歌山県&quot; &quot;大阪府&quot; &quot;兵庫県&quot; &quot;神奈川県&quot; &quot;東京都&quot; &quot;奈良県&quot; ## [8] &quot;京都府&quot; &quot;埼玉県&quot; levels(Score_df$Pref3) ## [1] &quot;大阪府&quot; &quot;埼玉県&quot; &quot;東京都&quot; &quot;神奈川県&quot; &quot;千葉県&quot; &quot;和歌山県&quot; &quot;奈良県&quot; ## [8] &quot;京都府&quot; &quot;兵庫県&quot; levels(Score_df$Pref4) ## [1] &quot;神奈川県&quot; &quot;東京都&quot; &quot;千葉県&quot; &quot;埼玉県&quot; &quot;和歌山県&quot; &quot;兵庫県&quot; &quot;京都府&quot; ## [8] &quot;大阪府&quot; &quot;奈良県&quot; PrefからPref4まで同じように見えますが、水準の順番が異なります (Prefはcharacter型だから水準がありません)。 12.2.8 fct_reorder(): 別の1変数の値を基準に水準の順番を変更する fct_infreq()は出現頻度順に並び替える関数でしたが、それと似たような関数としてfct_reorder()があります。ただし、これは出現頻度を基準にするのではなく、ある変数の平均値が低い順、中央値が高い順などでソートされます。まずは使い方から確認します。 データ名 %&gt;% mutate(新しい変数名 = fct_reorder(元の変数名, 基準となる変数, 関数名, 関数の引数)) 必要な引数が多いですね。解説よりも実際の例を見ながら説明します。今回もPrefをfactor変数にし、Pref_Rという列で格納しますが、平均予算が安い順でfactorの水準を決めたいと思います。 df &lt;- df %&gt;% mutate(Pref_R = fct_reorder(Pref, Budget, mean, na.rm = TRUE)) levels(df$Pref_R) ## [1] &quot;千葉県&quot; &quot;埼玉県&quot; &quot;奈良県&quot; &quot;兵庫県&quot; &quot;大阪府&quot; &quot;神奈川県&quot; &quot;和歌山県&quot; ## [8] &quot;東京都&quot; &quot;京都府&quot; Pref_Rの水準は千葉県、埼玉県、奈良県、…の順ですが、本当にそうでしょうか。group_by()とsummarise()などを使って確認してみましょう。 df %&gt;% group_by(Pref) %&gt;% summarise(Budget = mean(Budget, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(Budget) ## # A tibble: 9 x 2 ## Pref Budget ## &lt;chr&gt; &lt;dbl&gt; ## 1 千葉県 1124. ## 2 埼玉県 1147. ## 3 奈良県 1169. ## 4 兵庫県 1197. ## 5 大阪府 1203. ## 6 神奈川県 1239. ## 7 和歌山県 1252 ## 8 東京都 1283. ## 9 京都府 1399. 問題なくソートされましたね。注意点としてはfct_reorder()内に関数名を書く際、()は不要という点です。関数名の次の引数としてはその関数に別途必要な引数を指定します。引数が省略可能、あるいは不要な関数を使う場合は、省略しても構いませんし、数に制限はありません。 また、低い順ではなく、高い順にすることも可能です。次はScoreの中央値が高い順に水準を設定したPref_R2を作ってみましょう。 df &lt;- df %&gt;% mutate(Pref_R2 = fct_reorder(Pref, Score, median, na.rm = TRUE, .desc = TRUE)) levels(df$Pref_R2) ## [1] &quot;和歌山県&quot; &quot;奈良県&quot; &quot;千葉県&quot; &quot;大阪府&quot; &quot;東京都&quot; &quot;埼玉県&quot; &quot;京都府&quot; ## [8] &quot;神奈川県&quot; &quot;兵庫県&quot; 変わったのはmeanの代わりにmedianを使ったこと、そして.desc引数が追加された点です。fct_reorder()には.desc = FALSEがデフォルトとして指定されており、省略した場合は昇順でfactorの水準が決まります。ここで.desc = TRUEを指定すると、降順となります。実際、Scoreの中央値順になっているかを確認してみましょう。 df %&gt;% group_by(Pref) %&gt;% summarise(Score = median(Score, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(desc(Score)) ## # A tibble: 9 x 2 ## Pref Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 和歌山県 4 ## 2 奈良県 3.88 ## 3 千葉県 3.75 ## 4 大阪府 3.75 ## 5 東京都 3.64 ## 6 埼玉県 3.61 ## 7 京都府 3.5 ## 8 神奈川県 3.5 ## 9 兵庫県 3.5 12.2.9 fct_reorder2(): 別の2変数の値を基準に水準の順番を変更する この関数は別の変数を基準に水準が調整される点ではfct_reorder()と類似しています。ただし、よく誤解されるのは「変数Aの値が同じなら変数Bを基準に…」といったものではありません。たとえば、fct_reorder(x, y, mean)の場合、yの平均値 (mean())の順でxの水準を調整するという意味です。このmean()関数に必要なデータはベクトル1つです。しかし、関数によっては2つの変数が必要な場合があります。 これは頻繁に直面する問題ではありませんが、このfct_reorder2()関数が活躍するケースを紹介します。以下は6月27日から7月1日までの5日間、5地域におけるCOVID-19新規感染者数を表したデータです61。入力が面倒な方はここからダウンロードして読み込んでください。 # 入力が面倒ならデータをダウンロードし、 # Reorder2_df &lt;- read_csv(&quot;Data/COVID19.csv&quot;) Reorder2_df &lt;- tibble( Country = rep(c(&quot;日本&quot;, &quot;韓国&quot;, &quot;中国 (本土)&quot;, &quot;台湾&quot;, &quot;香港&quot;), each = 5), Date = rep(c(&quot;2020/06/27&quot;, &quot;2020/06/28&quot;, &quot;2020/06/29&quot;, &quot;2020/06/30&quot;, &quot;2020/07/01&quot;), 5), NewPat = c(100, 93, 86, 117, 130, 62, 42, 43, 50, 54, 17, 12, 19, 3, 5, 0, 0, 0, 0, 0, 1, 2, 4, 2, 28) ) Reorder2_df &lt;- Reorder2_df %&gt;% mutate(Date = as.Date(Date)) Reorder2_df ## # A tibble: 25 x 3 ## Country Date NewPat ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 日本 2020-06-27 100 ## 2 日本 2020-06-28 93 ## 3 日本 2020-06-29 86 ## 4 日本 2020-06-30 117 ## 5 日本 2020-07-01 130 ## 6 韓国 2020-06-27 62 ## 7 韓国 2020-06-28 42 ## 8 韓国 2020-06-29 43 ## 9 韓国 2020-06-30 50 ## 10 韓国 2020-07-01 54 ## # … with 15 more rows 可視化のコードはとりあえず無視し、グラフを出力してみましょう。 Reorder2_df %&gt;% ggplot() + geom_line(aes(x = Date, y = NewPat, color = Country), size = 1) + scale_x_date(date_labels = &quot;%Y年%m月%d日&quot;) + labs(x = &quot;年月日&quot;, y = &quot;新規感染者数 (人)&quot;, color = &quot;&quot;) + theme_gray(base_family = &quot;HiraKakuProN-W3&quot;) このグラフに違和感はあまりありませんが、「読みやすさ」の麺では改善の余地があります。たとえば、7月1日の時点で、新規感染者数が多いのは日本、韓国、香港、中国 (本土)、台湾の順です。しかし、右側の凡例の順番はそうではありません。この順番が一致すれば、更に図は読みやすくなるでしょう。 factor(Reorder2_df$Country) ## [1] 日本 日本 日本 日本 日本 韓国 韓国 ## [8] 韓国 韓国 韓国 中国 (本土) 中国 (本土) 中国 (本土) 中国 (本土) ## [15] 中国 (本土) 台湾 台湾 台湾 台湾 台湾 香港 ## [22] 香港 香港 香港 香港 ## Levels: 韓国 香港 台湾 中国 (本土) 日本 実際、何も指定せずにReorder2_dfのCountryをfactor化すると、韓国、香港、台湾、…の順であり、これは上のグラフと一致します。これをグラフにおける7月1日の新規感染者数の順で並べるためには、Dateを昇順にソートし、そして最後の要素 (\"2020/07/01\")内で新規感染者数 (NewPat)を降順に並べ替えた場合の順番にする必要があります。実際、Reorder2_dfをDateで昇順、NewPatで降順にソートし、最後の5行を抽出した結果が以下のコードです。 Reorder2_df %&gt;% arrange(Date, desc(NewPat)) %&gt;% slice_tail(n = 5) ## # A tibble: 5 x 3 ## Country Date NewPat ## &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; ## 1 日本 2020-07-01 130 ## 2 韓国 2020-07-01 54 ## 3 香港 2020-07-01 28 ## 4 中国 (本土) 2020-07-01 5 ## 5 台湾 2020-07-01 0 このように、水準を調整する際に2つの変数 (DateとNewPat)が使用されます。fct_reorder2()はfct_reorder()と買い方がほぼ同じですが、基準となる変数がもう一つ加わります。 データ名 %&gt;% mutate(新しい変数名 = fct_reorder2(元の変数名, 基準となる変数1, 基準となる変数2, 関数名, 関数の引数)) 重要なのはここの関数のところですが、fct_reorder2()はデフォルトでlast2()という関数が指定されており、まさに私たちに必要な関数です。したがって、ここでは関数名も省略できますが、ここでは一応明記しておきます。 Reorder2_df &lt;- Reorder2_df %&gt;% mutate(Country2 = fct_reorder2(Country, Date, NewPat, last2)) それでは新しく出来たCountry2の水準を確認してみましょう。 levels(Reorder2_df$Country2) ## [1] &quot;日本&quot; &quot;韓国&quot; &quot;香港&quot; &quot;中国 (本土)&quot; &quot;台湾&quot; ちゃんと7月1日の新規感染者数基準で水準の順番が調整されましたので、これを使ってグラフをもう一回作ってみます。 Reorder2_df %&gt;% ggplot() + geom_line(aes(x = Date, y = NewPat, color = Country2), size = 1) + scale_x_date(date_labels = &quot;%Y年%m月%d日&quot;) + labs(x = &quot;年月日&quot;, y = &quot;新規感染者数 (人)&quot;, color = &quot;&quot;) + theme_gray(base_family = &quot;HiraKakuProN-W3&quot;) これで図がさらに読みやすくなりました。ちなみに、forcatsパッケージはlast2()以外にもfirst2()という関数も提供しております。これを使うと、7月1日でなく、6月27日の新規感染者数の降順で水準の順番が調整されます。他にも引数を2つ使用する自作関数も使えますが、fct_reorder2()の主な使いみちはlast2()で十分でしょう。 12.2.10 fct_collapse(): 水準を統合する 水準数をより水準数に減らすためには、fct_recode()を使います。先ほど、fct_shift()で使ったdf4の例を考えてみましょう。df4のQ1の水準数は6つです。 levels(df4$Q1) ## [1] &quot;そう思う&quot; &quot;どちらかと言えばそう思う&quot; ## [3] &quot;どちらとも言えない&quot; &quot;どちらかと言えばそう思わない&quot; ## [5] &quot;そう思わない&quot; &quot;答えたくない&quot; これを4つに減らして見ましょう。具体的には「そう思う」と「どちらかと言えばそう思う」を「そう思う」に、「そう思わない」と「どちらかと言えばそう思わない」を「そう思わない」に統合します。これをfct_recode()で処理したのが以下のコードです。 # fct_recode()を使った例 df4 &lt;- df4 %&gt;% mutate(Q1_R2 = fct_recode(Q1, そう思う = &quot;そう思う&quot;, そう思う = &quot;どちらかと言えばそう思う&quot;, どちらとも言えない = &quot;どちらとも言えない&quot;, そう思わない = &quot;どちらかと言えばそう思わない&quot;, そう思わない = &quot;そう思わない&quot;, 答えたくない = &quot;答えたくない&quot;)) df4 ## # A tibble: 10 x 4 ## ID Q1 Q1_R Q1_R2 ## &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 そう思う そう思う そう思う ## 2 2 そう思わない そう思わない そう思わない ## 3 3 どちらとも言えない どちらとも言えない どちらとも言えない ## 4 4 どちらかと言えばそう思う どちらかと言えばそう思う そう思う ## 5 5 答えたくない 答えたくない 答えたくない ## 6 6 どちらかと言えばそう思う どちらかと言えばそう思う そう思う ## 7 7 どちらかと言えばそう思わない どちらかと言えばそう思わない そう思わない ## 8 8 答えたくない 答えたくない 答えたくない ## 9 9 そう思わない そう思わない そう思わない ## 10 10 そう思う そう思う そう思う levels(df4$Q1_R2) ## [1] &quot;そう思う&quot; &quot;どちらとも言えない&quot; &quot;そう思わない&quot; &quot;答えたくない&quot; しかし、水準を統合するに特化したfct_collapse()を使えばより便利です。使い方は、fct_recode()に非常に似ているため省略しますが、=の右側をc()でまとめることが出来ます。 # fct_collapse()を使った例 df4 &lt;- df4 %&gt;% mutate(Q1_R3 = fct_collapse(Q1, そう思う = c(&quot;そう思う&quot;, &quot;どちらかと言えばそう思う&quot;), どちらとも言えない = &quot;どちらとも言えない&quot;, そう思わない = c( &quot;どちらかと言えばそう思わない&quot;, &quot;そう思わない&quot;), 答えたくない = &quot;答えたくない&quot;)) df4 ## # A tibble: 10 x 5 ## ID Q1 Q1_R Q1_R2 Q1_R3 ## &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 そう思う そう思う そう思う そう思う ## 2 2 そう思わない そう思わない そう思わない そう思わない ## 3 3 どちらとも言えない どちらとも言えない どちらとも言えない… どちらとも言えない… ## 4 4 どちらかと言えばそう思う どちらかと言えばそう思う… そう思う そう思う ## 5 5 答えたくない 答えたくない 答えたくない 答えたくない ## 6 6 どちらかと言えばそう思う どちらかと言えばそう思う… そう思う そう思う ## 7 7 どちらかと言えばそう思わない… どちらかと言えばそう思わない… そう思わない そう思わない ## 8 8 答えたくない 答えたくない 答えたくない 答えたくない ## 9 9 そう思わない そう思わない そう思わない そう思わない ## 10 10 そう思う そう思う そう思う そう思う levels(df4$Q1_R3) ## [1] &quot;そう思う&quot; &quot;どちらとも言えない&quot; &quot;そう思わない&quot; &quot;答えたくない&quot; fct_recode()の結果と同じ結果が得られました。元の水準数や、減らされる水準数などによっては書く手間があまり変わらないので、好きな方を使っても良いでしょう。 12.2.11 fct_drop(): 使われていない水準を除去する 水準としては存在するものの、データとしては存在しないケースもあります。これをここでは「空水準 (empty levels)」と呼びます。たとえば、以下のコードはPrefをfactor化してからPref == \"奈良県\"のケースを落としたものです。 Score_df_f2 &lt;- df %&gt;% mutate(Pref = fct_inorder(Pref)) %&gt;% filter(Pref != &quot;奈良県&quot;) %&gt;% group_by(Pref) %&gt;% summarise(Score = mean(Score, na.rm = TRUE), .groups = &quot;drop&quot;) Score_df_f2 ## # A tibble: 8 x 2 ## Pref Score ## &lt;fct&gt; &lt;dbl&gt; ## 1 東京都 3.67 ## 2 神奈川県 3.53 ## 3 千葉県 3.72 ## 4 埼玉県 3.64 ## 5 大阪府 3.77 ## 6 京都府 3.68 ## 7 兵庫県 3.54 ## 8 和歌山県 3.97 このように結果としては、奈良県のデータを除外したため空水準である奈良県は表示されませんが、Pref変数はどうでしょうか。 levels(Score_df_f2$Pref) ## [1] &quot;東京都&quot; &quot;神奈川県&quot; &quot;千葉県&quot; &quot;埼玉県&quot; &quot;大阪府&quot; &quot;京都府&quot; &quot;兵庫県&quot; ## [8] &quot;奈良県&quot; &quot;和歌山県&quot; このように水準としては残っていることが分かります。使われていない水準が分析や可視化に影響を与えないケースもありますが、与えるケースもあります。これもこれまで勉強してきたfct_*()関数群で対応可能ですが、fct_drop()関数を使えば一発で終わります。実際にやってみましょう。 Score_df_f2 &lt;- Score_df_f2 %&gt;% mutate(Pref = fct_drop(Pref)) levels(Score_df_f2$Pref) ## [1] &quot;東京都&quot; &quot;神奈川県&quot; &quot;千葉県&quot; &quot;埼玉県&quot; &quot;大阪府&quot; &quot;京都府&quot; &quot;兵庫県&quot; ## [8] &quot;和歌山県&quot; 水準から奈良県が消えました。同じ機能をする関数としてはR内蔵関数であるdroplevels()関数があり、使い方はfct_drop()と同じです。 12.2.12 fct_expand(): 水準を追加する 一方、空水準を追加することも可能です。fct_expand()関数には元の変数名に加え、追加する水準名を入れるだけです。たとえば、dfのPrefの水準は関東と関西の9都府県名となっていますが、ここに\"滋賀県\"という水準を追加してみます。。 df5 &lt;- df %&gt;% mutate(Pref = fct_expand(Pref, &quot;滋賀県&quot;)) levels(df5$Pref) ## [1] &quot;京都府&quot; &quot;埼玉県&quot; &quot;神奈川県&quot; &quot;千葉県&quot; &quot;大阪府&quot; &quot;東京都&quot; &quot;奈良県&quot; ## [8] &quot;兵庫県&quot; &quot;和歌山県&quot; &quot;滋賀県&quot; \"滋賀県\"という新しい水準が出来ましたね。ただし、新しく追加された水準は最後の順番になりますので、修正が必要な場合はfct_relevel()などを使って適宜修正してください。 新しく水準が追加されることによって、何かの変化はあるでしょうか。まずは都府県ごとにScoreの平均値とケース数を計算してみましょう。 df5 %&gt;% group_by(Pref) %&gt;% summarise(Score = mean(Score, na.rm = TRUE), N = n(), .groups = &quot;drop&quot;) ## # A tibble: 9 x 3 ## Pref Score N ## &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 京都府 3.68 414 ## 2 埼玉県 3.64 1000 ## 3 神奈川県 3.53 1000 ## 4 千葉県 3.72 1000 ## 5 大阪府 3.77 1000 ## 6 東京都 3.67 1000 ## 7 奈良県 3.85 147 ## 8 兵庫県 3.54 591 ## 9 和歌山県 3.97 140 見た目は全く変わらず、滋賀県の行が新しく出来たわけでもありません。dplyrのgroup_by()の場合、空水準はグループ化の対象になりません。一方、多くのR内蔵関数はケースとして存在しなくても計算の対象となります。たとえば、ベクトル内のある値が何個格納されているか確認するtable()関数の例を見てみましょう。 table(df5$Pref) ## ## 京都府 埼玉県 神奈川県 千葉県 大阪府 東京都 奈良県 兵庫県 和歌山県 ## 414 1000 1000 1000 1000 1000 147 591 140 ## 滋賀県 ## 0 \"滋賀県\"という列があり、合致するケースが0と表示されます。group_by()でも空の水準まで含めて出力する引数.dropがあります。デフォルトはTRUEですが、これをFALSEに指定してみます。 df5 %&gt;% group_by(Pref, .drop = FALSE) %&gt;% summarise(Score = mean(Score, na.rm = TRUE), N = n(), .groups = &quot;drop&quot;) ## # A tibble: 10 x 3 ## Pref Score N ## &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; ## 1 京都府 3.68 414 ## 2 埼玉県 3.64 1000 ## 3 神奈川県 3.53 1000 ## 4 千葉県 3.72 1000 ## 5 大阪府 3.77 1000 ## 6 東京都 3.67 1000 ## 7 奈良県 3.85 147 ## 8 兵庫県 3.54 591 ## 9 和歌山県 3.97 140 ## 10 滋賀県 NaN 0 空水準も出力され、Scoreの平均値は計算不可 (NaN)、ケース数は0という結果が得られました。 12.2.13 fct_explicit_na(): 欠損値に水準を与える まずは、実習用データdf6を作ってみまます。X1はnumeric型変数ですが、これをfactor化します。最初からtibble()内でfactor化しておいても問題ありませんが、練習だと思ってください。 df6 &lt;- tibble( ID = 1:10, X1 = c(1, 3, 2, NA, 2, 2, 1, NA, 3, NA) ) df6 &lt;- df6 %&gt;% mutate(X1 = factor(X1, levels = c(1, 2, 3), labels = c(&quot;ラーメン&quot;, &quot;うどん&quot;, &quot;そば&quot;))) df6 ## # A tibble: 10 x 2 ## ID X1 ## &lt;int&gt; &lt;fct&gt; ## 1 1 ラーメン ## 2 2 そば ## 3 3 うどん ## 4 4 &lt;NA&gt; ## 5 5 うどん ## 6 6 うどん ## 7 7 ラーメン ## 8 8 &lt;NA&gt; ## 9 9 そば ## 10 10 &lt;NA&gt; それではX1をグループ化変数とし、ケース数を計算してみましょう。 df6 %&gt;% group_by(X1) %&gt;% summarise(N = n(), .groups = &quot;drop&quot;) ## # A tibble: 4 x 2 ## X1 N ## &lt;fct&gt; &lt;int&gt; ## 1 ラーメン 2 ## 2 うどん 3 ## 3 そば 2 ## 4 &lt;NA&gt; 3 NAもグループ化の対象となります。以下はこの欠損値も一つの水準として指定する方法について紹介します。欠損値を欠損値のままにするケースが多いですが、欠損値が何らかの意味を持つ場合、分析の対象になります。たとえば、多項ロジスティック回帰の応答変数として「分からない/答えたくない」を含めたり、「分からない/答えたくない」を選択する要因を分析したい場合は、欠損値に値を与える必要があります。なぜなら、一般的な分析において欠損値は分析対象から除外されるからです。 まずは、これまで紹介した関数を使ったやり方から紹介します。 df6 %&gt;% # まず、X1をcharacter型に変換し、X2という列に保存 mutate(X2 = as.character(X1), # X2がNAなら&quot;欠損値&quot;、それ以外なら元のX2の値に置換 X2 = ifelse(is.na(X2), &quot;欠損値&quot;, X2), # X2を再度factor化する X2 = factor(X2, levels = c(&quot;ラーメン&quot;, &quot;うどん&quot;, &quot;そば&quot;, &quot;欠損値&quot;))) ## # A tibble: 10 x 3 ## ID X1 X2 ## &lt;int&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 ラーメン ラーメン ## 2 2 そば そば ## 3 3 うどん うどん ## 4 4 &lt;NA&gt; 欠損値 ## 5 5 うどん うどん ## 6 6 うどん うどん ## 7 7 ラーメン ラーメン ## 8 8 &lt;NA&gt; 欠損値 ## 9 9 そば そば ## 10 10 &lt;NA&gt; 欠損値 X1をcharacter型に戻す理由62は、水準にない値が入るとfactor化が解除されるからです。factor型をcharacter型に戻さずにdf6$X1のNAを\"欠損値\"に置換すると、以下のようになります。 # df6のX1がNAなら&quot;欠損&quot;、それ以外なら元のX1の値を返す ifelse(is.na(df6$X1), &quot;欠損値&quot;, df6$X1) ## [1] &quot;1&quot; &quot;3&quot; &quot;2&quot; &quot;欠損値&quot; &quot;2&quot; &quot;2&quot; &quot;1&quot; &quot;欠損値&quot; &quot;3&quot; ## [10] &quot;欠損値&quot; \"ラーメン\"と\"うどん\"、\"そば\"がfactor化前の1, 2, 3に戻っただけでなく、NAが\"欠損値\"というcharacter型に置換されたため、全体がcharacter型に変換されました。このように欠損値に水準を与える作業は難しくはありませんが、面倒な作業です。そこで登場する関数がfct_exlpicit_na()関数です。使い方は、元の変数に加え、欠損値の水準名を指定するna_levelです。 df6 &lt;- df6 %&gt;% # na_levelのデフォルト値は&quot;(Missing)&quot; mutate(X2 = fct_explicit_na(X1, na_level = &quot;欠損値&quot;)) df6 ## # A tibble: 10 x 3 ## ID X1 X2 ## &lt;int&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 ラーメン ラーメン ## 2 2 そば そば ## 3 3 うどん うどん ## 4 4 &lt;NA&gt; 欠損値 ## 5 5 うどん うどん ## 6 6 うどん うどん ## 7 7 ラーメン ラーメン ## 8 8 &lt;NA&gt; 欠損値 ## 9 9 そば そば ## 10 10 &lt;NA&gt; 欠損値 欠損値が一つの水準になったことが分かります。 df6 %&gt;% group_by(X2) %&gt;% summarise(N = n(), .groups = &quot;drop&quot;) ## # A tibble: 4 x 2 ## X2 N ## &lt;fct&gt; &lt;int&gt; ## 1 ラーメン 2 ## 2 うどん 3 ## 3 そば 2 ## 4 欠損値 3 むろん、group_by()を使ってもちゃんと出力されます。 12.3 練習問題 データの出典はGoogleです。↩︎ character型でなく、numeric型でも出来ます。↩︎ "],
["tidydata.html", "13. 整然データ構造 13.1 整然データ (tidy data)とは 13.2 Wide型からLong型へ 13.3 Long型からWide型へ 13.4 列の操作", " 13. 整然データ構造 本章ではグラフの作成に適した形へデータを整形することについて学習します。ただし、これはグラフに限られた話ではありません。作図に適したデータは分析にも適します。 13.1 整然データ (tidy data)とは 分析や作図に適したデータの形は整然データ、または簡潔データ (tidy data)と呼ばれます。整然データの概念はtidyverse世界の産みの親であるHadely Wickham先生が提唱した概念であり、詳細はHadley先生が2014年に発表した論文63を参照してください。 整然データは目指す到達点は非常に単純です。それは「データの構造 (structure)と意味 (semantic)を一致させる」ことです。そして、この「意味」を出来る限り小さい単位で分解します。 例えば、3人で構成されたあるクラス内の被験者に対し、投薬前後に測定した数学成績があるとします。投薬前の成績は\"Control\"、投薬後の状況を\"Treatment\"とします。これをまとめたのが表13.1です。 表 13.1: Messy Dataの例 (1) Name Control Treatment Hadley 90 90 Song 80 25 Yanai 100 95 また、以上の表は転置も可能であり、以下のように表現することが可能です (表13.2)。 表 13.2: Messy Dataの例 (2) Treat Hadely Song Yanai Control 90 80 100 Treatment 90 25 95 2つのデータが持つ情報は全く同じです。これは「同じ意味を持つが、異なる構造を持つ」とも言えます。このような多様性が生じる理由は行と列のあり方が各値を説明するに十分ではないからです。異なるデータ構造として表現される余地があるということです。 たとえば、表13.1の場合、各列は以下のような3つの情報があります。 Name: 被験者名 Control: 投薬前の数学成績 Treatment: 投薬後の数学成績 このデータの問題は「投薬有無」と「数学成績」が2回登場したという点です。1は問題ありませんが、2と3の値は「投薬有無 \\(\\times\\) 数学成績」の組み合わせです。一つの変数に2つの情報が含まれていますね。これによって、投薬有無を行にしても列にしてもいいわけです。「ならばこっちの方が柔軟だしいいのでは?」と思う方もいるかも知れません。しかし、パソコンはこの曖昧さが嫌いです。なぜなら、人間のような思考ができないからです。データフレームは縦ベクトルの集合であるから、各列には一つの情報のみ格納する必要があります。たとえば、以下のように列を変更するとしましょう。 Name: 被験者名 Treat: 投薬有無 Math_Score: 数学成績 Treatは投薬前なら\"Control\"の値を、投薬後なら\"Treatment\"の値が入ります。Math_Socreには数学成績が入ります。これに則って表に直したのが表13.3です。 表 13.3: 整然データの例 Name Treat Math_Score Hadley Control 90 Hadley Treatment 90 Song Control 80 Song Treatment 25 Yanai Control 100 Yanai Treatment 95 表が長くなりましたが、これなら一つの列に2つ以上の情報が含まれることはありません。この場合、表13.1と表13.2のように、行と列を転置することができるでしょうか。 表 13.4: 表13.3を転置した場合 Name Hadley Hadley Song Song Yanai Yanai Treat Control Treatment Control Treatment Control Treatment Math_Score 90 90 80 25 100 95 その結果が表13.4ですが、いかがでしょうか。まず、列名が重複している時点でアウトですし、人間が見ても非常に分かりにくい表になりました。また、一つの列に異なるデータ (この場合、character型とnumeirc型)が混在しています。パソコンから見てはわけのわからないデータになったわけです。 ここまで来たら整然データのイメージはある程度掴めたかも知れません。具体的に整然データとは次の4つの条件を満たすデータです(Wickham 2014)。 1つの列は、1つの変数を表す。 1つの行は、1つの観測を表す。 1つのセル（特定の列の特定の行）は、1つの値を表す。 1つの表は、1つの観測単位 (unit of observation)をもつ（異なる観測単位が混ざっていない）。 以下でも、表13.1と表13.3を対比しながら、以上の4条件をより詳しく説明します。 13.1.1 1つの列は、1つの変数を表す 表13.1と表13.3に含まれる情報は以下の3つで共通しています。 被験者名 投薬有無 数学成績 これらの情報がそれぞれデータの変数になるわけですが、整然データは一つの列が一つの変数を表します。それではまず、表13.1 (図13.1の左)から考えてみましょう。この図には3つの情報が全て含まれています。しかし、数学成績は2列に渡って格納されており、「1列1変数」の条件を満たしておりません。一方、表13.3 (図13.1の右)は投薬前後を表すTreat変数を作成し、その値に応じた数学成績が格納されており、「1列1変数」の条件を満たしています。 図 13.1: 1つの列は、1つの変数を表す 「1列1変数」は整然データの最も基本となる条件であり、整然データ作成の出発点とも言えます。 13.1.2 1つの行は、1つの観測を表す 図13.2の左は一行当たり、いくつの観察が含まれているでしょうか。そのためにはこのデータが何を観察しているかを考える必要があります。このデータは投薬前後の数学成績を観察し、量的に測定したものです。つまり、同じ人に対して2回観察を行ったことになります。したがって、投薬前の数学成績と投薬後の数学成績は別の観察であり、図13.2の左は3行の表ですが、実は6回分の観察が含まれていることになります。1行に2つの観察が載っていることですね。 図 13.2: 1つの行は、1つの観測を表す 一方、図13.2の右は6行のデータであり、観察回数とデータの行数が一致しています。つまり、1行に1観察となります。 今回は数学成績しか測っていたいので、簡単な例ですが、実際のデータには曖昧な部分があります。たとえば、投薬によって血圧が変化する可能性があるため、最高血圧もまた投薬前後に測定したとします。それが表13.5の左です。 表 13.5: 1行1観察の例 Name Treat Math Blood Hadley Control 90 110 Hadley Treatment 90 115 Song Control 80 95 Song Treatment 25 110 Yanai Control 100 100 Yanai Treatment 95 95 Name Treat Type Value Hadley Control Math 90 Hadley Control Blood 110 Hadley Treatment Math 90 Hadley Treatment Blood 115 Song Control Math 80 Song Control Blood 95 Song Treatment Math 25 Song Treatment Blood 110 Yanai Control Math 100 Yanai Control Blood 100 Yanai Treatment Math 95 Yanai Treatment Blood 95 3人に投薬前後に数学成績と最高血圧を測定した場合の観察回数は何回でしょう。3人 \\(\\times\\) 2時点 \\(\\times\\) 2指標の測定だから12回の測定でしょうか。ならば、表13.5の右が整然データでしょう。しかし、この場合、1列1変数という条件が満たされなくなります。Value列には数学成績と血圧が混在しており、2つの変数になります。ならば、どれも整然データではないということでしょうか。実は整然データは表13.5の左です。なぜなら、「1観察=1値」ではないからです。データにおける観察とは観察単位ごとに測定された値の集合です。観察対象とは人や自治体、企業、国などだけでなく、時間も含まれます。たとえば、人の特徴 (性別、身長、所得、政治関心など)を測定しもの、ある日の特徴 (気温、株価など)を測定したもの全てが観察です。むろん、人 \\(\\times\\) 時間のような組み合わせが観察単位ともなり得ます。この一つ一つの観察単位から得られた値の集合が観察です。表13.5の分析単位は「人 \\(\\times\\) 時間」です。成績や最高血圧は分析単位が持つ特徴や性質であって、分析単位ではありません。 13.1.3 1つのセルは、1つの値を表す この条件に反するケースはあまりないかも知れません。たとえば、「Hadleyは処置前後の数学成績が同じだし、一行にまとめよう」という意味で図13.3の左のような表を作る方もいるかも知れませんが、あまりいないでしょう。 図 13.3: 1つのセルは、1つの値を表す 図13.3の例は「1セル1値」の条件に明らかに反します。しかし、基準が曖昧な変数もあり、その一つが日付です。 表 13.6: 日付の扱い方 Date Stock 2020/06/29 100 2020/06/30 105 2020/07/01 110 2020/07/02 85 2020/07/03 90 Year Month Date Stock 2020 6 29 100 2020 6 30 105 2020 7 1 110 2020 7 2 85 2020 7 3 90 表13.6の左側の表はどうでしょうか。5日間の株価を記録した架空のデータですが、たしかにDate列には日付が1つずつ、Stockには株価の値が1つずつ格納されています。しかし、解釈によっては「Dateに年、月、日といった3つの値が含まれているぞ」と見ることもできます。この解釈に基づく場合、表13.6の右側の表が整然データとなり、左側は雑然データとなります。このケースは第一条件であった「一列一変数」とも関係します。なぜなら、Dateという列が年・月・日といった3変数で構成されているとも解釈できるからです。 分析によっては左側のような表でも全く問題ないケースもあります。時系列分析でトレンド変数のみ必要ならこれでも十分に整然データと呼べます。しかし、季節変動などの要素も考慮するならば、左側は雑然データになります。データとしての使い勝手は右側の方が優れているのは確かです。 データを出来る限り細かく分解するほど情報量が豊かになりますが、それにも限度はあるでしょう。たとえば、「Yearは実は世紀の情報も含まれているのでは…?」という解釈もできますが、これを反映してデータ整形を行うか否かは分析の目的と分析モデルによって異なります。この意味で、明らかな雑然データはあり得ますが、明らかな整然データは存在しないでしょう。どちらかといえば、整然さの度合いがあり、「これなら十分に整然データと言えないだろうか」と判断できれば十分ではないかと筆者 (Song)は考えます。 13.1.4 1つの表は、1つの観測単位をもつ e-statなどから国勢調査データをダウンロードした経験はあるでしょうか。以下の図13.4は2015年度国勢調査データの一部です。 図 13.4: 国勢調査データ このデータの観察単位はなんでしょうか。データのの1行目は全国の人口を表しています。つまり、単位は国となります。しかし、2行目は北海道の人口です。この場合の観測単位は都道府県となります。つづいて、3行目は札幌市なので単位は市区町村になります。4行目は札幌市中央区、つまり観測単位が行政区になっています。そして14行目は函館市でまた単位は市区町村に戻っています。実際、会社や政府が作成するデータには図13.4や図13.5のようなものが多いです。とりわけ、図13.5のように、最後の行に「合計」などが表記されている場合が多いです。 図 13.5: 1つの表は、1つの観測単位をもつ このような表・データを作成することが悪いことではありません。むしろ、「読む」ための表ならこのような書き方が一般的でしょう。しかし、「分析」のためのデータは観察の単位を統一する必要があります。 13.2 Wide型からLong型へ 以下では「1列1変数」の条件を満たすデータの作成に便利なpivot_longer()とpivot_wider()関数について解説します。この関数群はおなじみのdplyrでなく、tidyrパッケージが提供している関数ですが、どれもtidyverseパッケージ群に含まれているため、tidyverseパッケージを読み込むだけで十分です。本節ではpivot_longer()を、次節ではpivot_wider()を取り上げます。 まず、pivot_longer()ですが、この関数は比較的に新しい関数であり、これまではtidyrのgather()関数が使われてきました。しかし、gahter()関数は将来、なくなる予定の関数であり、今からtidyrを学習する方はpivot_*()関数群に慣れておきましょう。 まずはtidyverseパッケージを読み込みます。 library(tidyverse) 今回は様々な形のデータを変形する作業をするので、あるデータセットを使うよりも、架空の簡単なデータを使います。 df1 &lt;- tibble( Name = c(&quot;Hadley&quot;, &quot;Song&quot;, &quot;Yanai&quot;), Control = c(90, 80, 100), Treatment = c(90, 25, 95), Gender = c(&quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;) ) df1 ## # A tibble: 3 x 4 ## Name Control Treatment Gender ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Hadley 90 90 Male ## 2 Song 80 25 Female ## 3 Yanai 100 95 Female このデータは既に指摘した通り「1列1変数」の条件を満たしております。この条件を満たすデータは以下のような形となります。 ## # A tibble: 6 x 4 ## Name Gender Treat Math_Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Hadley Male Control 90 ## 2 Hadley Male Treatment 90 ## 3 Song Female Control 80 ## 4 Song Female Treatment 25 ## 5 Yanai Female Control 100 ## 6 Yanai Female Treatment 95 Treat変数が作成され、元々は変数名であった\"Control\"と\"Treatment\"が値として格納されます。この変数をキー変数と呼びます。そして、キー変数の値に応じた数学成績がMath_Scoreという変数でまとめられました。この変数を値変数と呼びます。 「1列1変数」を満たさなかった最初のデータは「Wide型データ」、これを満たすようなデータは「Long型データ」と呼ばれます。これは相対的に最初のデータが横に広いから名付けた名前であって、「Wide型=雑然データ」もしくは「Long型=雑然データ」ではないことに注意してください64。 Wide型データをLong型へ変換する関数がpivot_longer()であり、基本的な使い方は以下の通りです。 # pivot_longer()の使い方 データ名 %&gt;% pivot_longer(cols = c(まとめる変数1, まとめる変数2, ...), names_to = &quot;キー変数名&quot;, values_to = &quot;値変数名&quot;) ここでは同じ変数がControlとTreatment変数で分けられているため、まとめる変数はこの2つであり、cols = c(Control, Treatment)と指定します。ControlとTreatmentは\"で囲んでも、囲まなくても同じです。また、dplyrのselect()関数で使える変数選択の関数 (starts_with()、where()など)や:演算子も使用可能です。また、cols引数はpivot_longer()の第2引数であるため、cols =は省略可能です（第一引数はパイプにより既に渡されています）。 names_toとvalues_to引数はそれぞれキー変数名と値変数名を指定する引数で、ここは必ず\"で囲んでください。このdf1をLong型へ変換し、df1_Lと名付けるコードが以下のコードです。 df1_L &lt;- df1 %&gt;% pivot_longer(Control:Treatment, names_to = &quot;Treat&quot;, values_to = &quot;Math_Score&quot;) df1_L ## # A tibble: 6 x 4 ## Name Gender Treat Math_Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Hadley Male Control 90 ## 2 Hadley Male Treatment 90 ## 3 Song Female Control 80 ## 4 Song Female Treatment 25 ## 5 Yanai Female Control 100 ## 6 Yanai Female Treatment 95 これだけでもpivot_longer()関数を使ってWide型からLong型への変換は問題なくできますが、以下ではもうちょっと踏み込んだ使い方について解説します。「ここまでで十分だよ」という方は、ここを飛ばしても構いません。 今回の実習データdf3は3人の体重を3日間に渡って計測したものです。ただし、ドジっ子のSongは2日目にうっかり測るのを忘れており、欠損値となっています。 df2 &lt;- tibble( Name = c(&quot;Hadley&quot;, &quot;Song&quot;, &quot;Yanai&quot;), Day1 = c(75, 120, 70), Day2 = c(73, NA, 69), Day3 = c(71, 140, 71) ) df2 ## # A tibble: 3 x 4 ## Name Day1 Day2 Day3 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hadley 75 73 71 ## 2 Song 120 NA 140 ## 3 Yanai 70 69 71 まず、これをこれまでのやり方でLong型へ変形し、df2_Lと名付けます。 df2_L &lt;- df2 %&gt;% pivot_longer(starts_with(&quot;Day&quot;), names_to = &quot;Days&quot;, values_to = &quot;Weight&quot;) df2_L ## # A tibble: 9 x 3 ## Name Days Weight ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Hadley Day1 75 ## 2 Hadley Day2 73 ## 3 Hadley Day3 71 ## 4 Song Day1 120 ## 5 Song Day2 NA ## 6 Song Day3 140 ## 7 Yanai Day1 70 ## 8 Yanai Day2 69 ## 9 Yanai Day3 71 これでも問題ないかも知れませんが、以下のような操作を追加に行うとします。 Weightが欠損している行を除去する Days列の値から\"Day\"を除去し、numeric型にする 以上の作業を行うには、dplyrが便利でしょう。ちなみにstr_remove()関数が初めて登場しましたが、これについては第16章で詳細に解説します。簡単に説明しますと、str_remove(\"X123\", \"X\")は\"X123\"から\"X\"を除去し、\"123\"のみ残す関すです。残された値が数字のみであってもデータ型はcharacter型なので、もう一回、numeric型に変換する必要があります65。dplyrを使ったコードは以下の通りです。 # 1. WeightがNAのケースを除去 # 2. Days変数の値から&quot;Day&quot;を除去 # 3. Days変数をnumeric型へ変換 df2_L %&gt;% filter(!is.na(Weight)) %&gt;% # 1 mutate(Days = str_remove(Days, &quot;Day&quot;), # 2 Days = as.numeric(Days)) # 3 ## # A tibble: 8 x 3 ## Name Days Weight ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hadley 1 75 ## 2 Hadley 2 73 ## 3 Hadley 3 71 ## 4 Song 1 120 ## 5 Song 3 140 ## 6 Yanai 1 70 ## 7 Yanai 2 69 ## 8 Yanai 3 71 実はこの作業、pivot_longer()内で行うことも可能です。たとえば、values_toで指定した変数の値が欠損しているケースを除去するにはvalues_drop_na引数をTRUEに指定するだけです。 # Weight変数がNAのケースを除去する df2 %&gt;% pivot_longer(starts_with(&quot;Day&quot;), names_to = &quot;Days&quot;, values_to = &quot;Weight&quot;, values_drop_na = TRUE) ## # A tibble: 8 x 3 ## Name Days Weight ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Hadley Day1 75 ## 2 Hadley Day2 73 ## 3 Hadley Day3 71 ## 4 Song Day1 120 ## 5 Song Day3 140 ## 6 Yanai Day1 70 ## 7 Yanai Day2 69 ## 8 Yanai Day3 71 それでは、キー変数から共通する文字列を除去するにはどうすれば良いでしょうか。この場合、names_prefix引数を使います。これはnames_toで指定した新しく出来る変数の値における接頭詞を指定し、それを除去する引数です。今回は\"Day1\"、\"Day2\"、\"Day3\"から\"Day\"を除去するので、names_prefix = \"Day\"と指定します。こうすることで、Days列から\"Day\"が除去されます。ただし、数字だけ残っても、そのデータ型はcharacter型ですので、このデータ型を変換する必要があります。ここで使うのがnames_transform引数であり、これはlist型のオブジェクトを渡す必要があります。Days列をnumeric型にする場合はlist(Days = as.numeric)です。複数の列のデータ型を変える場合、list()の中に追加していきます。それでは実際に走らせてみましょう。 # 1. Day変数の値から&quot;Day&quot;を除去する # 2. Day変数をinteger型に変換 # 3. Weight変数がNAのケースを除去する df2 %&gt;% pivot_longer(starts_with(&quot;Day&quot;), names_to = &quot;Days&quot;, names_prefix = &quot;Day&quot;, # 1 names_transform = list(Days = as.numeric), # 2 values_to = &quot;Weight&quot;, values_drop_na = TRUE) # 3 ## # A tibble: 8 x 3 ## Name Days Weight ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hadley 1 75 ## 2 Hadley 2 73 ## 3 Hadley 3 71 ## 4 Song 1 120 ## 5 Song 3 140 ## 6 Yanai 1 70 ## 7 Yanai 2 69 ## 8 Yanai 3 71 これでWide型をLong型が変換され、整然でありながら、より見栄の良いデータが出来上がりました。他にもpivot_longer()は様々な引数に対応しており、詳細は?pivot_longerやレファレンスページを参照してください。 13.3 Long型からWide型へ ご存知の通り、「Long型データ=整然データ」ではありません。実際、表13.5の右はLong型データですが、1列に2つの変数が含まれており、整然データとは言えません。このようなデータはいくらでもあります。とりわけ、「分析」のためじゃなく、「読む」ための表の場合において多く発見されます。 表 13.7: Long型データの例 都道府県 区分 人口 面積 北海道 総人口 5381733 83424.31 外国人 21676 83424.31 青森県 総人口 1308265 9645.59 外国人 3447 9645.59 岩手県 総人口 1279594 15275.01 外国人 5017 15275.01 宮城県 総人口 2333899 7282.22 外国人 13989 7282.22 都道府県 総人口 外国人 面積 北海道 5381733 21676 83424.31 青森県 1308265 3447 9645.59 岩手県 1279594 5017 15275.01 宮城県 2333899 13989 7282.22 変数名が日本語になっていますが、これは「読むための表」を読み込むことを仮定しています。このように変数名として日本語は使えますが、自分でデータセットを作成する際、変数名はローマ字にすることを強く推奨します。 表13.7の左の場合、人口列に総人口と外国人人口といった2つの変数の値が格納されているため、整然データではありません。これを整然データにしたものが右の表です。本節ではLong型データをWide型データへ変換するpivot_wider()関数を紹介します。この関数は同じくtidyrが提供しているspread()関数とほぼ同じ関数ですが、今はpivot_wider()の使用が推奨されており、spread()はいずれかtidyrから外される予定です。 まずは、実習用データを読み込みます。 df3 &lt;- read_csv(&quot;Data/Population2015.csv&quot;) ## Parsed with column specification: ## cols( ## 都道府県 = col_character(), ## 区分 = col_character(), ## 人口 = col_double(), ## 面積 = col_double() ## ) df3 ## # A tibble: 94 x 4 ## 都道府県 区分 人口 面積 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 北海道 総人口 5381733 83424. ## 2 &lt;NA&gt; 外国人 21676 83424. ## 3 青森県 総人口 1308265 9646. ## 4 &lt;NA&gt; 外国人 3447 9646. ## 5 岩手県 総人口 1279594 15275. ## 6 &lt;NA&gt; 外国人 5017 15275. ## 7 宮城県 総人口 2333899 7282. ## 8 &lt;NA&gt; 外国人 13989 7282. ## 9 秋田県 総人口 1023119 11638. ## 10 &lt;NA&gt; 外国人 2914 11638. ## # … with 84 more rows このデータは2015年国勢調査から抜粋したデータであり、各変数の詳細は以下の通りです。 変数名 説明 都道府県 都道府県名 区分 総人口/外国人人口の区分 人口 人口 (人) 面積 面積 (km\\(^2\\)) まずは変数名が日本語になっているので、rename()関数を使ってそれぞれPref、Type、Population、Areaに変更します。 df3 &lt;- df3 %&gt;% rename(&quot;Pref&quot; = 都道府県, &quot;Type&quot; = 区分, &quot;Population&quot; = 人口, &quot;Area&quot; = 面積) df3 ## # A tibble: 94 x 4 ## Pref Type Population Area ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 北海道 総人口 5381733 83424. ## 2 &lt;NA&gt; 外国人 21676 83424. ## 3 青森県 総人口 1308265 9646. ## 4 &lt;NA&gt; 外国人 3447 9646. ## 5 岩手県 総人口 1279594 15275. ## 6 &lt;NA&gt; 外国人 5017 15275. ## 7 宮城県 総人口 2333899 7282. ## 8 &lt;NA&gt; 外国人 13989 7282. ## 9 秋田県 総人口 1023119 11638. ## 10 &lt;NA&gt; 外国人 2914 11638. ## # … with 84 more rows 次は、Pref列の欠損値を埋めましょう。ここの欠損値は、当該セルの一つ上のセルの値で埋まりますが、これはfill()関数で簡単に処理できます。欠損値を埋めたい変数名をfill()の引数として渡すだけです。 df3 &lt;- df3 %&gt;% fill(Pref) df3 ## # A tibble: 94 x 4 ## Pref Type Population Area ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 北海道 総人口 5381733 83424. ## 2 北海道 外国人 21676 83424. ## 3 青森県 総人口 1308265 9646. ## 4 青森県 外国人 3447 9646. ## 5 岩手県 総人口 1279594 15275. ## 6 岩手県 外国人 5017 15275. ## 7 宮城県 総人口 2333899 7282. ## 8 宮城県 外国人 13989 7282. ## 9 秋田県 総人口 1023119 11638. ## 10 秋田県 外国人 2914 11638. ## # … with 84 more rows そして、いよいよpivot_wider()関数の出番ですが、基本的に使い方は以下の通りです。 # pivot_wider()の使い方 データ名 %&gt;% pivot_wider(names_from = キー変数名, values_from = 値変数名) まず、キー変数名は列として展開する変数名であり、ここではTypeになります。そして、値変数名は展開される値の変数であり、ここではPopulationになります。つまり、「PopulationをTypeごとに分けて別の列にする」ことになります。また、values_from引数は長さ2以上のベクトルを指定することで、複数の値変数を指定することも可能です。たとえば、df3にIncomeという平均所得を表す列があり、これらも総人口と外国人それぞれ異なる値を持っているとしたら、values_from = c(Population, Income)のように複数の値変数を指定することが出来ます。今回は値変数が1つのみですが、早速やってみましょう。 df3_W &lt;- df3 %&gt;% pivot_wider(names_from = Type, values_from = Population) df3_W ## # A tibble: 47 x 4 ## Pref Area 総人口 外国人 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 北海道 83424. 5381733 21676 ## 2 青森県 9646. 1308265 3447 ## 3 岩手県 15275. 1279594 5017 ## 4 宮城県 7282. 2333899 13989 ## 5 秋田県 11638. 1023119 2914 ## 6 山形県 9323. 1123891 5503 ## 7 福島県 13784. 1914039 8725 ## 8 茨城県 6097. 2916976 41310 ## 9 栃木県 6408. 1974255 26494 ## 10 群馬県 6362. 1973115 37126 ## # … with 37 more rows また、日本語の変数名が出来てしまったので、それぞれTotalとForeignerに変更し、relocate()関数を使ってAreaを最後の列に移動します。 df3_W &lt;- df3_W %&gt;% rename(&quot;Total&quot; = 総人口, &quot;Foreigner&quot; = 外国人) %&gt;% relocate(Area, .after = last_col()) df3_W ## # A tibble: 47 x 4 ## Pref Total Foreigner Area ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 北海道 5381733 21676 83424. ## 2 青森県 1308265 3447 9646. ## 3 岩手県 1279594 5017 15275. ## 4 宮城県 2333899 13989 7282. ## 5 秋田県 1023119 2914 11638. ## 6 山形県 1123891 5503 9323. ## 7 福島県 1914039 8725 13784. ## 8 茨城県 2916976 41310 6097. ## 9 栃木県 1974255 26494 6408. ## 10 群馬県 1973115 37126 6362. ## # … with 37 more rows これで整然データの出来上がりです。 このpivot_wider()関数はpivot_longer()関数同様、様々な引数を提供しておりますが、主に使う機能は以上です。他にはpivot_wider()によって出来た欠損値を埋める引数であるvalues_fillがあり、デフォルト値はNULLです。ここに0や\"Missing\"などの長さ1のベクトルを指定すれば、指定した値で欠損値が埋まります。 pivot_wider()関数の詳細は?pivot_widerもしくは、レファレンスページを参照してください。 13.4 列の操作 他にも「1列1変数」の条件を満たさないケースを考えましょう。pivot_longer()は1つの変数が複数の列に渡って格納されている際に使いましたが、今回は1つの列に複数の変数があるケースを考えてみましょう。たとえば、年月日が1つの列に入っている場合、これを年、月、日の3列で分割する作業です。また、これと関連して、列から文字列を除去し、数値のみ残す方法についても紹介します。 実習用データを読み込んでみましょう。 df4 &lt;- read_csv(&quot;Data/COVID19_JK.csv&quot;) ## Parsed with column specification: ## cols( ## ID = col_double(), ## Date = col_character(), ## Week = col_character(), ## Confirmed_Japan = col_character(), ## Confirmed_Korea = col_character() ## ) df4 ## # A tibble: 172 x 5 ## ID Date Week Confirmed_Japan Confirmed_Korea ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 2020/1/16 木 1人 &lt;NA&gt; ## 2 2 2020/1/17 金 0人 &lt;NA&gt; ## 3 3 2020/1/18 土 0人 &lt;NA&gt; ## 4 4 2020/1/19 日 0人 &lt;NA&gt; ## 5 5 2020/1/20 月 0人 1人 ## 6 6 2020/1/21 火 0人 0人 ## 7 7 2020/1/22 水 0人 0人 ## 8 8 2020/1/23 木 0人 0人 ## 9 9 2020/1/24 金 2人 1人 ## 10 10 2020/1/25 土 0人 0人 ## # … with 162 more rows このデータは2020年1月16日から2020年7月5日まで、COVID-19 (新型コロナ)の新規感染者数を日本と韓国を対象に収集したものです。データはWikipedia (日本 / 韓国)から収集しました。韓国の新規感染者数は最初の4日分が欠損値のように見えますが、最初の感染者が確認されたのが1月20日のため、1月19日までは欠損となっています。 変数名 説明 ID ケースID Date 年月日 Week 曜日 Confirmed_Japan 新規感染者数 (日本) Confirmed_Korea 新規感染者数 (韓国) このデータの場合、観察単位は「国 \\(\\times\\) 日」です。しかし、df4は1行に日本と韓国の情報が格納されており「1行1観察」の条件を満たしておりません。したがって、pivot_longer()を使ってLong型へ変換し、新しいデータの名前をdf4_Lと名付けます。 df4_L &lt;- df4 %&gt;% pivot_longer(cols = starts_with(&quot;Confirmed&quot;), names_to = &quot;Country&quot;, names_prefix = &quot;Confirmed_&quot;, values_to = &quot;Confirmed&quot;) df4_L ## # A tibble: 344 x 5 ## ID Date Week Country Confirmed ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 2020/1/16 木 Japan 1人 ## 2 1 2020/1/16 木 Korea &lt;NA&gt; ## 3 2 2020/1/17 金 Japan 0人 ## 4 2 2020/1/17 金 Korea &lt;NA&gt; ## 5 3 2020/1/18 土 Japan 0人 ## 6 3 2020/1/18 土 Korea &lt;NA&gt; ## 7 4 2020/1/19 日 Japan 0人 ## 8 4 2020/1/19 日 Korea &lt;NA&gt; ## 9 5 2020/1/20 月 Japan 0人 ## 10 5 2020/1/20 月 Korea 1人 ## # … with 334 more rows 続いて、新規感染者数を表すConfirmed列から「人」を除去しましょう。人間にとってはなんの問題もありませんが、パソコンにとって1人や5人は文字列に過ぎず、分析ができる状態ではありません。ここで使う関数がparse_number()です。引数として指定した列から数値のみ抽出します。\"$1000\"や\"1, 324, 392\"のような数値でありながら、character型として保存されている列から数値のみを取り出す際に使う関数です。使い方は以下の通りです。 データ名 %&gt;% mutate(新しい変数名 = parse_number(数値のみ抽出する変数名)) 似たようなものとしてparse_character()があり、これは逆に文字列のみ抽出する関数です。 ここではConfimedから数値のみ取り出し、Confrimed列に上書きし、それをdf4_Sと名付けます。 df4_S &lt;- df4_L %&gt;% mutate(Confirmed = parse_number(Confirmed)) df4_S ## # A tibble: 344 x 5 ## ID Date Week Country Confirmed ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 2020/1/16 木 Japan 1 ## 2 1 2020/1/16 木 Korea NA ## 3 2 2020/1/17 金 Japan 0 ## 4 2 2020/1/17 金 Korea NA ## 5 3 2020/1/18 土 Japan 0 ## 6 3 2020/1/18 土 Korea NA ## 7 4 2020/1/19 日 Japan 0 ## 8 4 2020/1/19 日 Korea NA ## 9 5 2020/1/20 月 Japan 0 ## 10 5 2020/1/20 月 Korea 1 ## # … with 334 more rows それでは国、曜日ごとの新規感染者数を調べてみます。求める統計量は曜日ごとの新規感染者数の合計、平均、標準偏差です。まず、曜日は月から日の順になるよう、factor型に変換します。そして、国と曜日ごとに記述統計量を計算し、df4_S_Summary1という名で保存します。 df4_S &lt;- df4_S %&gt;% mutate(Week = factor(Week, levels = c(&quot;月&quot;, &quot;火&quot;, &quot;水&quot;, &quot;木&quot;, &quot;金&quot;, &quot;土&quot;, &quot;日&quot;))) df4_S_Summary1 &lt;- df4_S %&gt;% group_by(Country, Week) %&gt;% summarise(Sum = sum(Confirmed, na.rm = TRUE), Mean = mean(Confirmed, na.rm = TRUE), SD = sd(Confirmed, na.rm = TRUE), .groups = &quot;drop&quot;) df4_S_Summary1 ## # A tibble: 14 x 5 ## Country Week Sum Mean SD ## &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Japan 月 2540 106. 156. ## 2 Japan 火 2093 87.2 111. ## 3 Japan 水 2531 105. 133. ## 4 Japan 木 2704 108. 151. ## 5 Japan 金 3083 123. 172. ## 6 Japan 土 3327 133. 189. ## 7 Japan 日 3244 130. 179. ## 8 Korea 月 1609 67.0 126. ## 9 Korea 火 1641 68.4 111. ## 10 Korea 水 1626 67.8 102. ## 11 Korea 木 1883 78.5 137. ## 12 Korea 金 2099 87.5 143. ## 13 Korea 土 2194 91.4 174. ## 14 Korea 日 2088 87 215. df4_S_Summary1はこの状態で整然データですが、もし人間が読むための表を作るなら、韓国と日本を別の列に分けた方が良いかも知れません。pivot_wider()を使って、日本と韓国のの新規感染者数を2列に展開します。 df4_S_Summary1 %&gt;% pivot_wider(names_from = Country, values_from = Sum:SD) ## # A tibble: 7 x 7 ## Week Sum_Japan Sum_Korea Mean_Japan Mean_Korea SD_Japan SD_Korea ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 月 2540 1609 106. 67.0 156. 126. ## 2 火 2093 1641 87.2 68.4 111. 111. ## 3 水 2531 1626 105. 67.8 133. 102. ## 4 木 2704 1883 108. 78.5 151. 137. ## 5 金 3083 2099 123. 87.5 172. 143. ## 6 土 3327 2194 133. 91.4 189. 174. ## 7 日 3244 2088 130. 87 179. 215. これで人間にとって読みやすい表が出来ました。今は「日本の合計」、「韓国の合計」、「日本の平均」、…の順番ですが、これを日本と韓国それぞれまとめる場合は、relocate()を使います。 df4_S_Summary1 %&gt;% pivot_wider(names_from = Country, values_from = Sum:SD) %&gt;% relocate(Week, ends_with(&quot;Japan&quot;), ends_with(&quot;Korea&quot;)) ## # A tibble: 7 x 7 ## Week Sum_Japan Mean_Japan SD_Japan Sum_Korea Mean_Korea SD_Korea ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 月 2540 106. 156. 1609 67.0 126. ## 2 火 2093 87.2 111. 1641 68.4 111. ## 3 水 2531 105. 133. 1626 67.8 102. ## 4 木 2704 108. 151. 1883 78.5 137. ## 5 金 3083 123. 172. 2099 87.5 143. ## 6 土 3327 133. 189. 2194 91.4 174. ## 7 日 3244 130. 179. 2088 87 215. 新規感染者が確認されるのは金〜日曜日が多いことが分かります。 曜日ではなく、月ごとに記述統計料を計算する場合は、まずDate列を年、月、日に分割する必要があります。具体的にはDateを\"/\"を基準に別ければいいです。そこで登場するのはseparate()関数であり、使い方は以下の通りです。 # separate()の使い方 データ名 %&gt;% separate(cols = 分割する変数名 into = 分割後の変数名, sep = &quot;分割する基準&quot;) colsにはDateを指定し、intoは新しく出来る列名を指定します。今回はDateが3列に分割されるので、長さ3のcharacter型ベクトルを指定します。ここではYear、Month、Dayとしましょう。最後のsep引数は分割する基準となる文字を指定します。df4のDateは\"2020/06/29\"のように年月日が\"/\"で分けられているため、\"/\"を指定します。実際にやってみましょう。 df4_S &lt;- df4_S %&gt;% separate(col = Date, into = c(&quot;Year&quot;, &quot;Month&quot;, &quot;Day&quot;), sep = &quot;/&quot;) df4_S ## # A tibble: 344 x 7 ## ID Year Month Day Week Country Confirmed ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 2020 1 16 木 Japan 1 ## 2 1 2020 1 16 木 Korea NA ## 3 2 2020 1 17 金 Japan 0 ## 4 2 2020 1 17 金 Korea NA ## 5 3 2020 1 18 土 Japan 0 ## 6 3 2020 1 18 土 Korea NA ## 7 4 2020 1 19 日 Japan 0 ## 8 4 2020 1 19 日 Korea NA ## 9 5 2020 1 20 月 Japan 0 ## 10 5 2020 1 20 月 Korea 1 ## # … with 334 more rows 新しく出来た変数は元の変数があった場所になります。ここまで来たら月ごとに新規感染者の記述統計量は計算できます。曜日ごとに行ったコードのWeekをMonthに変えるだけです。また、Monthは数字のみで構成されたcharacter型であるため、このままでも問題なくソートされます。したがって、別途factor化の必要もありません（むろん、してもいいですし、むしろ推奨されます）。 df4_S_Summary2 &lt;- df4_S %&gt;% group_by(Country, Month) %&gt;% summarise(Sum = sum(Confirmed, na.rm = TRUE), Mean = mean(Confirmed, na.rm = TRUE), SD = sd(Confirmed, na.rm = TRUE), .groups = &quot;drop&quot;) df4_S_Summary2 ## # A tibble: 14 x 5 ## Country Month Sum Mean SD ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Japan 1 17 1.06 1.34 ## 2 Japan 2 213 7.34 7.81 ## 3 Japan 3 1723 55.6 42.4 ## 4 Japan 4 12135 404. 146. ## 5 Japan 5 2763 89.1 73.0 ## 6 Japan 6 1742 58.1 23.0 ## 7 Japan 7 929 186. 45.1 ## 8 Korea 1 11 0.917 1.44 ## 9 Korea 2 3139 108. 203. ## 10 Korea 3 6737 217. 222. ## 11 Korea 4 887 29.6 26.6 ## 12 Korea 5 729 23.5 16.2 ## 13 Korea 6 1348 44.9 10.4 ## 14 Korea 7 289 57.8 6.61 df4_S_Summary2 %&gt;% pivot_wider(names_from = Country, values_from = Sum:SD) %&gt;% relocate(Month, ends_with(&quot;Japan&quot;), ends_with(&quot;Korea&quot;)) ## # A tibble: 7 x 7 ## Month Sum_Japan Mean_Japan SD_Japan Sum_Korea Mean_Korea SD_Korea ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 17 1.06 1.34 11 0.917 1.44 ## 2 2 213 7.34 7.81 3139 108. 203. ## 3 3 1723 55.6 42.4 6737 217. 222. ## 4 4 12135 404. 146. 887 29.6 26.6 ## 5 5 2763 89.1 73.0 729 23.5 16.2 ## 6 6 1742 58.1 23.0 1348 44.9 10.4 ## 7 7 929 186. 45.1 289 57.8 6.61 平均値から見ると、日本は7都道府県を対象に緊急事態宣言が行われた4月がピークで緩やかに減少していますが、7月になって上がり気味です。韓国はカルト宗教団体におけるクラスターが発生した3月がピークで、6月からまた上がり気味ですね。傾向としては韓国が日本に1ヶ月先行しているように見えます。 それではseparate()関数の他の引数についても簡単に紹介します。まず、sep引数はnumeric型でも可能です。この場合、文字列内の位置を基準に分割されます。年月日が20200629のように保存されている場合は、何らかの基準となる文字がありません。この場合、sep = c(4, 6)にすると、「\"20200629\"の4文字目と5文字目の間で分割、6文字目と7文字目の間で分割」となります。また、sep = c(-4, -2)のように負の値も指定可能であり、この場合は右からの位置順で分割します。 また、separate()後は元の変数がなくなりますが、remove = FALSEの場合、元の変数 (ここではDate)が残ります。他にもconvert引数もあります。convert = TRUEの場合、適切なデータ型へ変換してくれます。デフォルト値はFALSEであり、この場合、character型として分割されます。先ほどの例だとYearもMonthもDayも現在はcharacter型です。separate()内でconvert = TRUEを追加すると、分割後のYear、Month、Dayはnumeric型として保存されます。 separate()の詳細は?separateまたは、レファレンスページを参照してください。 参考資料 "],
["visualization.html", "14. 可視化 14.1 可視化のためのパッケージ 14.2 良いグラフとは 14.3 グラフィックの文法 14.4 実習用データ 14.5 棒グラフ 14.6 ヒストグラム 14.7 散布図 14.8 図のカスタマイズ 14.9 練習問題", " 14. 可視化 14.1 可視化のためのパッケージ Rのbase graphic lattice ggplot2 14.2 良いグラフとは BBC Visual and Data Journalism cookbook for R graphics 14.3 グラフィックの文法 14.3.1 ggplot2のイメージ ggplot(data = df) + geom_line(aes(x = Year, y = P, color = Company_Type1), size = 1) + geom_point(aes(x = Year, y = P, color = Company_Type1), size = 3, pch = 21, fill = &quot;white&quot;) + labs(x = &quot;年度&quot;, y = &quot;平均利用者数 (人/日)&quot;, color = &quot;事業者区分&quot;) + scale_x_continuous(breaks = 2011:2017, labels = 2011:2017) + theme_minimal(base_family = &quot;HiraKakuProN-W3&quot;) # 第1層: キャンバスを用意し、使用するデータはdf ggplot(data = df) # 第2層: X軸はYear、Y軸はPにし、Company_type1ごとに色分けした折れ線グラフを作成し、線の太さは1とする。 ggplot(data = df) + geom_line(aes(x = Year, y = P, color = Company_Type1), size = 1) # 第3層: X軸はYear、Y軸はPにし、Company_type1ごとに色分けした散布図を作成する。 # 点の大きさは3、点のタイプは21 (外線付き)、点の中身の色は白よする ggplot(data = df) + geom_line(aes(x = Year, y = P, color = Company_Type1), size = 1) + geom_point(aes(x = Year, y = P, color = Company_Type1), size = 3, pch = 21, fill = &quot;white&quot;) # 第4層: X軸、Y軸のラベルをそれぞれ「年度」、「平均利用者数 (人/日)」に # 凡例のcolorのラベルは「事業者区分」にする ggplot(data = df) + geom_line(aes(x = Year, y = P, color = Company_Type1), size = 1) + geom_point(aes(x = Year, y = P, color = Company_Type1), size = 3, pch = 21, fill = &quot;white&quot;) + labs(x = &quot;年度&quot;, y = &quot;平均利用者数 (人/日)&quot;, color = &quot;事業者区分&quot;) # 第5層: 連続変数で構成されたX軸を調整する # 目盛りは2011, 2012, ..., 2017とし、ラベルも2011, 2012, ..., 2017に ggplot(data = df) + geom_line(aes(x = Year, y = P, color = Company_Type1), size = 1) + geom_point(aes(x = Year, y = P, color = Company_Type1), size = 3, pch = 21, fill = &quot;white&quot;) + labs(x = &quot;年度&quot;, y = &quot;平均利用者数 (人/日)&quot;, color = &quot;事業者区分&quot;) + scale_x_continuous(breaks = 2011:2017, labels = 2011:2017) # 第6層: テーマをminimalに指定し、フォント群はHiraKakuProN-W3に ggplot(data = df) + geom_line(aes(x = Year, y = P, color = Company_Type1), size = 1) + geom_point(aes(x = Year, y = P, color = Company_Type1), size = 3, pch = 21, fill = &quot;white&quot;) + labs(x = &quot;年度&quot;, y = &quot;平均利用者数 (人/日)&quot;, color = &quot;事業者区分&quot;) + scale_x_continuous(breaks = 2011:2017, labels = 2011:2017) + theme_minimal(base_family = &quot;HiraKakuProN-W3&quot;) 図 14.1: ggplot2の図が出来上がるまで (全体像) 14.3.2 グラフィックの構成要素 ggplot2におけるプロット (plot)は「データ + 幾何オブジェクト + 座標系」で構成されます。 ここでいうデータは主にデータフレームまたはtibbleです。これは主にggplot()関数の第一引数と指定するか、パイプで渡すのが一般的です。ただし、ggplot2で作図するためには、データを予め整然データに整形する必要があります。 幾何オブジェクト (geometry object)とは簡単に言うと図の種類です。散布図、折れ線グラフ、棒グラフ、ヒストグラムなど、ggplot2は様々なタイプの幾何オブジェクトを提供しており、ユーザー自作の幾何オブジェクトもRパッケージとして多く公開されています。幾何オブジェクトは関数の形で提供されており、geom_で始まるといった共通点があります。散布図はgeom_point()、折れ線グラフはgeom_line()のような関数を使います。 この幾何オブジェクトに線や点、棒などを表示する際には、どの変数が横軸で、どの変数が縦軸かを明記する必要があります。また、変数によって点や線の色が変わったりする場合も、どの変数によって変わるかを明記します。これを マッピング (mapping)と呼びます。また、必要に応じて位置 (position)と統計量 (stat)を明記する必要がありますが、これは指定しなくてもとりあえず何らかの図は出力されます。 最後に座標系 (coordinate system)は幾何オブジェクトが表示される空間の特徴を定義します。最も重要な特徴は横軸と縦軸の下限と上限です。または、空間を回転することなどもできます。 ggplot2の図は以上の3つ要素を重ねることで出来ます。 図 14.2: ggplot2の構造の例 ただし、この中で座標系は適切だと判断される座標系に設定してくれるため、ユーザーが必ず指定すべきものはデータと幾何オブジェクトのみです。また、幾何オブジェクトはマッピングを含んでおり、これも必ず指定する必要があります。したがって、ggplot2で作図するための最小限のコードは以下のようになります。 # ggplot2におけるプロットの基本形 # データはggplotの第一引数と使う場合が多いため、「data =」は省略可能 # マッピングは主に幾何オブジェクトの第一引数として使うため、「mapping =」は省略可能 ggplot(data = データ名) + 幾何オブジェクト関数(mapping = aes(マッピング)) # パイプを使う場合 データ名 %&gt;% ggplot() + 幾何オブジェクト関数(mapping = aes(マッピング)) 注意すべき点はggplot2においてレイヤーを重ねる際は%&gt;%でなく、+を使う点です。パイプ演算子は左側の結果を右に渡す意味を持ちますが、ggplot2はデータを渡すよりも、レイヤーを足していくイメージですから、+を使います。 以下はggplot2の必須要素であるデータと幾何オブジェクト、マッピングなどについて解説し、続いて図は見栄を調整するための関数群を紹介します。 14.3.2.1 データ 作図のためにはデータはなくてはなりません。データはdata.frmae型、またはtibble型であり、一般的にはggplot()関数の第一引数として指定します。例えば、ggplot(data = データ名)のように書いてもいいですし、data =は省略して、ggplot(データ名)でも構いません。 データを指定するもう一つの方法はパイプ演算子を使うことです。この場合、データ名 %&gt;% ggplot()のように書きます。書く手間はほぼ同じですが、dplyrやtidyrなどでデータを加工し、それをオブジェクトとして保存せずにすぐ作図に使う場合は便利です。 実際、使う機会は少ないですが、1つのグラフに複数のデータを使う場合もあります。ggplot2は複数のデータにも対応していますが、とりあえずメインとなるデータをggplot()に指定し、追加的に必要なデータは今度説明する幾何オブジェクト関数内で指定します。この方法については適宜必要に応じて説明します。 14.3.2.2 幾何オブジェクト しかし、データを指定しただけで図が出来上がるわけではありません。指定したデータを使ってどのような図を作るかも指定する必要があります。この図のタイプが幾何オブジェクト (geometry object)であり、geom_*()関数で表記します。たとえば、散布図を作る場合、 データ名 %&gt;% ggplot() + geom_point() のように指定します。以上のコードは「あるデータを使って (データ名 %&gt;%)、キャンバスを用意し (ggplot() +)、散布図を作成する (geom_point())。」と読むことが出来ます。 また、この幾何オブジェクトは重ねることも可能です。よく見る例としては、散布図の上に回帰曲線 (geom_smooth())や折れ線グラフ (geom_line())を重ねたものであり、これらの幾何オブジェクトは+で繋ぐことが可能です。 ggplot2が提供する幾何オブジェクト関数は散布図だけでなく、棒グラフ (geom_bar())、ヒストグラム (geom_histogram())、折れ線グラフ (geom_line())、ヒートマップ (geom_tile())など、データ分析の場面で使われるほとんどの種類が含まれています。他にもユーザーが作成した幾何オブジェクトもパッケージとして多く公開されています（たとえば、非巡回有向グラフ作成のためのggdag、ネットワークの可視化のためのggnetworkなど）。 14.3.2.3 マッピング どのようなデータを使って、どのような図を作るかを指定した後は、変数を指定します。たとえば、散布図の場合、各点の横軸と縦軸における位置情報が必要です。ヒストグラムならヒストグラムに必要な変数を指定する必要があります。このようにプロット上に出力されるデータの具体的な在り方を指定するのをマッピング (mapping)と呼びます。 マッピングは幾何オブジェクト関数内で行います。具体的にはgeom_*()内にmapping = aes(マッピング)で指定します。aes()も関数の一種です。散布図ならgeom_point(mapping = aes(x = X軸の変数, y = Y軸の変数))です。ヒストグラムなら横軸のみを指定すればいいのでgeom_histogram(mapping = aes(x = 変数名))で十分です。マッピングは一般的にはgeom_*()の第一引数として渡しますが、この場合、mapping =は省略可能です。 マッピングに必要な変数、つまりaes()に必要な引数は幾何オブジェクトによって異なります。散布図や折れ線グラフならX軸とY軸の情報が必須であるため、2つ必要です (xとy)。ヒストグラムは連続変数の度数分布表を自動的に作成してからグラフが作られるから1つが必要です (x)。また、等高線図の場合、高さの情報も必要なので3つの変数が必要です (xとy、z)。これらの引数は必ず指定する必要があります。 以上の引数に加え、追加のマッピング情報を入れることも可能です。たとえば、鉄道事業者ごとの平均利用者数を時系列で示した最初の例を考えてみましょう。これは折れ線グラフですので、mapping = aes(x = 年度, y = 利用者数)までは必須です。しかし、この図にはもう一つの情報がありますね。それは事業者のタイプです。事業者のタイプごとに線の色を変えたい場合は、aes()内にcolor = 事業者のタイプを、線の種類を変えたい場合は、linetype = 事業者のタイプのように引数を追加します。こうすると2次元のプロットに3次元の情報 (年度、利用者数、事業者タイプ)を乗せることが可能です。むろん、4次元以上にすることも可能です。たとえば、地域ごとに異なる色を、事業者タイプごとに異なる線のタイプを指定する場合は、mapping = aes(x = 年度, y = 利用者数, color = 地域, linetype = 事業者のタイプ)のように指定します。colorやlinetype以外にも大きさ (size)、透明度 (alpha)、点のタイプ (shape)、面の色 (fill)などを指定することができます。 先ほどマッピング引数は幾何オブジェクト関数内で指定すると言いましたが、実はggplot()内に入れ、geom_*()内では省略することも可能です。幾何オブジェクトが1つのみならどっちでも問題ありません。しかし、幾何オブジェクトが2つ以上の場合は注意が必要です。全ての幾何オブジェクトがマッピングを共有する場合はggplot()の方が書く手間が省きます。しかし、幾何オブジェクトがマッピングを共有しない場合は幾何オブジェクト関数内に別途指定する必要があります。あるいは、共有するところだけ、ggplot()に書いて、共有しない部分だけ幾何オブジェクトで指定することも可能です。 14.3.2.4 その他 以上のことさえ覚えれば、とりあえず図は作れます。最後に、必須要素ではありませんが、幾何オブジェクトに使う引数について説明します。先ほど説明しましたcolorやlinetype、sizeなどはマッピングの情報として使うことも可能ですが、aes()の外側に置くことも可能です。しかし、その挙動はかなり異なります。colorがaes()の外側にある場合は、幾何オブジェクトの全要素に対して反映される。 たとえば、横軸が「ゲームのプレイ時間」、縦軸が「身長」の散布図を作成しるとします。ここでcolor引数を追加しますが、まずはaes()の外側に入れます。 # 例1: 全ての点の色が赤になる データ %&gt;% ggplot() + geom_point(aes(x = ゲームのプレイ時間, y = 身長), color = &quot;red&quot;) ここで注目する点は 散布図におけるすべての点の色がcolorで指定した色 (\"red\" = 赤)に変更された点 colorの引数は変数名でなく、具体的な色を指定する点 以上の2点です。aes()の内側にcolorを指定する場合は、以下のように変数名を指定します。たとえば、性別ごとに異なる色を付けるとしたら、 # 例2: 性別ごとに点の色が変わる データ %&gt;% ggplot() + geom_point(aes(x = ゲームのプレイ時間, y = 身長, color = 性別)) 以上のように書きます。aes()の内部はマッピングの情報が含まれています。言い換えると、aes()の中はある変数がグラフ上においてどのような役割を果たしているかを明記するところです。2つ目の例では性別という変数が色分けをする役割を果たすため、aes()の内側に入ります。一方、1つ目の例では色分けが行われておりません。 ここまでがggplot2の入門の入門の入門です。韓国旅行に例えると、やっと仁川国際空港の入国審査を通ったところです。The R Graph Galleryを見ると、主にggplot2で作成知れた綺麗な図がいっぱいあります。しかし、ここまで勉強してきたものだけでは、このような図を作るのは難しいです。そもそもサンプルコードを見ても理解するのが難しいかも知れません。以下では本格的なggplot2の使い方を解説します。到達目標は(1)「よく使う」グラフが作成できること、そして(2)The R Graph Galleryのサンプルコードを見て自分で真似できるようになることです。 14.4 実習用データ 実習の前に本章で使用するデータとggplot2パッケージが含まれているtidyverseを読み込みます。 library(tidyverse) df &lt;- read_csv(&quot;Data/Stations.csv&quot;) df ## # A tibble: 9,150 x 23 ## ID Station_Name Pref Zipcode Address Longitude Latitude Station_Status Line_ID ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.11e6 函館 1 040-00… 北海道函館市… 141. 41.8 0 11101 ## 2 1.11e6 五稜郭 1 041-08… 函館市亀田本… 141. 41.8 0 11101 ## 3 1.11e6 桔梗 1 041-08… 北海道函館市… 141. 41.8 0 11101 ## 4 1.11e6 大中山 1 041-11… 亀田郡七飯町… 141. 41.9 0 11101 ## 5 1.11e6 七飯 1 041-11… 亀田郡七飯町… 141. 41.9 0 11101 ## 6 1.11e6 新函館北斗 1 041-12… 北海道北斗市… 141. 41.9 0 11101 ## 7 1.11e6 仁山 1 041-11… 亀田郡七飯町… 141. 41.9 0 11101 ## 8 1.11e6 大沼 1 041-13… 北海道亀田郡… 141. 42.0 0 11101 ## 9 1.11e6 大沼公園 1 041-13… 北海道亀田郡… 141. 42.0 0 11101 ## 10 1.11e6 赤井川 1 049-21… 茅部郡森町字… 141. 42.0 0 11101 ## # … with 9,140 more rows, and 14 more variables: Line_Name &lt;chr&gt;, Line_Status &lt;dbl&gt;, ## # Company_ID &lt;dbl&gt;, Company_Name &lt;chr&gt;, Company_Type1 &lt;dbl&gt;, Company_Type2 &lt;dbl&gt;, ## # Company_Status &lt;dbl&gt;, P2011 &lt;dbl&gt;, P2012 &lt;dbl&gt;, P2013 &lt;dbl&gt;, P2014 &lt;dbl&gt;, ## # P2015 &lt;dbl&gt;, P2016 &lt;dbl&gt;, P2017 &lt;dbl&gt; 全国の9150鉄道駅のデータを収集したものです。データには駅の地理的情報や、路線、事業者の情報と平均利用者数 (人/日)が含まれています。利用者数の情報は国土交通省の国土数値情報「駅別乗降客数データ」から、その他の情報は「駅データ.jp」から入手したものです。両データの結合は緯度と経度を基準にマッチングし、駅名が一致するケースのみ残したものです。したがって、不正確にマッチングされたケースが存在する可能性があります（とりわけ乗換駅など）。この実習用データを使って、何らかの意味のある分析はできません。あくまでも実習用データとしてお使いください。 各変数の詳細は以下の通りです。 変数名 説明 詳細 ID 駅ID Station_Name 駅名 Pref 所在地 都道府県 (ID) Zipcode 所在地 郵便番号 Address 所在地 住所 Longitude 経度 Latitude 緯度 Station_Status 駅の状態 0:運用中 / 1:運用前 / 2:廃止 Line_ID 路線ID Line_Name 路線名 Line_Status 路線の状態 0:運用中 / 1:運用前 / 2:廃止 Company_ID 事業者ID Company_Name 事業者名 Company_Type1 事業者タイプ1 0:その他 / 1:JR / 2:大手私鉄 / 3:準大手私鉄 Company_Type2 事業者タイプ2 1:JR / 2:公営 / 3:民営 / 4:第三セクター Company_Status 事業者の状態 0:運用中 / 1:運用前 / 2:廃止 P2011 2011年度利用者数 単位は(人/日) P2012 2012年度利用者数 単位は(人/日) P2013 2013年度利用者数 単位は(人/日) P2014 2014年度利用者数 単位は(人/日) P2015 2015年度利用者数 単位は(人/日) P2016 2016年度利用者数 単位は(人/日) P2017 2017年度利用者数 単位は(人/日) 14.5 棒グラフ 棒グラフについては以下の2つのタイプについて説明します。 ある変数の数の表す棒グラフ 各グループの統計量を表す棒グラフ 前者は「データ内に北海道のケースはいくつあるか、東京の行はいくつあるか」のようなものであり、後者は「都道府県ごとの利用者数の平均値はいくつか」を出力するグラフです。 ケース数のグラフ Pref_df &lt;- read_csv(&quot;Data/Vote.csv&quot;) ## Parsed with column specification: ## cols( ## ID = col_double(), ## Pref = col_character(), ## Zaisei = col_double(), ## Over65 = col_double(), ## Under30 = col_double(), ## LDP = col_double(), ## DPJ = col_double(), ## Komei = col_double(), ## Ishin = col_double(), ## JCP = col_double(), ## SDP = col_double() ## ) df &lt;- df %&gt;% mutate(Pref = factor(Pref, levels = 1:47, labels = Pref_df$Pref)) df %&gt;% ggplot() + geom_bar(aes(x = Pref)) df %&gt;% ggplot() + geom_bar(aes(x = Pref)) + theme_bw(base_family = &quot;HiraKakuProN-W3&quot;) df %&gt;% ggplot() + geom_bar(aes(x = Pref)) + theme_bw(base_family = &quot;HiraKakuProN-W3&quot;) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) df %&gt;% ggplot() + geom_bar(aes(x = Pref)) + labs(x = &quot;都道府県&quot;, y = &quot;ケース数&quot;) + theme_minimal(base_family = &quot;HiraKakuProN-W3&quot;) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) 記述統計量のグラフ Bar_df1 &lt;- df %&gt;% group_by(Pref) %&gt;% summarise(Passenger = mean(P2017, na.rm = TRUE), .groups = &quot;drop&quot;) Bar_df1 %&gt;% ggplot() + geom_bar(aes(x = Pref, y = Passenger), stat = &quot;identity&quot;) + labs(x = &quot;都道府県&quot;, y = &quot;平均利用者数 (人/日)&quot;) + theme_minimal(base_family = &quot;HiraKakuProN-W3&quot;) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) 14.6 ヒストグラム 14.7 散布図 14.8 図のカスタマイズ 14.9 練習問題 dfを用い、以下のような図を作成せよ。 "],
["datahandling3.html", "15. データハンドリング[応用編]", " 15. データハンドリング[応用編] ここでは整形されていない状態のデータを "],
["string.html", "16. 文字列の処理", " 16. 文字列の処理 "],
["scraping.html", "17. スクレイピング", " 17. スクレイピング "],
["rmarkdown.html", "18. R Markdown 18.1 R Markdown 18.2 Markdown文法の基本 18.3 チャンクのオプション 18.4 ヘッダーのオプション 18.5 日本語が含まれているPDFの出力", " 18. R Markdown 18.1 R Markdown 18.2 Markdown文法の基本 18.3 チャンクのオプション 18.4 ヘッダーのオプション 18.5 日本語が含まれているPDFの出力 本文中に日本語が含まれている場合、PDF出力の祭、エラーが表示されるだろう。日本語が含まれたPDFの場合、自分のパソコンに日本語TeX環境を整える必要がある。 もし、自分のPCで既に日本語TeX環境が整っている場合、R Markdownのヘッダーを以下のように修正する。 --- title: &quot;R楽しいぞ&quot; subtitle: &quot;みんなでやろうぜ&quot; author: &quot;矢内勇生 a.k.a Rの神&quot; date: &quot;2020年4月10日&quot; output: pdf_document: highlight: &quot;default&quot; number_sections: yes toc: yes latex_engine: xelatex mainfont: ipaexg.ttf --- コンパイルしたら以下のようなPDFファイルが生成される。 ヘッダーの主な修正はoutput:オプションである。それでは一つずつ解説する。 pdf_document:: PDF出力 highlight:: コードのハイライトテーマを設定する。 使用可能なテーマはdefault、tango、pygments、kate、monochrome、espresso、zenburn、haddock、breezedarkの9種類である。それぞれの例は後で紹介する。 number_sections:: 章・節の前に数字を付ける場合、yes toc: 目次を付ける場合、yes latex_engine:: ここはxelatexのままにする。 mainfont:: ここもipaexg.ttfのままにする。 highlightテーマについてであるが、rmarkdown 2.1の場合、使用可能なテーマは以下の9種類66である。 default tango pygments kate monochrome espresso zenburn haddock breezedark プリンターのインク、トナーカートリッジが心配ならespresso、zenburn、breezedarkは避けた方が良いだろう。 defaultとtangoは同じである。↩︎ "],
["solution.html", "19. 演習問題の回答 19.1 基本的な操作 19.2 データの構造 19.3 Rプログラミングの基礎", " 19. 演習問題の回答 結果は載せておりません。自分で結果を確認しましょう。 19.1 基本的な操作 (myVec1 &lt;- c(3, 9, 10, 8, 3, 5, 8)) # 問1 myVec1[c(2, 4, 6)] # 問2 sum(myVec1) # 問3 sum(myVec1[(myVec1 %% 2 == 1)]) # 問4 (myVec2 &lt;- c(1, 2, 3, 4, 3, 2, 1)) # 問5 (myVec3 &lt;- myVec1 + myVec2) # 問6 myVec3[myVec3 &lt; 10] # 問7 myVec4 &lt;- 1:100 # 問8 sum(myVec4^2) # 問9 sum((myVec4[myVec4 %% 2 == 1])^2) # 問10 19.2 データの構造 19.2.1 ベクトル # 問1 1から10までの公差1の等差数列を作成し、myVec1と名付けよ。 myVec1 &lt;- 1:10 # 問2 myVec1の長さを求めよ。 length(myVec1) # 問3 myVec1から偶数のみを抽出せよ myVec1[myVec1 %% 2 == 0] # 問4 myVec1をmyVec2という名でコピーし、myVec2の偶数を全て0に置換せよ。 myVec2 &lt;- myVec1 myVec2[myVec2 %% 2 == 0] &lt;- 0 # 問5 myVec1の全要素から1を引し、myVec3と名付けよ。 myVec3 &lt;- myVec1 - 1 # 問6 myVec1の奇数番目の要素には1を、偶数番目の要素には2を足し、myVec4と名付けよ。 myVec4 &lt;- myVec1 + c(1, 2) # 問7 myVec4からmyVec1を引け。 myVec4 - myVec1 19.2.2 行列 問1 以下のような2つの行列を作成せよ。 \\[ \\text{myMat1} = \\left[ \\begin{matrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\end{matrix} \\right], \\text{myMat2} = \\left[ \\begin{matrix} 1 &amp; 4 &amp; 7 \\\\ 2 &amp; 5 &amp; 8 \\\\ 3 &amp; 6 &amp; 9 \\end{matrix} \\right] \\] # myMat1: byrow = を指定する場合 myMat1 &lt;- matrix(1:6, nrow = 2, byrow = TRUE) # myMat1: byrow = を指定しない場合 myMat1 &lt;- matrix(c(1, 4, 2, 5, 3, 6), nrow = 2) # myMat2: byrow = を指定する場合 myMat2 &lt;- matrix(c(1, 4, 7, 2, 5, 8, 3, 6, 9), nrow = 3, byrow = TRUE) # myMat2: byrow = を指定しない場合 myMat2 &lt;- matrix(1:9, nrow = 3) 問2 myMat1とmyMat2の掛け算を行い、myMat3と名付けよ。 myMat3 &lt;- myMat1 %*% myMat2 問3 連立方程式の解を求めよ。 # 問3-1 myMat4 &lt;- matrix(c(3, -1, 2, 1, 2, 3, 2, -1, -1), nrow = 3, byrow = TRUE) myMat5 &lt;- matrix(c(12, 11, 2), nrow = 3) # 問3-2 solve(myMat4) # 問3-3 myMat6 &lt;- solve(myMat4) %*% myMat5 # 問3-4 myMat4 %*% myMat6 19.2.3 データフレーム # 問1. 以下のようなデータフレームを作成し、myDF1と名付けよ。 myDF1 &lt;- data.frame( ID = 1:10, Name = c(&quot;Australia&quot;, &quot;China&quot;, &quot;Iran&quot;, &quot;Iraq&quot;, &quot;Japan&quot;, &quot;Qatar&quot;, &quot;Saudi Arabia&quot;, &quot;South Korea&quot;, &quot;Syria&quot;, &quot;UAE&quot;), Rank = c(42, 76, 33, 70, 28, 55, 67, 40, 79, 71), Socre = c(1457, 1323, 1489, 1344, 1500, 1396, 1351, 1464, 1314, 1334) ) # 問2. myDF1からName列を抽出せよ。 myDF1$Name # 問3. myDF1のName列から3番目の要素を抽出せよ。 myDF1$Name[3] # 問4. myDF1の3行目を抽出せよ。 myDF1[3, ] # 問5. FIFA_Women.csvをtibble型として読み込み、myTbl1と名付けよ。 myTbl1 &lt;- read_csv(&quot;Data/FIFA_Women.csv&quot;) # 問6. myTbl1のRank列を抽出し、それぞれの要素が20より小さいかを判定せよ。 myTbl1$Rank &lt; 20 # 問7. Rankが20より小さい国名を抽出せよ。 myTbl1$Team[myTbl1$Rank &lt; 20] # 問8. myTbl1からランキングが20位以内の行を抽出せよ。 myTbl1[myTbl1$Rank &lt; 20, ] 19.3 Rプログラミングの基礎 問1 while()を使う場合 Trial &lt;- 1 Total &lt;- 0 while (Total != 15) { Dice &lt;- sample(1:6, 3, replace = TRUE) Total &lt;- sum(Dice) print(paste0(Trial, &quot;目のサイコロ投げの結果: &quot;, Dice[1], &quot;, &quot;, Dice[2], &quot;, &quot;, Dice[3], &quot; (合計: &quot;, Total, &quot;)&quot;)) Trial &lt;- Trial + 1 } for()を使う場合 for (Trial in 1:10000) { Dice &lt;- sample(1:6, 3, replace = TRUE) Total &lt;- sum(Dice) print(paste0(Trial, &quot;目のサイコロ投げの結果: &quot;, Dice[1], &quot;, &quot;, Dice[2], &quot;, &quot;, Dice[3], &quot; (合計: &quot;, Total, &quot;)&quot;)) if (Total == 15) { break } } 問2 # 問2-1 Cause &lt;- c(&quot;喫煙&quot;, &quot;飲酒&quot;, &quot;食べすぎ&quot;, &quot;寝不足&quot;, &quot;ストレス&quot;) for (i in Cause) { Text &lt;- sprintf(&quot;肥満の原因は%sでしょう。&quot;, i) print(Text) } # 問2-2 Effect &lt;- c(&quot;肥満&quot;, &quot;ハゲ&quot;, &quot;不人気&quot;, &quot;金欠&quot;) for (i in Effect) { for (j in Cause) { Text &lt;- sprintf(&quot;%sの原因は%sでしょう。&quot;, i, j) print(Text) } } # 問2-3 Solution &lt;- c(&quot;この薬を飲めば&quot;, &quot;一日一麺すれば&quot;, &quot;Songに100万円振り込めば&quot;) for (i in Effect) { for (j in Cause) { for (k in Solution) { Text &lt;- sprintf(&quot;%sの原因は%sですが、%s改善されるでしょう。&quot;, i, j, k) print(Text) } } } 問3 Data &lt;- c(5, 3) if (Data[1] &gt; Data[2]) { Temp &lt;- Data[1] Data[1] &lt;- Data[2] Data[2] &lt;- Temp } Data 問4 Data &lt;- c(5, 2, 4, 1) for (i in (length(Data)-1):1) { for (j in 1:i) { if (Data[j] &gt; Data[j+1]) { Temp &lt;- Data[j] Data[j] &lt;- Data[j + 1] Data[j+1] &lt;- Temp } } } Data 問5 mySort &lt;- function(x) { for (i in (length(x)-1):1) { for (j in 1:i) { if (x[j] &gt; x[j+1]) { Temp &lt;- x[j] x[j] &lt;- x[j + 1] x[j+1] &lt;- Temp } } } x } # Bubble Sortの例 Data &lt;- c(28, 92, 29, 84, 29, 27, 19, 23, 32, 30) mySort(Data) 問6 DQ_Attack2 &lt;- function(attack, defence, hp, enemy) { DefaultDamage &lt;- (attack / 2) - (defence / 4) DefaultDamage &lt;- ifelse(DefaultDamage &lt; 0, 0, DefaultDamage) DamageWidth &lt;- floor(DefaultDamage / 16) + 1 DamageMin &lt;- DefaultDamage - DamageWidth DamageMin &lt;- ifelse(DamageMin &lt; 0, 0, DamageMin) DamageMax &lt;- DefaultDamage + DamageWidth CurrentHP &lt;- hp while (CurrentHP &gt; 0) { Kaisin &lt;- runif(n = 1, min = 0, max = 1) if (Kaisin &lt;= (1/32)) { Damage &lt;- runif(n = 1, min = attack * 0.95, max = attack * 1.05) } else { Damage &lt;- runif(n = 1, min = DamageMin, max = DamageMax) } Damage &lt;- round(Damage, 0) CurrentHP &lt;- CurrentHP - Damage if (Kaisin &lt;= (1/32)) { print(paste0(&quot;かいしんのいちげき!&quot;, enemy, &quot;に&quot;, Damage, &quot;のダメージ!!&quot;)) } else{ print(paste0(enemy, &quot;に&quot;, Damage, &quot;のダメージ!!&quot;)) } } paste0(enemy, &quot;をやっつけた！&quot;) } 問7 mySample &lt;- function(x, n, seed) { # 以下の条件が満たされない場合、エラーメッセージを出力し、関数を停止 stopifnot( # length(n) == 1が満たされない場合 &quot;a length of n must be 1.&quot; = (length(n) == 1), # length(seed) == 1が満たされない場合 &quot;a length of seed must be 1.&quot; = (length(seed) == 1), # is.numeric(seed) == TRUEが満たされない場合 &quot;seed must be integer of double.&quot; = is.numeric(seed), # ceiling(n) == nが満たされない場合 &quot;n must be interger.&quot; = (ceiling(n) == n) ) # LCG()を用いてn個の乱数を生成し、xの長さだけ倍にする index &lt;- LCG(n = n, seed = seed) * length(x) # 得られた疑似乱数を切り上げる index &lt;- ceiling(index) # ベクトルxのindex番目要素を抽出し、Resultに格納 Result &lt;- x[index] Result } "],
["sessioninfo.html", "20. 本書の執筆環境", " 20. 本書の執筆環境 ## R version 4.0.0 (2020-04-24) ## Platform: x86_64-apple-darwin17.0 (64-bit) ## Running under: macOS Catalina 10.15.5 ## ## Matrix products: default ## BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.0/Resources/lib/libRlapack.dylib ## ## locale: ## [1] ja_JP.UTF-8/ja_JP.UTF-8/ja_JP.UTF-8/C/ja_JP.UTF-8/ja_JP.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] DT_0.14 kableExtra_1.1.0 knitr_1.29 magrittr_1.5 haven_2.3.1 ## [6] xlsx_0.6.3 forcats_0.5.0 stringr_1.4.0 dplyr_1.0.0 purrr_0.3.4 ## [11] readr_1.3.1 tidyr_1.1.0 tibble_3.0.1 tidyverse_1.3.0 ggplot2_3.3.2 ## [16] cowplot_1.0.0 bookdown_0.20 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.4.6 lubridate_1.7.9 lattice_0.20-41 xlsxjars_0.6.1 ## [5] assertthat_0.2.1 digest_0.6.25 utf8_1.1.4 R6_2.4.1 ## [9] cellranger_1.1.0 backports_1.1.8 reprex_0.3.0 evaluate_0.14 ## [13] httr_1.4.1 highr_0.8 pillar_1.4.4 rlang_0.4.6 ## [17] readxl_1.3.1 rstudioapi_0.11 blob_1.2.1 magick_2.4.0 ## [21] rmarkdown_2.3 labeling_0.3 webshot_0.5.2 htmlwidgets_1.5.1 ## [25] munsell_0.5.0 broom_0.5.6 compiler_4.0.0 modelr_0.1.8 ## [29] xfun_0.15 pkgconfig_2.0.3 htmltools_0.5.0 tidyselect_1.1.0 ## [33] fansi_0.4.1 viridisLite_0.3.0 crayon_1.3.4 dbplyr_1.4.4 ## [37] withr_2.2.0 grid_4.0.0 nlme_3.1-148 jsonlite_1.7.0 ## [41] gtable_0.3.0 lifecycle_0.2.0 DBI_1.1.0 scales_1.1.1 ## [45] cli_2.0.2 stringi_1.4.6 farver_2.0.3 fs_1.4.2 ## [49] xml2_1.3.2 ellipsis_0.3.1 generics_0.0.2 vctrs_0.3.1 ## [53] tools_4.0.0 glue_1.4.1 crosstalk_1.1.0.1 hms_0.5.3 ## [57] yaml_2.2.1 colorspace_1.4-1 rvest_0.3.5 rJava_0.9-12 "],
["reference.html", "21. 参考資料", " 21. 参考資料 "]
]
