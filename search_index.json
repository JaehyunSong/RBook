[
["tidydata.html", "13. 整然データ構造 13.1 整然データ (tidy data)とは 13.2 Wide型からLong型へ 13.3 Long型からWide型へ 13.4 列の操作", " 13. 整然データ構造 本章ではグラフの作成に適した形へデータを整形することについて学習します。ただし、これはグラフに限られた話ではありません。作図に適したデータは分析にも適します。 13.1 整然データ (tidy data)とは 分析や作図に適したデータの形は整然データ、または簡潔データ (tidy data)と呼ばれます。整然データの概念はtidyverse世界の産みの親であるHadely Wickham先生が提唱した概念であり、詳細はHadley先生が2014年に発表した論文1を参照してください。 整然データは目指す到達点は非常に単純です。それは「データの構造 (structure)と意味 (semantic)を一致させる」ことです。そして、この「意味」を出来る限り小さい単位で分解します。 例えば、3人で構成されたあるクラス内の被験者が投薬の前後に測った数学成績があるとします。投薬前の成績は\"Control\"、投薬後の状況を\"Treatment\"とします。これをまとめたのが表13.1です。 表 13.1: Messy Dataの例 (1) Name Control Treatment Hadley 90 90 Song 80 25 Yanai 100 95 また、以上の表は転置も可能であり、以下のように表現することが可能です (表13.2)。 表 13.2: Messy Dataの例 (2) Treat Hadely Song Yanai Control 90 80 100 Treatment 90 25 95 2つのデータが持つ情報は全く同じです。これは「同じ意味を持つが、異なる構造を持つ」とも言えます。このような多様性が生じる意味は行と列のあり方が各値を説明するに十分ではないからです。異なるデータ構造として表現される余地があるということです。 たとえば、表13.1の場合、各列は以下のような3つの情報があります。 Name: 被験者名 Control: 投薬前の数学成績 Treatment: 投薬後の数学成績 このデータの問題は「投薬有無」と「数学成績」が2回登場したという点です。1は問題ありませんが、2と3の値は「投薬有無 \\(\\times\\) 数学成績」の組み合わせです。一つの変数に2つの情報が含まれていますね。これによって、投薬有無を行にしても列にしてもいいわけです。「ならばこっちの方が柔軟だしいいのでは?」と思う方もいるかも知れません。しかし、パソコンはこの曖昧さが嫌いです。なぜなら、人間のような思考ができないからです。データフレームは縦ベクトルの集合であるから、各列には一つの情報のみ格納する必要があります。たとえば、以下のように列を変更するとしましょう。 Name: 被験者名 Treat: 投薬有無 Math_Score: 数学成績 Treatは投薬前なら\"Control\"の値を、投薬後なら\"Treatment\"の値が入ります。Math_Socreには数学成績が入ります。これに則って表に直したのが表13.3です。 表 13.3: 整然データの例 Name Treat Math_Score Hadley Control 90 Hadley Treatment 90 Song Control 80 Song Treatment 25 Yanai Control 100 Yanai Treatment 95 表が長くなりましたが、これなら一つの列に2つ以上の情報が含まれることはありません。この場合、表13.1と表13.2のように、行と列を転置することができるでしょうか。 表 13.4: 表13.3を転置した場合 Name Hadley Hadley Song Song Yanai Yanai Treat Control Treatment Control Treatment Control Treatment Math_Score 90 90 80 25 100 95 その結果が表13.4ですが、いかがでしょうか。まず、列名が重複している時点でアウトですし、人間が見ても非常に分かりにくい表になりました。また、一つの列に異なるデータ (この場合、character型とnumeirc型)が混在しています。パソコンから見てはわけのわからないデータになったわけです。 ここまで来たら整然データのイメージはある程度掴めたかも知れません。具体的に整然データとは次の4つの条件を満たすデータです(Wickham, 2014)。 1つの列は、1つの変数を表す。 1つの行は、1つの観測を表す。 1つのセル（特定の列の特定の行）は、1つの値を表す。 1つの表は、1つの観測単位 (unit of observation)をもつ（異なる観測単位が混ざっていない）。 以下でも、表13.1と表13.3を対比しながら、以上の4条件をより詳しく説明します。 13.1.1 1つの列は、1つの変数を表す 表13.1と表13.3に含まれる情報は以下の3つで共通しています。 被験者名 投薬有無 数学成績 これらの情報がそれぞれデータの変数になるわけですが、整然データは一つの列が一つの変数を表します。それではまず、表13.1 (図13.1の左)から考えてみましょう。この図には3つの情報が全て含まれています。しかし、数学成績は2列に渡って格納されており、「1列1変数」の条件を満たしておりません。一方、表13.3 (図13.1の右)は投薬前後を表すTreat変数を作成し、その値に応じた数学成績が格納されており、「1列1変数」の条件を満たしています。 図 13.1: 1つの列は、1つの変数を表す 「1列1変数」は整然データの最も基本となる条件であり、整然データ作成の出発点とも言えます。 13.1.2 1つの行は、1つの観測を表す 図13.2の左は一行当たり、いくつの観察が含まれているでしょうか。そのためにはこのデータが何を観察しているかを考える必要があります。このデータは投薬前後の数学成績を観察し、量的に測定したものです。つまり、同じ人に対して2回観察を行ったことになります。したがって、投薬前の数学成績と投薬後の数学成績は別の観察であり、図13.2の左は3行の表ですが、実は6回分の観察が含まれていることになります。1行に2つの観察が載っていることですね。 図 13.2: 1つの行は、1つの観測を表す 一方、図13.2の右は6行のデータであり、観察回数とデータの行数が一致しています。つまり、1行に1観察となります。 今回は数学成績しか測っていたいので、簡単な例ですが、実際のデータには曖昧な部分があります。たとえば、投薬によって血圧が変化する可能性があるため、最高血圧もまた投薬前後に測定したとします。それが表13.5の左です。 表 13.5: 1行1観察の例 Name Treat Math Blood Hadley Control 90 110 Hadley Treatment 90 115 Song Control 80 95 Song Treatment 25 110 Yanai Control 100 100 Yanai Treatment 95 95 Name Treat Type Value Hadley Control Math 90 Hadley Control Blood 110 Hadley Treatment Math 90 Hadley Treatment Blood 115 Song Control Math 80 Song Control Blood 95 Song Treatment Math 25 Song Treatment Blood 110 Yanai Control Math 100 Yanai Control Blood 100 Yanai Treatment Math 95 Yanai Treatment Blood 95 3人に投薬前後に数学成績と最高血圧を測定した場合の観察回数は何回でしょう。3人 \\(\\times\\) 2時点 \\(\\times\\) 2指標の測定だから12回の測定でしょうか。ならば、表13.5の右が整然データでしょう。しかし、この場合、1列1変数という条件が満たされなくなります。Value列には数学成績と血圧が混在しており、2つの変数になります。ならば、どれも整然データではないということでしょうか。実は整然データは表13.5の左です。なぜなら、「1観察=1値」ではないからです。データにおける観察とは観察単位ごとに測定された値の集合です。観察対象とは人や自治体、企業、国などだけでなく、時間も含まれます。たとえば、人の特徴 (性別、身長、所得、政治関心など)を測定しもの、ある日の特徴 (気温、株価など)を測定したもの全てが観察です。むろん、人 \\(\\times\\) 時間のような組み合わせが観察単位ともなり得ます。この一つ一つの観察単位から得られた値の集合が観察です。表13.5の分析単位は「人 \\(\\times\\) 時間」です。成績や最高血圧は分析単位が持つ特徴や性質であって、分析単位ではありません。 13.1.3 1つのセルは、1つの値を表す この条件に反するケースはあまりないかも知れません。たとえば、「Hadleyは処置前後の数学成績が同じだし、一行にまとめよう」という意味で図13.3の左のような表を作る方もいるかも知れませんが、あまりいないでしょう。 図 13.3: 1つのセルは、1つの値を表す 図13.3の例は「1セル1値」の条件に明らかに反します。しかし、基準が曖昧な変数もあり、その一つが日付です。 表 13.6: 日付の扱い方 Date Stock 2020/06/29 100 2020/06/30 105 2020/07/01 110 2020/07/02 85 2020/07/03 90 Year Month Date Stock 2020 6 29 100 2020 6 30 105 2020 7 1 110 2020 7 2 85 2020 7 3 90 表13.6の左側の表はどうでしょうか。5日間の株価を記録した架空のデータですが、たしかにDate列には日付が1つずつ、Stockには株価の値が1つずつ格納されています。しかし、解釈によっては「Dateに年、月、日といった3つの値が含まれているぞ」と見ることもできます。この解釈に基づく場合、表13.6の右側の表が整然データとなり、左側は雑然データとなります。このケースは第一条件であった「一列一変数」とも関係します。なぜなら、Dateという列が年・月・日といった3変数で構成されているとも解釈できるからです。 分析によっては左側のような表でも全く問題ないケースもあります。時系列分析でトレンド変数のみ必要ならこれでも十分に整然データと呼べます。しかし、季節変動などの要素も考慮するならば、左側は雑然データになります。データとしての使い勝手は右側の方が優れているのは確かです。 データを出来る限り細かく分解するほど情報量が豊かになりますが、それにも限度はあるでしょう。たとえば、「Yearは実は世紀の情報も含まれているのでは…?」という解釈もできますが、これを反映してデータ整形を行うか否かは分析の目的と分析モデルによって異なります。この意味で、明らかな雑然データはあり得ますが、明らかな整然データは存在しないでしょう。どちらかといえば、整然さの度合いがあり、「これなら十分に整然データと言えないだろうか」と判断できれば十分ではないかと筆者 (Song)は考えます。 13.1.4 1つの表は、1つの観測単位をもつ e-statなどから国勢調査データをダウンロードした経験はあるでしょうか。以下の図13.4は2015年度国勢調査データの一部です。 図 13.4: 国勢調査データ このデータの観察単位はなんでしょうか。データのの1行目は全国の人口を表しています。つまり、単位は国となります。しかし、2行目は北海道の人口です。この場合の観測単位は都道府県となります。つづいて、3行目は札幌市なので単位は市区町村になります。4行目は札幌市中央区、つまり観測単位が行政区になっています。そして14行目は函館市でまた単位は市区町村に戻っています。実際、会社や政府が作成するデータには図13.4や図13.5のようなものが多いです。とりわけ、図13.5のように、最後の行に「合計」などが表記されている場合が多いです。 図 13.5: 1つの表は、1つの観測単位をもつ このような表・データを作成することが悪いことではありません。むしろ、「読む」ための表ならこのような書き方が一般的でしょう。しかし、「分析」のためのデータは観察の単位を統一する必要があります。 13.2 Wide型からLong型へ 以下では「1列1変数」の条件を満たすデータの作成に便利なpivot_longer()とpivot_wider()関数について解説します。この関数群はおなじみのdplyrでなく、tidyrパッケージが提供している関数ですが、どれもtidyverseパッケージ群に含まれているため、tidyverseパッケージを読み込むだけで十分です。本節ではpivot_longer()を、次節ではpivot_wider()を取り上げます。 まず、pivot_longer()ですが、この関数は比較的に新しい関数であり、これまではtidyrのgather()関数が使われてきました。しかし、gahter()関数は将来、なくなる予定の関数であり、今からtidyrを学習する方はpivot_*()関数群に慣れておきましょう。 まずはtidyverseパッケージを読み込みます。 library(tidyverse) 今回は様々な形のデータを変形する作業をするので、あるデータセットを使うよりも、架空の簡単なデータを使います。 df1 &lt;- tibble( Name = c(&quot;Hadley&quot;, &quot;Song&quot;, &quot;Yanai&quot;), Control = c(90, 80, 100), Treatment = c(90, 25, 95), Gender = c(&quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;) ) df1 ## # A tibble: 3 x 4 ## Name Control Treatment Gender ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Hadley 90 90 Male ## 2 Song 80 25 Female ## 3 Yanai 100 95 Female このデータは既に指摘した通り「1列1変数」の条件を満たしております。この条件を満たすデータは以下のような形となります。 ## # A tibble: 6 x 4 ## Name Gender Treat Math_Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Hadley Male Control 90 ## 2 Hadley Male Treatment 90 ## 3 Song Female Control 80 ## 4 Song Female Treatment 25 ## 5 Yanai Female Control 100 ## 6 Yanai Female Treatment 95 Treat変数が作成され、元々は変数名であった\"Control\"と\"Treatment\"が値として格納されます。この変数をキー変数と呼びます。そして、キー変数の値に応じた数学成績がMath_Scoreという変数でまとめられました。この変数を値変数と呼びます。 「1列1変数」を満たさなかった最初のデータは「Wide型データ」、これを満たすようなデータは「Long型データ」と呼ばれます。これは相対的に最初のデータが横に広いから名付けた名前であって、「Wide型=雑然データ」もしくは「Long型=雑然データ」ではないことに注意してください2。 Wide型データをLong型へ変換する関数がpivot_longer()であり、基本的な使い方は以下の通りです。 # pivot_longer()の使い方 データ名 %&gt;% pivot_longer(cols = c(まとめる変数1, まとめる変数2, ...), names_to = &quot;キー変数名&quot;, values_to = &quot;値変数名&quot;) ここでは同じ変数がControlとTreatment変数で分けられているため、まとめる変数はこの2つであり、cols = c(Control, Treatment)と指定します。ControlとTreatmentは\"で囲んでも、囲まなくても同じです。また、dplyrのselect()関数で使える変数選択の関数 (starts_with()、where()など)や:演算子も使用可能です。また、cols引数はpivot_longer()の第2引数であるため、cols =は省略可能です（第一引数はパイプにより既に渡されています）。 names_toとvalues_to引数はそれぞれキー変数名と値変数名を指定する引数で、ここは必ず\"で囲んでください。このdf1をLong型へ変換し、df1_Lと名付けるコードが以下のコードです。 df1_L &lt;- df1 %&gt;% pivot_longer(Control:Treatment, names_to = &quot;Treat&quot;, values_to = &quot;Math_Score&quot;) df1_L ## # A tibble: 6 x 4 ## Name Gender Treat Math_Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Hadley Male Control 90 ## 2 Hadley Male Treatment 90 ## 3 Song Female Control 80 ## 4 Song Female Treatment 25 ## 5 Yanai Female Control 100 ## 6 Yanai Female Treatment 95 これだけでもpivot_longer()関数を使ってWide型からLong型への変換は問題なくできますが、以下ではもうちょっと踏み込んだ使い方について解説します。「ここまでで十分だよ」という方は、ここを飛ばしても構いません。 今回の実習データdf3は3人の体重を3日間に渡って計測したものです。ただし、ドジっ子のSongは2日目にうっかり測るのを忘れており、欠損値となっています。 df2 &lt;- tibble( Name = c(&quot;Hadley&quot;, &quot;Song&quot;, &quot;Yanai&quot;), Day1 = c(75, 120, 70), Day2 = c(73, NA, 69), Day3 = c(71, 140, 71) ) df2 ## # A tibble: 3 x 4 ## Name Day1 Day2 Day3 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hadley 75 73 71 ## 2 Song 120 NA 140 ## 3 Yanai 70 69 71 まず、これをこれまでのやり方でLong型へ変形し、df2_Lと名付けます。 df2_L &lt;- df2 %&gt;% pivot_longer(starts_with(&quot;Day&quot;), names_to = &quot;Day&quot;, values_to = &quot;Weight&quot;) df2_L ## # A tibble: 9 x 3 ## Name Day Weight ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Hadley Day1 75 ## 2 Hadley Day2 73 ## 3 Hadley Day3 71 ## 4 Song Day1 120 ## 5 Song Day2 NA ## 6 Song Day3 140 ## 7 Yanai Day1 70 ## 8 Yanai Day2 69 ## 9 Yanai Day3 71 これでも問題ないかも知れませんが、以下のような操作を追加に行うとします。 Weightが欠損している行を除去する Dayの値から\"Day\"を除去し、numeric型にする 以上の作業を行うには、dplyrが便利でしょう。ちなみにstr_remove()関数が初めて登場しましたが、これについては第16章で詳細に解説します。簡単に説明しますと、str_remove(\"X123\", \"X\")は\"X123\"から\"X\"を除去し、\"123\"のみ残す関すです。残された値が数字のみであってもデータ型はcharacter型なので、もう一回、numeric型に変換する必要があります3。dplyrを使ったコードは以下の通りです。 # 1. WeightがNAのケースを除去 # 2. Day変数の値から&quot;Day&quot;を除去 # 3. Day変数をnumeric型へ変換 df2_L %&gt;% filter(!is.na(Weight)) %&gt;% # 1 mutate(Day = str_remove(Day, &quot;Day&quot;), # 2 Day = as.numeric(Day)) # 3 ## # A tibble: 8 x 3 ## Name Day Weight ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hadley 1 75 ## 2 Hadley 2 73 ## 3 Hadley 3 71 ## 4 Song 1 120 ## 5 Song 3 140 ## 6 Yanai 1 70 ## 7 Yanai 2 69 ## 8 Yanai 3 71 実はこの作業、pivot_longer()内で行うことも可能です。たとえば、values_toで指定した変数の値が欠損しているケースを除去するにはvalues_drop_na引数をTRUEに指定するだけです。 # Weight変数がNAのケースを除去する df2 %&gt;% pivot_longer(starts_with(&quot;Day&quot;), names_to = &quot;Day&quot;, values_to = &quot;Weight&quot;, values_drop_na = TRUE) ## # A tibble: 8 x 3 ## Name Day Weight ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Hadley Day1 75 ## 2 Hadley Day2 73 ## 3 Hadley Day3 71 ## 4 Song Day1 120 ## 5 Song Day3 140 ## 6 Yanai Day1 70 ## 7 Yanai Day2 69 ## 8 Yanai Day3 71 # 1. Day変数の値から&quot;Day&quot;を除去する # 2. Day変数をinteger型に変換 # 3. Weight変数がNAのケースを除去する df2 %&gt;% pivot_longer(starts_with(&quot;Day&quot;), names_to = &quot;Day&quot;, names_prefix = &quot;Day&quot;, # 1 names_transform = list(Day = as.numeric), # 2 values_to = &quot;Weight&quot;, values_drop_na = TRUE) # 3 ## # A tibble: 8 x 3 ## Name Day Weight ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hadley 1 75 ## 2 Hadley 2 73 ## 3 Hadley 3 71 ## 4 Song 1 120 ## 5 Song 3 140 ## 6 Yanai 1 70 ## 7 Yanai 2 69 ## 8 Yanai 3 71 13.3 Long型からWide型へ pivot_wider() spread()は旧版 13.4 列の操作 separate() parse_number() 参考資料 "]
]
