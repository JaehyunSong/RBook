[
["datahandling1.html", "10. データハンドリング[基礎編] 10.1 データハンドリングとtidyverse 10.2 パイプ演算子 (%&gt;%) 10.3 列の抽出 10.4 行の抽出 10.5 行のソート 10.6 記述統計量の計算 10.7 グルーピング 10.8 変数の計算 10.9 行単位の操作 10.10 練習問題", " 10. データハンドリング[基礎編] ここでは比較的綺麗に整形されているデータフレームを扱う方法について考えます。ここでいう「比較的綺麗なデータ」とは、すぐに分析に使えるレベルのデータを意味します。 10.1 データハンドリングとtidyverse 作成中 library(tidyverse) 10.2 パイプ演算子 (%&gt;%) dplyrパッケージを利用する前にパイプ演算子について説明します。パイプ演算子はdplyrに含まれている演算子ではなく、magrittrという別のパッケージから提供される演算子ですが、tidyverseパッケージを読み込むと自動的に読み込まれます。パイプ演算子はx %&gt;% y()のような書き方となりますが、これは「xをy()の第一引数として渡す」ことを意味します。xの部分はベクトルやデータフレームのようなオブジェクトでも、関数でも構いません。なぜなら、関数から得られた結果もまたベクトルやデータフレームといったものになるからです。 たとえば、「paste(3, \"+\", 5, \"=\", 8)を実行し、その結果をrep()関数を使って3回複製し、それをprint()を使って出力する」コードを考えてみましょう。方法としては2つ考えられます。まずは、それぞれの処理を別途のオブジェクトに格納する方法です。そして二つ目は関数の中に関数を使う方法です。 # 方法1: 一関数一オブジェクト Result1 &lt;- paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) Result2 &lt;- rep(Result1, 3) print(Result2) ## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; # 方法2: 関数の中に関数の中に関数 print(rep(paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8), 3)) ## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; どれも結果は同じです。コードを書く手間を考えれば、後者の方が楽かも知れませんが、可読性があまりよくありません。一方、前者は可読性は良いものの、コードも長くなり、オブジェクトを2つも作ってしまうのでメモリの無駄遣いになります。 コードの可読性と書く手間、両方を満足する書き方がパイプ演算子%&gt;%です。まずは、例から見ましょう。 # %&gt;%を使う paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) %&gt;% rep(3) %&gt;% print() ## [1] &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; &quot;3 + 5 = 8&quot; まず、結果は先ほどと同じです。それではコードの説明をしましょう。まずは、paste(3, \"+\", 5, \"=\", 8)を実行します。そしてその結果をそのままrep()関数の第一引数として渡されます。つまり、rep(paste(3, \"+\", 5, \"=\", 8), 3)になるわけです。ここではrep(3)と書きましたが、第一引数が渡されたため、3は第二引数扱いになります (パイプ演算子前のオブジェクトを第二、三引数として渡す方法は適宜説明します。)。そして、これをまたprint()関数に渡します。結果としてはprint(rep(paste(3, \"+\", 5, \"=\", 8), 3))となります。 関数を重ねると読む順番は「カッコの内側から外側へ」になりますが、パイプ演算子を使うと「左から右へ」といったより自然な読み方が可能になります。また、以下のコードのように、パイプ演算子後に改行を行うことでより読みやすいコードになります。これからはパイプ演算子の後は必ず改行をします。 # 改行 (+字下げ)したらもっと読みやすくなる paste(3, &quot;+&quot;, 5, &quot;=&quot;, 8) %&gt;% rep(3) %&gt;% print() データハンドリングは様々な作業を準じに行う必要があります。例えば、「(1) 列を選択して、(2) 欠損値を含む列を除去して、 (3) ある変数の値を100倍にして、(4) ある変数の値がが小さい行から大きい順へ並び替える」といった手順です。これらの作業はパイプ演算子を使えば、スムーズに行うことが可能です。 10.3 列の抽出 それでは今回の実習用データを読み込みましょう。Ramen.csvには「ぐるなび」から取得したラーメン屋6292店舗の情報が入っています。具体的には東京、神奈川、千葉、埼玉、大阪、京都、兵庫、奈良、和歌山それぞれ都府県にあるラーメン屋の中から最大1000店舗の情報を抽出したものです。東京都は、ぐるなびに登録したラーメン屋が3000店舗以上ですが、1000店舗の基準はぐるなびの「おすすめ」の順で上位1000店舗となります。また、店側またはぐるなびが登録したカテゴリを基準に抽出したため、実際はラーメン屋ではないにもかかわらずラーメン屋としてデータ内に含まれている可能性があります。 まず、このデータを読み込み、dfという名付けます。 df &lt;- read_csv(&quot;Data/Ramen.csv&quot;) ## Parsed with column specification: ## cols( ## ID = col_character(), ## Name = col_character(), ## Pref = col_character(), ## Zipcode = col_double(), ## Latitude = col_double(), ## Longitude = col_double(), ## Line = col_character(), ## Station = col_character(), ## Walk = col_double(), ## Bus = col_double(), ## Car = col_double(), ## Budget = col_double(), ## ScoreN = col_double(), ## Score = col_double() ## ) データの中身を確認してみましょう。 df ## # A tibble: 6,292 x 14 ## ID Name Pref Zipcode Latitude Longitude Line Station Walk Bus Car Budget ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 東京都… 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 ## 2 gfeb… 本格上海… 東京都… 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA NA 2000 ## 3 ggt5… 食べ飲み… 東京都… 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA NA 2980 ## 4 g181… 博多餃子… 東京都… 1920904 35.7 139. ＪＲ 八王子駅… 1 NA NA 2000 ## 5 ggww… まさ屋 … 東京都… 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA NA 380 ## 6 gdzk… 完全個室… 東京都… 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 ## 7 ga2g… 鶏そば … 東京都… 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA NA 850 ## 8 gg9m… 宴会個室… 東京都… 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA NA 2000 ## 9 gdvk… 中国料理… 東京都… 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA NA 1000 ## 10 gggb… 中国料理… 東京都… 1140002 35.8 140. 地下鉄南… 王子駅 2 NA NA 2000 ## # … with 6,282 more rows, and 2 more variables: ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; 1行目の# A tibble: 2,000 x 12から、ケース数 (店舗数)は2000、変数は12個あることが分かります。各変数の詳細は以下の通りです。 変数名 説明 ID ぐるなび上の店舗ID Name 店舗名 Pref 店舗の所在地 (都府県) Zipcode 店舗の郵便番号 Latitude 緯度 Longitude 経度 Line 最寄りの駅の路線 Station 最寄りの駅 Walk 最寄りの駅からの距離 (徒歩; 分) Bus 最寄りの駅からの距離 (バス; 分) Car 最寄りの駅からの距離 (車; 分) Budget 平均予算 (円) ScoreN 口コミの数 Score 口コミ評価の平均値 それではここからはdfを用いたdplyrの様々な機能を紹介していきます。 10.3.1 特定の列を抽出する まずは、データフレームから特定の列のみを残す、除去する方法について紹介します。たとえば、dfからID、Name、Pref、Scoreのみを残すとします。dplyrを使わない方法とdplyrのselect()関数を使った方法を紹介します。 # dplyrを使わない方法 df[, c(&quot;ID&quot;, &quot;Name&quot;, &quot;Pref&quot;, &quot;Score&quot;)] ## # A tibble: 6,292 x 4 ## ID Name Pref Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA ## 5 ggww100 まさ屋 渋谷店 東京都 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 東京都 NA ## 7 ga2g202 鶏そば きらり 東京都 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 3.33 ## 9 gdvk200 中国料理 宝龍 東京都 2.5 ## 10 gggb200 中国料理 天安門 東京都 NA ## # … with 6,282 more rows # dplyr::select()を使う方法 # select(df, ID, Name, Pref, Score)でもOK df %&gt;% select(ID, Name, Pref, Score) ## # A tibble: 6,292 x 4 ## ID Name Pref Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA ## 5 ggww100 まさ屋 渋谷店 東京都 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 東京都 NA ## 7 ga2g202 鶏そば きらり 東京都 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 3.33 ## 9 gdvk200 中国料理 宝龍 東京都 2.5 ## 10 gggb200 中国料理 天安門 東京都 NA ## # … with 6,282 more rows どれも結果は同じですが、select()関数を使った方がより読みやすいコードになっているでしょう。むろん、select()関数を使わない方がスッキリする方も知るかも知れません。実際、自分でパッケージなどを作成する際はselect()を使わない場合が多いです。ただし、一般的な分析の流れではselect()の方がコードも意味も明確となり、パイプ演算子でつなぐのも容易です。 select()関数の使い方は非常に簡単です。第一引数はデータフレームですが、パイプ演算子を使う場合は省略可能です。第二引数以降の引数はデータフレームの変数名です。つまり、ここには残す変数名のみを書くだけで十分です。 また、select()関数を使って列の順番を変えることもできます。たとえば、ID、Pref、Name、Scoreの順で列を残すなら、この順番で引数を書くだけです。 df %&gt;% select(ID, Pref, Name) ## # A tibble: 6,292 x 3 ## ID Pref Name ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 e539604 東京都 居酒屋 龍記 京橋店 ## 2 gfeb600 東京都 本格上海料理 新錦江 上野御徒町本店 ## 3 ggt5900 東京都 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） ## 4 g181340 東京都 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 ## 5 ggww100 東京都 まさ屋 渋谷店 ## 6 gdzk500 東京都 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 ## 7 ga2g202 東京都 鶏そば きらり ## 8 gg9m100 東京都 宴会個室×餃子酒場 北京飯店 秋葉原本店 ## 9 gdvk200 東京都 中国料理 宝龍 ## 10 gggb200 東京都 中国料理 天安門 ## # … with 6,282 more rows 10.3.2 特定の列を抽出し、列名を変更する また、特定の列を残す際、変数名を変更することも可能です。今回もID、Name、Pref、Scoreのみを残しますが、Pref列はPrefectureに変えてみましょう。 df %&gt;% select(ID, Name, Prefecture = Pref, Score) ## # A tibble: 6,292 x 4 ## ID Name Prefecture Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 東京都 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 東京都 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 東京都 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 東京都 NA ## 5 ggww100 まさ屋 渋谷店 東京都 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 東京都 NA ## 7 ga2g202 鶏そば きらり 東京都 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 東京都 3.33 ## 9 gdvk200 中国料理 宝龍 東京都 2.5 ## 10 gggb200 中国料理 天安門 東京都 NA ## # … with 6,282 more rows 抽出する際、変数を新しい変数名 = 既存の変数名にするだけで、変数名が簡単に変更できました。もし、特定の列は抽出しないものの、変数名を変えるにはどうすれば良いでしょうか。ここではdfのPrefをPrefectureに、WalkをDistanceに変更してみます。dplyrを使わない場合とdplyrのrename()関数を使う場合を両方紹介します。 まずは、name()関数についてですが、これはデータフレームの変数名をベクトルとして出力する関数です。 names(df) ## [1] &quot;ID&quot; &quot;Name&quot; &quot;Pref&quot; &quot;Zipcode&quot; &quot;Latitude&quot; &quot;Longitude&quot; ## [7] &quot;Line&quot; &quot;Station&quot; &quot;Walk&quot; &quot;Bus&quot; &quot;Car&quot; &quot;Budget&quot; ## [13] &quot;ScoreN&quot; &quot;Score&quot; 察しの良い読者は気づいたかも知れませんが、names(データフレーム名)の結果はベクトルであり、上書きも可能です。つまり、names(df)の3番目と9番目の要素を\"Prefecture\"と\"Distance\"に上書きすることができるということです。 # dplyrを使わずに列名を変更する方法 names(df)[c(3, 9)] &lt;- c(&quot;Prefecture&quot;, &quot;Distance&quot;) # dfの中身を出力 df ## # A tibble: 6,292 x 14 ## ID Name Prefecture Zipcode Latitude Longitude Line Station Distance Bus ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 東京都 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA ## 2 gfeb… 本格上海… 東京都 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA ## 3 ggt5… 食べ飲み… 東京都 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA ## 4 g181… 博多餃子… 東京都 1920904 35.7 139. ＪＲ 八王子駅… 1 NA ## 5 ggww… まさ屋 … 東京都 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA ## 6 gdzk… 完全個室… 東京都 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA ## 7 ga2g… 鶏そば … 東京都 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA ## 8 gg9m… 宴会個室… 東京都 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA ## 9 gdvk… 中国料理… 東京都 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA ## 10 gggb… 中国料理… 東京都 1140002 35.8 140. 地下鉄南… 王子駅 2 NA ## # … with 6,282 more rows, and 4 more variables: Car &lt;dbl&gt;, Budget &lt;dbl&gt;, ## # ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; 簡単に変数名の変更ができました。続いて、dplyrのrename()関数を使った方法です。今回は、PrefectureをPrefに、DistanceをWalkに戻して見ましょう。そして、出力するだけにとどまらず、dfに上書きしましょう。 # dfのPrefectureをPrefに、DistanceをWalkに変更し、上書きする df &lt;- df %&gt;% rename(Pref = Prefecture, Walk = Distance) これで終わりです。実はselect()関数と使い方がほぼ同じです。ただし、残す変数名を指定する必要がなく、名前を変更する変数名と新しい変数名を入れるだけです。変数が少ないデータならselect()でもあまり不便は感じないかも知れませんが、変数が多くなるとrename()関数は非常に便利です。 10.3.3 特定の列を除外する 逆に、一部の変数をデータフレームから除去したい場合もあるでしょう。たとえば、緯度 (Latitude)と経度 (Longitude)はラーメン屋の情報としては不要かもしれません。この2つの変数を除外するためにはどうすれば良いでしょうか。まず考えられるのは、この2つの変数を除いた変数を指定・抽出する方法です。 df %&gt;% select(ID, Name, Pref, Zipcode, Line, Station, Walk, Bus, Car, Budget, ScoreN, Score) ## # A tibble: 6,292 x 12 ## ID Name Pref Zipcode Line Station Walk Bus Car Budget ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e5396… 居酒屋 龍記 京橋… 東京都… 1040031 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 0 NA ## 2 gfeb6… 本格上海料理 新錦… 東京都… 1100005 地下鉄日… 仲御徒町駅… 1 NA NA 2000 2 4.5 ## 3 ggt59… 食べ飲み放題×中華… 東京都… 1250041 ＪＲ常磐… 金町駅 2 NA NA 2980 0 NA ## 4 g1813… 博多餃子軒 八王子… 東京都… 1920904 ＪＲ 八王子駅… 1 NA NA 2000 0 NA ## 5 ggww1… まさ屋 渋谷店… 東京都… 1500042 地下鉄半… 渋谷駅 7 NA NA 380 0 NA ## 6 gdzk5… 完全個室 上海レス… 東京都… 1000013 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 0 NA ## 7 ga2g2… 鶏そば きらり… 東京都… 1760006 西武池袋… 江古田駅… 2 NA NA 850 0 NA ## 8 gg9m1… 宴会個室×餃子酒場… 東京都… 1010021 ＪＲ 秋葉原駅… 4 NA NA 2000 3 3.33 ## 9 gdvk2… 中国料理 宝龍… 東京都… 1000006 ＪＲ 有楽町駅… 1 NA NA 1000 2 2.5 ## 10 gggb2… 中国料理 天安門… 東京都… 1140002 地下鉄南… 王子駅 2 NA NA 2000 0 NA ## # … with 6,282 more rows かなり長いコードになりましたね。しかし、もっと簡単な方法があります。それは-を使う方法です。 df %&gt;% select(-Latitude, -Longitude) # select(-c(Latitude, Longitude)) ## # A tibble: 6,292 x 12 ## ID Name Pref Zipcode Line Station Walk Bus Car Budget ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e5396… 居酒屋 龍記 京橋… 東京都… 1040031 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 0 NA ## 2 gfeb6… 本格上海料理 新錦… 東京都… 1100005 地下鉄日… 仲御徒町駅… 1 NA NA 2000 2 4.5 ## 3 ggt59… 食べ飲み放題×中華… 東京都… 1250041 ＪＲ常磐… 金町駅 2 NA NA 2980 0 NA ## 4 g1813… 博多餃子軒 八王子… 東京都… 1920904 ＪＲ 八王子駅… 1 NA NA 2000 0 NA ## 5 ggww1… まさ屋 渋谷店… 東京都… 1500042 地下鉄半… 渋谷駅 7 NA NA 380 0 NA ## 6 gdzk5… 完全個室 上海レス… 東京都… 1000013 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 0 NA ## 7 ga2g2… 鶏そば きらり… 東京都… 1760006 西武池袋… 江古田駅… 2 NA NA 850 0 NA ## 8 gg9m1… 宴会個室×餃子酒場… 東京都… 1010021 ＪＲ 秋葉原駅… 4 NA NA 2000 3 3.33 ## 9 gdvk2… 中国料理 宝龍… 東京都… 1000006 ＪＲ 有楽町駅… 1 NA NA 1000 2 2.5 ## 10 gggb2… 中国料理 天安門… 東京都… 1140002 地下鉄南… 王子駅 2 NA NA 2000 0 NA ## # … with 6,282 more rows 除外したい変数名の前に-を付けただけです。また、-Latitudeと-Longitudeをそれぞれ指定せず、-c(Latitude, Longitude)のようにc()でまとめるのも可能です。 10.3.4 隣接した列を指定する 先ほど、dfから緯度 (Latitude)と経度 (Longitude)を除外する例を考えてみましょう。-を使うと簡単ですが、場合によっては残す変数名を指定する必要もあります。 df %&gt;% select(ID, Name, Pref, Zipcode, Line, Station, Walk, Bus, Car, Budget, ScoreN, Score) よく考えてみれば、IDからZipcodeは隣接した列ですし、LineからScoreまでもそうです。これはnames()関数で確認できます。 names(df) ## [1] &quot;ID&quot; &quot;Name&quot; &quot;Pref&quot; &quot;Zipcode&quot; &quot;Latitude&quot; &quot;Longitude&quot; ## [7] &quot;Line&quot; &quot;Station&quot; &quot;Walk&quot; &quot;Bus&quot; &quot;Car&quot; &quot;Budget&quot; ## [13] &quot;ScoreN&quot; &quot;Score&quot; ここで便利な演算子が:です。これまで、xからyまでの公差1の等差数列を作成する際にx:yを使って来ましたが、これに非常に似ています。データフレームの「x列からy列まで」の表記もselect()関数内では:と書くことができます。したがって、上記のコードは以下のように短縮化可能です。 df %&gt;% select(ID:Zipcode, Line:Score) 「dfのIDからZipcodeまで、そしてLineからScoreまでの列を選択する」という意味です。非常に便利な演算子ですので、-と合わせて覚えておきましょう。 10.3.5 一部の列の順番だけを変える ある列の位置を替えたいとします。たとえば、ScoreとScoreNをそれぞれ1列目、2列目にしたい場合、どうすれば良いでしょうか。これまで勉強したことを考えると、以下のようなコードで問題ないでしょう。 df %&gt;% select(Score, ScoreN, ID:Budget) ## # A tibble: 6,292 x 14 ## Score ScoreN ID Name Pref Zipcode Latitude Longitude Line Station Walk Bus ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NA 0 e539… 居酒屋 … 東京都… 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA ## 2 4.5 2 gfeb… 本格上海… 東京都… 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA ## 3 NA 0 ggt5… 食べ飲み… 東京都… 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA ## 4 NA 0 g181… 博多餃子… 東京都… 1920904 35.7 139. ＪＲ 八王子駅… 1 NA ## 5 NA 0 ggww… まさ屋 … 東京都… 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA ## 6 NA 0 gdzk… 完全個室… 東京都… 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA ## 7 NA 0 ga2g… 鶏そば … 東京都… 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA ## 8 3.33 3 gg9m… 宴会個室… 東京都… 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA ## 9 2.5 2 gdvk… 中国料理… 東京都… 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA ## 10 NA 0 gggb… 中国料理… 東京都… 1140002 35.8 140. 地下鉄南… 王子駅 2 NA ## # … with 6,282 more rows, and 2 more variables: Car &lt;dbl&gt;, Budget &lt;dbl&gt; しかし、dplyrにはrelocate()というより便利な専用関数を提供しています。relocate()には変数名を指定するだけですが、ここで指定した変数がデータフレームの最初列の方に移動します。 df %&gt;% relocate(Score, ScoreN) ## # A tibble: 6,292 x 14 ## Score ScoreN ID Name Pref Zipcode Latitude Longitude Line Station Walk Bus ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 NA 0 e539… 居酒屋 … 東京都… 1040031 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA ## 2 4.5 2 gfeb… 本格上海… 東京都… 1100005 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA ## 3 NA 0 ggt5… 食べ飲み… 東京都… 1250041 35.8 140. ＪＲ常磐… 金町駅 2 NA ## 4 NA 0 g181… 博多餃子… 東京都… 1920904 35.7 139. ＪＲ 八王子駅… 1 NA ## 5 NA 0 ggww… まさ屋 … 東京都… 1500042 35.7 140. 地下鉄半… 渋谷駅 7 NA ## 6 NA 0 gdzk… 完全個室… 東京都… 1000013 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA ## 7 NA 0 ga2g… 鶏そば … 東京都… 1760006 35.7 140. 西武池袋… 江古田駅… 2 NA ## 8 3.33 3 gg9m… 宴会個室… 東京都… 1010021 35.7 140. ＪＲ 秋葉原駅… 4 NA ## 9 2.5 2 gdvk… 中国料理… 東京都… 1000006 35.7 140. ＪＲ 有楽町駅… 1 NA ## 10 NA 0 gggb… 中国料理… 東京都… 1140002 35.8 140. 地下鉄南… 王子駅 2 NA ## # … with 6,282 more rows, and 2 more variables: Car &lt;dbl&gt;, Budget &lt;dbl&gt; relocate()を使うとID:Budgetが省略可能となり、より短いコードになります。もう一つの例は、最初に持ってくるのではなく、「ある変数の前」または「ある変数の後」に移動させるケースです。これもrelocate()で可能ですが、もう一つの引数が必要です。PrefとZipcdoeの順番を変えるなら、まずは以下のような方法が考えられます。 df %&gt;% select(ID:Name, Zipcode, Pref, Latitude:Score) ## # A tibble: 6,292 x 14 ## ID Name Zipcode Pref Latitude Longitude Line Station Walk Bus Car Budget ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 1040031 東京都… 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 ## 2 gfeb… 本格上海… 1100005 東京都… 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA NA 2000 ## 3 ggt5… 食べ飲み… 1250041 東京都… 35.8 140. ＪＲ常磐… 金町駅 2 NA NA 2980 ## 4 g181… 博多餃子… 1920904 東京都… 35.7 139. ＪＲ 八王子駅… 1 NA NA 2000 ## 5 ggww… まさ屋 … 1500042 東京都… 35.7 140. 地下鉄半… 渋谷駅 7 NA NA 380 ## 6 gdzk… 完全個室… 1000013 東京都… 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 ## 7 ga2g… 鶏そば … 1760006 東京都… 35.7 140. 西武池袋… 江古田駅… 2 NA NA 850 ## 8 gg9m… 宴会個室… 1010021 東京都… 35.7 140. ＪＲ 秋葉原駅… 4 NA NA 2000 ## 9 gdvk… 中国料理… 1000006 東京都… 35.7 140. ＪＲ 有楽町駅… 1 NA NA 1000 ## 10 gggb… 中国料理… 1140002 東京都… 35.8 140. 地下鉄南… 王子駅 2 NA NA 2000 ## # … with 6,282 more rows, and 2 more variables: ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; これをrelocate()で書き換えるなら、.afterまたは.before引数が必要になります。relocate(変数名1, .after = 変数名2)は「変数1を変数2の直後に移動させる」 ことを意味します。 df %&gt;% relocate(Pref, .after = Zipcode) ## # A tibble: 6,292 x 14 ## ID Name Zipcode Pref Latitude Longitude Line Station Walk Bus Car Budget ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539… 居酒屋 … 1040031 東京都… 35.7 140. 地下鉄有… 銀座一丁目駅… 3 NA NA 3000 ## 2 gfeb… 本格上海… 1100005 東京都… 35.7 140. 地下鉄日… 仲御徒町駅… 1 NA NA 2000 ## 3 ggt5… 食べ飲み… 1250041 東京都… 35.8 140. ＪＲ常磐… 金町駅 2 NA NA 2980 ## 4 g181… 博多餃子… 1920904 東京都… 35.7 139. ＪＲ 八王子駅… 1 NA NA 2000 ## 5 ggww… まさ屋 … 1500042 東京都… 35.7 140. 地下鉄半… 渋谷駅 7 NA NA 380 ## 6 gdzk… 完全個室… 1000013 東京都… 35.7 140. 地下鉄銀… 虎ノ門駅… 3 NA NA 2980 ## 7 ga2g… 鶏そば … 1760006 東京都… 35.7 140. 西武池袋… 江古田駅… 2 NA NA 850 ## 8 gg9m… 宴会個室… 1010021 東京都… 35.7 140. ＪＲ 秋葉原駅… 4 NA NA 2000 ## 9 gdvk… 中国料理… 1000006 東京都… 35.7 140. ＪＲ 有楽町駅… 1 NA NA 1000 ## 10 gggb… 中国料理… 1140002 東京都… 35.8 140. 地下鉄南… 王子駅 2 NA NA 2000 ## # … with 6,282 more rows, and 2 more variables: ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; .beforeを使うことできます。この場合は「ZipcodeをPrefの直前に移動させる」 ことを指定する必要があります。結果は省略しますが、自分でコードを走らせ、上と同じ結果が得られるかを確認してみてください。 df %&gt;% relocate(Zipcode, .before = Pref) 10.3.6 select()の便利な機能 select()関数は他にも便利な機能がいくつかあります。ここではいくつの機能を紹介しますが、より詳しい内容は?dplyr::selectを参照してください。 starts_with()とends_with()、contains()、num_range(): 特定の文字を含む変数を選択する まずは、特定の文字を含む変数名を指定する方法です。starts_with(\"X\")、ends_with(\"X\")、contains(\"X\")は変数名が\"X\"で始まるか、\"X\"で終わるか、\"X\"を含むかを判断し、条件に合う変数名を返す関数です。実際の例を見ましょう。 # ID、Nameに続いて、Scoreで始まる変数名を抽出 df %&gt;% select(ID, Name, starts_with(&quot;Score&quot;)) ## # A tibble: 6,292 x 4 ## ID Name ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 居酒屋 龍記 京橋店 0 NA ## 2 gfeb600 本格上海料理 新錦江 上野御徒町本店 2 4.5 ## 3 ggt5900 食べ飲み放題×中華ビストロ NOZOMI（のぞみ） 0 NA ## 4 g181340 博多餃子軒 八王子店 タピオカ店 Bull Pulu（ブルプル）併設 0 NA ## 5 ggww100 まさ屋 渋谷店 0 NA ## 6 gdzk500 完全個室 上海レストラン 檸檬 霞ヶ関ビル内店 0 NA ## 7 ga2g202 鶏そば きらり 0 NA ## 8 gg9m100 宴会個室×餃子酒場 北京飯店 秋葉原本店 3 3.33 ## 9 gdvk200 中国料理 宝龍 2 2.5 ## 10 gggb200 中国料理 天安門 0 NA ## # … with 6,282 more rows # eで終わる変数名を除去 df %&gt;% select(-ends_with(&quot;e&quot;)) # !ends_with(&quot;e&quot;)も可能 ## # A tibble: 6,292 x 8 ## ID Pref Station Walk Bus Car Budget ScoreN ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 東京都 銀座一丁目駅 3 NA NA 3000 0 ## 2 gfeb600 東京都 仲御徒町駅 1 NA NA 2000 2 ## 3 ggt5900 東京都 金町駅 2 NA NA 2980 0 ## 4 g181340 東京都 八王子駅 1 NA NA 2000 0 ## 5 ggww100 東京都 渋谷駅 7 NA NA 380 0 ## 6 gdzk500 東京都 虎ノ門駅 3 NA NA 2980 0 ## 7 ga2g202 東京都 江古田駅 2 NA NA 850 0 ## 8 gg9m100 東京都 秋葉原駅 4 NA NA 2000 3 ## 9 gdvk200 東京都 有楽町駅 1 NA NA 1000 2 ## 10 gggb200 東京都 王子駅 2 NA NA 2000 0 ## # … with 6,282 more rows # reを含む変数名を抽出するが、ScoreNは除去する df %&gt;% select(contains(&quot;re&quot;), -ScoreN) ## # A tibble: 6,292 x 2 ## Pref Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 東京都 NA ## 2 東京都 4.5 ## 3 東京都 NA ## 4 東京都 NA ## 5 東京都 NA ## 6 東京都 NA ## 7 東京都 NA ## 8 東京都 3.33 ## 9 東京都 2.5 ## 10 東京都 NA ## # … with 6,282 more rows 他の使い方としてはX1、X2のような「文字+数字」の変数を選択する際、starts_with()が活躍します。たとえば、以下のようなmyDF1があるとします。 myDF1 &lt;- data.frame( ID = 1:5, X1 = c(2, 4, 6, 2, 7), Y1 = c(3, 5, 1, 1, 0), X1D = c(4, 2, 1, 6, 9), X2 = c(5, 5, 6, 0, 2), Y2 = c(3, 3, 2, 3, 1), X2D = c(8, 9, 5, 0, 1), X3 = c(3, 0, 3, 0, 2), Y3 = c(1, 5, 9, 1, 3), X3D = c(9, 1, 3, 3, 8) ) myDF1 ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D ## 1 1 2 3 4 5 3 8 3 1 9 ## 2 2 4 5 2 5 3 9 0 5 1 ## 3 3 6 1 1 6 2 5 3 9 3 ## 4 4 2 1 6 0 3 0 0 1 3 ## 5 5 7 0 9 2 1 1 2 3 8 このmyDF1からID、Y1、Y2、Y3を抽出するにはどうすれば良いでしょうか。これらの変数は隣接していないため、:も使えませんが、starts_with()を使えば簡単です。 myDF1 %&gt;% select(ID, starts_with(&quot;Y&quot;)) ## ID Y1 Y2 Y3 ## 1 1 3 3 1 ## 2 2 5 3 5 ## 3 3 1 2 9 ## 4 4 1 3 1 ## 5 5 0 1 3 それでは、ID、X1、X2、X3はどうでしょうか。starts_with(\"X\")だと、X1cなども選択されてしまいますね。ここで-ends_with()の出番です。つまり、「まずはstarts_with(\"X\")でXで始まる変数を選択し、続いて、Dで終わるものを除外すればいいじゃん？」です。それでは、やってみましょうか。 myDF1 %&gt;% select(ID, starts_with(&quot;X&quot;), -ends_with(&quot;D&quot;)) ## X1 X2 X3 ## 1 2 5 3 ## 2 4 5 0 ## 3 6 6 3 ## 4 2 0 0 ## 5 7 2 2 あらら、IDも同時になくなりましたね1。実はこのような時のために用意された関数があり、それがnum_range()です。num_range()の第一引数はstarts_with()関数と同じですが、第二引数も必要です。この第二引数にはnumeric型のベクトルが必要です。1:3でも、c(1, 2, 3)でも構いません。たとえば、ID、X1、X2、X3するには以下のように書きます。 myDF1 %&gt;% select(ID, num_range(&quot;X&quot;, 1:3)) ## ID X1 X2 X3 ## 1 1 2 5 3 ## 2 2 4 5 0 ## 3 3 6 6 3 ## 4 4 2 0 0 ## 5 5 7 2 2 ぱっぱらぱー！ all_of()とany_of(): 文字型ベクトルを用いた変数の選択 all_of()とany_of()はselect()内の変数名として文字型ベクトルを使う際に用いる関数です。これは抽出したい列名が既にcharacter型ベクトルとして用意されている場合、便利な関数です。たとえば、以下のName_Vecを考えてみましょう。 Name_Vec &lt;- c(&quot;X1&quot;, &quot;X2&quot;, &quot;X3&quot;) このName_Vecの要素と同じ列名を持つ列とID列をmyDF1から抽出する方法は以下の2通りです。 myDF1[, c(&quot;ID&quot;, Name_Vec)] ## ID X1 X2 X3 ## 1 1 2 5 3 ## 2 2 4 5 0 ## 3 3 6 6 3 ## 4 4 2 0 0 ## 5 5 7 2 2 myDF1 %&gt;% select(ID, all_of(Name_Vec)) ## ID X1 X2 X3 ## 1 1 2 5 3 ## 2 2 4 5 0 ## 3 3 6 6 3 ## 4 4 2 0 0 ## 5 5 7 2 2 今の例だと、select()を使わない前者の方が便利かも知れませんが、select()内に外の変数名も指定する場合も多いので、後者の方が汎用性は高いです。私から見れば、今の例でも後者の方が読みやすく、使いやすいと思います。 それでは以下のようなName_Vecはどうでしょう。今回は、myDF1に含まれていないX4とX5もあります。 Name_Vec &lt;- c(&quot;X1&quot;, &quot;X2&quot;, &quot;X3&quot;, &quot;X4&quot;, &quot;X5&quot;) myDF1 %&gt;% select(all_of(Name_Vec)) ## Error: Can&#39;t subset columns that don&#39;t exist. ## [31mx[39m Columns `X4` and `X5` don&#39;t exist. このようにエラーが出てしまします。つまり、all_of()の場合、引数の要素全てがデータフレームに存在する必要があります。もし、ないものは無視して、合致する列だけ取り出したいはどうすれば良いでしょうか。そこで登場するのがany_of()です。 myDF1 %&gt;% select(any_of(Name_Vec)) ## X1 X2 X3 ## 1 2 5 3 ## 2 4 5 0 ## 3 6 6 3 ## 4 2 0 0 ## 5 7 2 2 any_of()の方がより使いやすいと思う方も多いでしょうが、必ずしもそうとは限りません。たとえば、Name_Vecに誤字などが含まれる場合、any_of()だと誤字が含まれている変数は取り出しません。この場合はむしろちゃんとエラーを表示してくれた方が嬉しいですね。 last_col(): 最後の列を選択する 普段あまり使わない機能ですが、最後の列を選択するlast_col()という関数もあります。たとえば、last_col(0)にすると最後の列を選択し、last_col(1)なら最後から2番目の列を選択します。たとえば、dfからIDと最後の列を取り出してみましょう。 # IDと最後の列のみを抽出 df %&gt;% select(ID, last_col(0)) ## # A tibble: 6,292 x 2 ## ID Score ## &lt;chr&gt; &lt;dbl&gt; ## 1 e539604 NA ## 2 gfeb600 4.5 ## 3 ggt5900 NA ## 4 g181340 NA ## 5 ggww100 NA ## 6 gdzk500 NA ## 7 ga2g202 NA ## 8 gg9m100 3.33 ## 9 gdvk200 2.5 ## 10 gggb200 NA ## # … with 6,282 more rows 最後の2行分を取り出すことも可能です。この場合はlast_col()の引数を長さ1ベクトルでなく、長さ2以上のベクトルにします。最後の行が0、その手前の行が1ですから、中の引数は1:0となります。0:1でも可能ですが、結果が若干異なります。 # IDと最後の2列分を抽出 (引数を1:0と設定) df %&gt;% select(ID, last_col(1:0)) ## # A tibble: 6,292 x 3 ## ID ScoreN Score ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 0 NA ## 2 gfeb600 2 4.5 ## 3 ggt5900 0 NA ## 4 g181340 0 NA ## 5 ggww100 0 NA ## 6 gdzk500 0 NA ## 7 ga2g202 0 NA ## 8 gg9m100 3 3.33 ## 9 gdvk200 2 2.5 ## 10 gggb200 0 NA ## # … with 6,282 more rows # IDと最後の2列分を抽出 (引数を0:1と設定) df %&gt;% select(ID, last_col(0:1)) ## # A tibble: 6,292 x 3 ## ID Score ScoreN ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 NA 0 ## 2 gfeb600 4.5 2 ## 3 ggt5900 NA 0 ## 4 g181340 NA 0 ## 5 ggww100 NA 0 ## 6 gdzk500 NA 0 ## 7 ga2g202 NA 0 ## 8 gg9m100 3.33 3 ## 9 gdvk200 2.5 2 ## 10 gggb200 NA 0 ## # … with 6,282 more rows last_col()の引数を1:0にするか0:1にするかによって抽出される順番が異なります。1:0はc(1, 0)、0:1はc(0, 1)と同じであることを考えると理由は簡単です。c(1, 0)の場合、last_col(1), last_col(0)の順番で処理をし、c(0, 1)はlast_col(0)、last_col(1)の順番で処理を行うからです。 このlast_col()の引数を空っぽにするとそれは最後の列を意味します。これを利用すれば、「ある変数の最後の列へ移動させる」こともできます。たとえば、IDを最後の列に移動させたい場合、relocate(ID, .after = last_col())のように書きます。 where(): データ型から変数を選択する 最後に、「numeric型の列のみ抽出したい」、「character型の列だけほしい」場合に便利なwhere()関数を紹介します。where()の中に入る引数は一つだけであり、データ型を判定する関数名が入ります。たとえば、numeric型か否かを判断する関数はis.numericです。dfからnumeric型の変数のみを抽出したい場合は以下のように書きます。 # numeric型の列を抽出する df %&gt;% select(where(is.numeric)) ## # A tibble: 6,292 x 9 ## Zipcode Latitude Longitude Walk Bus Car Budget ScoreN Score ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1040031 35.7 140. 3 NA NA 3000 0 NA ## 2 1100005 35.7 140. 1 NA NA 2000 2 4.5 ## 3 1250041 35.8 140. 2 NA NA 2980 0 NA ## 4 1920904 35.7 139. 1 NA NA 2000 0 NA ## 5 1500042 35.7 140. 7 NA NA 380 0 NA ## 6 1000013 35.7 140. 3 NA NA 2980 0 NA ## 7 1760006 35.7 140. 2 NA NA 850 0 NA ## 8 1010021 35.7 140. 4 NA NA 2000 3 3.33 ## 9 1000006 35.7 140. 1 NA NA 1000 2 2.5 ## 10 1140002 35.8 140. 2 NA NA 2000 0 NA ## # … with 6,282 more rows !を使って条件に合致する列を除外することも可能です。もし、character型の列を除外する場合は以下のように!where(is.character)を指定します。 # character型でない列を抽出する df %&gt;% select(!where(is.character)) ## # A tibble: 6,292 x 9 ## Zipcode Latitude Longitude Walk Bus Car Budget ScoreN Score ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1040031 35.7 140. 3 NA NA 3000 0 NA ## 2 1100005 35.7 140. 1 NA NA 2000 2 4.5 ## 3 1250041 35.8 140. 2 NA NA 2980 0 NA ## 4 1920904 35.7 139. 1 NA NA 2000 0 NA ## 5 1500042 35.7 140. 7 NA NA 380 0 NA ## 6 1000013 35.7 140. 3 NA NA 2980 0 NA ## 7 1760006 35.7 140. 2 NA NA 850 0 NA ## 8 1010021 35.7 140. 4 NA NA 2000 3 3.33 ## 9 1000006 35.7 140. 1 NA NA 1000 2 2.5 ## 10 1140002 35.8 140. 2 NA NA 2000 0 NA ## # … with 6,282 more rows &amp;を使って複数の条件を使うことも可能です。たとえば、ID変数に加えて「\"L\"で始まる変数の中でnumeric型の列を抽出」するコードは以下のようになります。 # IDと、Lで始まるnumeric型の列を抽出する df %&gt;% select(ID, starts_with(&quot;L&quot;) &amp; where(is.numeric)) ## # A tibble: 6,292 x 3 ## ID Latitude Longitude ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 e539604 35.7 140. ## 2 gfeb600 35.7 140. ## 3 ggt5900 35.8 140. ## 4 g181340 35.7 139. ## 5 ggww100 35.7 140. ## 6 gdzk500 35.7 140. ## 7 ga2g202 35.7 140. ## 8 gg9m100 35.7 140. ## 9 gdvk200 35.7 140. ## 10 gggb200 35.8 140. ## # … with 6,282 more rows 10.4 行の抽出 他にも特定の行を抽出する場合があります。多くの場合、「何かの条件と合致するケースのみ抽出する」または、「何かの条件と合致しないケースのみを抽出する」やこれらの組み合わせで行の抽出を行います。そこで登場するのがdplyr()パッケージのfilter()関数です。filter()関数の使い方は以下の通りです。 # dplyr::filter()の使い方 filter(データフレーム名, 条件1, 条件2, ...) むろん、第一引数がデータですから、%&gt;%を使うことも可能です。 # dplyr::filter()の使い方 (パイプを使う方法) データフレーム名 %&gt;% filter(条件1, 条件2, ...) まずは、条件が一つの場合を考えてみましょう。ここでは「Prefが\"京都府\"であるケースのみに絞り、NameとStation、Score列のみを出力する」ケースを考えてみましょう。まず、filter()関数で行を抽出し、続いてselect()関数で抽出する列を指定します。むろん、今回の場合、filter()とselect()の順番は替えても構いません。 # dfからPrefが&quot;京都府&quot;であるケースのみ残し、df2という名で保存 df2 &lt;- df %&gt;% filter(Pref == &quot;京都府&quot;) # df2からName, Station, Score列を抽出 df2 %&gt;% select(Name, Station, Score) ## # A tibble: 414 x 3 ## Name Station Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 中国料理 鳳麟 くいな橋駅 NA ## 2 黒毛和牛一頭買い焼肉と 炊き立て土鍋ご飯 市場小路 烏丸店 四条駅 3.19 ## 3 京の中華 ハマムラ みやこみち店 京都駅 NA ## 4 焼肉処 真 桂店 桂駅 NA ## 5 祇園京都ラーメン 祇園四条駅 NA ## 6 創作料理 串カツ トンカツ jiro 新田辺駅 NA ## 7 祇園 晩餐のあと 祇園四条駅 NA ## 8 DETAIL 東山駅 NA ## 9 めんや龍神 北大路駅 NA ## 10 無尽蔵 京都八条家 京都駅 3.5 ## # … with 404 more rows これはdfからPref == \"京都府\"のケースのみ残したものをdf2として格納し、それをまたselect()関数を使って列を抽出するコードです。これでも問題ありませんが、これだとパイプ演算子の便利さが分かりません。パイプ演算子は複数使うことが可能です。 df %&gt;% filter(Pref == &quot;京都府&quot;) %&gt;% select(Name, Station, Score) ## # A tibble: 414 x 3 ## Name Station Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 中国料理 鳳麟 くいな橋駅 NA ## 2 黒毛和牛一頭買い焼肉と 炊き立て土鍋ご飯 市場小路 烏丸店 四条駅 3.19 ## 3 京の中華 ハマムラ みやこみち店 京都駅 NA ## 4 焼肉処 真 桂店 桂駅 NA ## 5 祇園京都ラーメン 祇園四条駅 NA ## 6 創作料理 串カツ トンカツ jiro 新田辺駅 NA ## 7 祇園 晩餐のあと 祇園四条駅 NA ## 8 DETAIL 東山駅 NA ## 9 めんや龍神 北大路駅 NA ## 10 無尽蔵 京都八条家 京都駅 3.5 ## # … with 404 more rows 全く同じ結果ですが、無駄にdf2というデータフレームを作らず済むので、メモリの観点からも嬉しいですし、何よりコードが短く、しかも可読性も上がりました。 今回は==を使って合致するものに絞りましたが、!=を使って合致しないものに絞ることも可能です。または、比較演算子 (&lt;、&gt;、&gt;=、&lt;=など)を使うことも可能です。それでは、組み込み数 (ScoreN)が0ではないケースを取り出し、Name、Station、ScoreN、Score列を出力させてみましょう。 df %&gt;% filter(ScoreN != 0) %&gt;% select(Name, Station, starts_with(&quot;Score&quot;)) ## # A tibble: 1,344 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 本格上海料理 新錦江 上野御徒町本店 仲御徒町駅 2 4.5 ## 2 宴会個室×餃子酒場 北京飯店 秋葉原本店 秋葉原駅 3 3.33 ## 3 中国料理 宝龍 有楽町駅 2 2.5 ## 4 麺達 うま家 高田馬場駅 2 3 ## 5 刀削麺・火鍋・西安料理 XI’AN（シーアン） 後楽園店 後楽園駅 1 NA ## 6 七志らーめん 渋谷道玄坂店 渋谷駅 7 4.5 ## 7 永楽 京成小岩駅 6 4.42 ## 8 よってこや お台場店 お台場海浜公園駅 1 4 ## 9 ラーメン武藤製麺所 竹ノ塚駅 4 3.5 ## 10 桂花ラーメン 新宿末広店 新宿三丁目駅 8 3 ## # … with 1,334 more rows これで口コミ数が1以上の店舗のみに絞ることができました。ただし、店によっては口コミはあっても、評価 (Score)が付いていないところもあります。たとえば、「刀削麺・火鍋・西安料理 XI’AN（シーアン） 後楽園店」の場合、口コミはありますが、評価はありません。したがって、今回は評価が付いている店舗に絞ってみましょう。 df %&gt;% filter(Score != NA) %&gt;% select(Name, Station, starts_with(&quot;Score&quot;)) ## # A tibble: 0 x 4 ## # … with 4 variables: Name &lt;chr&gt;, Station &lt;chr&gt;, ScoreN &lt;dbl&gt;, Score &lt;dbl&gt; あらら、何の結果も表示されませんでした。これはfilter()内の条件に合致するケースが存在しないことを意味します。しかし、先ほどの結果を見ても、評価が付いている店はいっぱいありましたね。これはなぜでしょう。 察しの良い読者さんは気づいているかと思いますが、第7.8章で説明した通り、NAか否かを判定する際は==や!=は使えません。is.na()を使います。filter(is.na(Score))なら「ScoreがNAであるケースに絞る」ことを意味しますが、今回は「ScoreがNAでないケースに絞る」ことが目的ですので、is.na()の前に!を付けます。 df %&gt;% filter(!is.na(Score)) %&gt;% select(Name, Station, starts_with(&quot;Score&quot;)) ## # A tibble: 1,134 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 本格上海料理 新錦江 上野御徒町本店 仲御徒町駅 2 4.5 ## 2 宴会個室×餃子酒場 北京飯店 秋葉原本店 秋葉原駅 3 3.33 ## 3 中国料理 宝龍 有楽町駅 2 2.5 ## 4 麺達 うま家 高田馬場駅 2 3 ## 5 七志らーめん 渋谷道玄坂店 渋谷駅 7 4.5 ## 6 永楽 京成小岩駅 6 4.42 ## 7 よってこや お台場店 お台場海浜公園駅 1 4 ## 8 ラーメン武藤製麺所 竹ノ塚駅 4 3.5 ## 9 桂花ラーメン 新宿末広店 新宿三丁目駅 8 3 ## 10 北斗 新橋店 新橋駅 4 2.5 ## # … with 1,124 more rows これで口コミ評価が登録された店舗に絞ることができました。 続いて、複数の条件を持つケースを考えてみましょう。例えば、「京都府内の店舗で、口コミ評価が3.5以上の店舗」を出力したい場合、以下のようなコードとなります。 df %&gt;% filter(Pref == &quot;京都府&quot;, Score &gt;= 3.5) %&gt;% select(Name, Station, ScoreN, Score) ## # A tibble: 53 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 無尽蔵 京都八条家 京都駅 2 3.5 ## 2 一蘭 京都河原町店 河原町駅 2 3.75 ## 3 ミスター・ギョーザ 西大路駅 8 4.06 ## 4 一蘭 京都八幡店 樟葉駅 3 4 ## 5 中華料理 清華園 京都駅 3 5 ## 6 まがり &lt;NA&gt; 2 4 ## 7 魁力屋 北山店 北大路駅 2 4.25 ## 8 大中BAL横店 &lt;NA&gt; 7 4.1 ## 9 こうちゃん 西舞鶴駅 1 5 ## 10 大黒ラーメン 伏見桃山駅 4 4.25 ## # … with 43 more rows 条件をfilter()内に追加するだけです。今回は!is.na(Score)は不要です。なぜなら、Score &gt;= 3.5という条件で既に欠損値は対象外になるからです。条件文が複数ある場合、ANDかORかを指定する必要があります。つまり、条件文AとBがある場合、「AとB両方満たすものを出力する」か「AとBどちらかを満たすものを出力するか」を指定する必要があります。今の結果ってANDでしたよね。filter()関数は、別途の指定がない場合、全てAND扱いになります。RのAND演算子は&amp;ですので、以上のコードは以下のコードと同じです。 df %&gt;% filter(Pref == &quot;京都府&quot; &amp; Score &gt;= 3.5) %&gt;% select(Name, Station, ScoreN, Score) ## # A tibble: 53 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 無尽蔵 京都八条家 京都駅 2 3.5 ## 2 一蘭 京都河原町店 河原町駅 2 3.75 ## 3 ミスター・ギョーザ 西大路駅 8 4.06 ## 4 一蘭 京都八幡店 樟葉駅 3 4 ## 5 中華料理 清華園 京都駅 3 5 ## 6 まがり &lt;NA&gt; 2 4 ## 7 魁力屋 北山店 北大路駅 2 4.25 ## 8 大中BAL横店 &lt;NA&gt; 7 4.1 ## 9 こうちゃん 西舞鶴駅 1 5 ## 10 大黒ラーメン 伏見桃山駅 4 4.25 ## # … with 43 more rows AND演算子 (&amp;)が使えるということはOR演算子 (|)も使えることを意味します。たとえば、Stationが\"高田馬場駅\"か\"三田駅\"の条件を指定したい場合、 df %&gt;% filter(Station == &quot;高田馬場駅&quot; | Station == &quot;三田駅&quot;) %&gt;% select(Name, Station, ScoreN, Score) ## # A tibble: 14 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 麺達 うま家 高田馬場駅 2 3 ## 2 らぁ麺 やまぐち 高田馬場駅 7 4.08 ## 3 博多一瑞亭 三田店 三田駅 0 NA ## 4 つけ麺屋 ひまわり 高田馬場駅 4 2.75 ## 5 石器ラーメン 高田馬場 高田馬場駅 0 NA ## 6 旨辛らーめん 表裏 高田馬場駅 0 NA ## 7 三歩一 高田馬場駅 8 4.56 ## 8 えぞ菊 戸塚店 高田馬場駅 4 3.62 ## 9 麺屋 宗 高田馬場駅 5 4.2 ## 10 とんこつラーメン 博多風龍 高田馬場店 高田馬場駅 2 3 ## 11 横浜家系ラーメン 馬場壱家 高田馬場駅 0 NA ## 12 らーめん よし丸 高田馬場駅 1 5 ## 13 札幌ラーメン どさん子 三田店 三田駅 0 NA ## 14 天下一品 三田店 三田駅 0 NA のように書きます（ちなみに高田馬場の「やまぐち」は本当に美味しいです）。むろん、複数の変数を用いたORも可能です。たとえば、「Prefが\"京都府\"かScoreが3以上」のような条件も可能ですが (Pref == \"京都府\" | Score &gt;= 3)、実際、このような例はあまりありません。よく使うのは「変数Xがaかbかcか」のような例です。ただし、この場合は|を使わないもっと簡単な方法があります。それは第9.4章で紹介した%in%演算子です。以下のコードは上のコードと同じものです。 df %&gt;% filter(Station %in% c(&quot;高田馬場駅&quot;, &quot;三田駅&quot;)) %&gt;% select(Name, Station, ScoreN, Score) ## # A tibble: 14 x 4 ## Name Station ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 麺達 うま家 高田馬場駅 2 3 ## 2 らぁ麺 やまぐち 高田馬場駅 7 4.08 ## 3 博多一瑞亭 三田店 三田駅 0 NA ## 4 つけ麺屋 ひまわり 高田馬場駅 4 2.75 ## 5 石器ラーメン 高田馬場 高田馬場駅 0 NA ## 6 旨辛らーめん 表裏 高田馬場駅 0 NA ## 7 三歩一 高田馬場駅 8 4.56 ## 8 えぞ菊 戸塚店 高田馬場駅 4 3.62 ## 9 麺屋 宗 高田馬場駅 5 4.2 ## 10 とんこつラーメン 博多風龍 高田馬場店 高田馬場駅 2 3 ## 11 横浜家系ラーメン 馬場壱家 高田馬場駅 0 NA ## 12 らーめん よし丸 高田馬場駅 1 5 ## 13 札幌ラーメン どさん子 三田店 三田駅 0 NA ## 14 天下一品 三田店 三田駅 0 NA 結局、|が使われるケースがかなり限定されます。あるとすれば、「変数Xがa以下か、b以上か」のようなケースですね。ただし、&amp;と|を同時に使うケースは考えられます。たとえば、大阪駅と京都駅周辺のうまいラーメン屋を調べるとします。問題は美味しさの基準ですが、3.5点以上としましょう。ただし、京都府民はラーメンに非常に厳しく、3点以上なら美味しいと仮定します。この場合、「(Stationが\"大阪駅\"かつScore &gt;= 3.5)、または(Stationが\"京都駅\"かつScore &gt;= 3)」のような条件が必要になります。()は「()の中から判定せよ」という、普通の算数での使い方と同じです。それでは、実際に検索してみましょう。 df %&gt;% filter((Station == &quot;大阪駅&quot; &amp; Score &gt;= 3.5) | (Station == &quot;京都駅&quot; &amp; Score &gt;= 3)) %&gt;% select(Name, Station, Walk, ScoreN, Score) ## # A tibble: 6 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Lei can ting 大阪ルクア店 大阪駅 3 3 4 ## 2 神座 ルクア大阪店 大阪駅 1 10 3.94 ## 3 みつか坊主 醸 大阪駅 10 4 5 ## 4 無尽蔵 京都八条家 京都駅 5 2 3.5 ## 5 中華料理 清華園 京都駅 10 3 5 ## 6 ますたに 京都拉麺小路店 京都駅 9 3 3.67 Songが大好きな神座がヒットして嬉しいです。 10.5 行のソート 続いて、行のソートについて解説します。「食べログ」などのレビューサービスを利用する場合、口コミ評価が高い順で見るのが一般的でしょう2。また、サッカーのランキングも多くは1位から下の順位で掲載されるのが一般的です。ここではこのようにある変数の値順に行を並び替える方法について説明します。 ソートにはdplyrパッケージのarrange()関数を使います。引数は変数名のみです。たとえば、奈良県のラーメン屋を検索してみましょう。並び替える順は駅から近い店舗を上位に、遠い店舗を下位に並べます。このような順は昇順 (ascending)と呼ばれ、ランキング表などでよく見ます。駅から近い順にソートするので、まず最寄りの駅情報が欠損でないことが必要です。また、ラーメン屋の評価も気になるので口コミが1つ以上付いている店舗に絞りましょう。表示する列は店舗名、最寄りの駅、徒歩距離、口コミ数、点数です。 df %&gt;% filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;% select(Name, Station, Walk, ScoreN, Score) %&gt;% arrange(Walk) %&gt;% print(n = Inf) ## # A tibble: 24 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 麺屋 あまのじゃく 本店 富雄駅 2 2 4.5 ## 2 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅 4 1 4 ## 3 ラーメン家 みつ葉 富雄駅 4 1 3.5 ## 4 天下一品 新大宮店 新大宮駅 6 1 3 ## 5 麺屋 一徳 天理駅 7 1 3 ## 6 丸源ラーメン 橿原店 金橋駅 8 1 3.5 ## 7 らーめん食堂 よってこや 平群店 元山上口駅 10 1 4 ## 8 天理スタミナラーメン本店 櫟本駅 11 2 3.25 ## 9 博多長浜らーめん夢街道 奈良土橋店 真菅駅 11 1 3.5 ## 10 ぶ～け 奈良駅 11 1 5 ## 11 つけめん らーめん元喜神 押熊店 学研奈良登美ヶ丘駅 12 4 4.12 ## 12 彩華ラーメン 本店 前栽駅 12 5 3.6 ## 13 力皇 天理駅 13 1 3.5 ## 14 らーめん きみちゃん 京終駅 14 2 4.5 ## 15 無鉄砲がむしゃら 帯解駅 15 2 4 ## 16 彩華ラーメン 田原本店 石見駅 15 1 4 ## 17 神座 大和高田店 大和高田駅 17 2 3.75 ## 18 彩華ラーメン 奈良店 尼ヶ辻駅 17 3 4.33 ## 19 彩華ラーメン 桜井店 大福駅 18 1 3 ## 20 天下一品 東生駒店 東生駒駅 19 1 3.5 ## 21 まりお流ラーメン 新大宮駅 20 1 5 ## 22 どうとんぼり神座 奈良柏木店 西ノ京駅 22 1 3 ## 23 河童ラーメン本舗 押熊店 学研奈良登美ヶ丘駅 28 1 4 ## 24 博多長浜らーめん 夢街道 四条大路店 新大宮駅 29 4 2.88 3行まではこれまで習ってきたもので、4行目がソートの関数、arrange()です。引数はソートの基準となる変数で、今回は最寄りの駅からの徒歩距離を表すWalkです。5行目は省略可能ですが、tibbleクラスの場合、10行までしか出力されないので、print(n = Inf)で「すべての行を表示」させます。nを指定することで出力される行数が調整可能です。奈良県のラーメン屋の中で最寄りの駅から最も近い店は「麺屋 あまのじゃく 本店」で徒歩2分でした。京田辺店も駅から約2分ですし、近いですね。ちなみにSongはここの塩とんこつが好きです。世界一こってりなラーメンとも言われる「チョモランマ」で有名な「まりお流ラーメン」は新大宮駅から徒歩20分でかなり遠いことが分かります。 続いて、駅からの距離ではなく、評価が高い順にしてみましょう。評価が高いほど上に来るので、今回は昇順でなく、降順 (descending)でソートする必要があります。arrange()関数は基本的に、指定された変数を基準に昇順でソートします。降順にするためにはdesc()関数を更に用います。たとえば、arrange(desc(変数名))のようにです。それでは実際にやってみましょう。上のコードの4行目をarange(Walk)からarrange(desc(Score))にちょっと修正するだけです。 df %&gt;% filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;% select(Name, Station, Walk, ScoreN, Score) %&gt;% arrange(desc(Score)) %&gt;% print(n = Inf) ## # A tibble: 24 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 まりお流ラーメン 新大宮駅 20 1 5 ## 2 ぶ～け 奈良駅 11 1 5 ## 3 麺屋 あまのじゃく 本店 富雄駅 2 2 4.5 ## 4 らーめん きみちゃん 京終駅 14 2 4.5 ## 5 彩華ラーメン 奈良店 尼ヶ辻駅 17 3 4.33 ## 6 つけめん らーめん元喜神 押熊店 学研奈良登美ヶ丘駅 12 4 4.12 ## 7 河童ラーメン本舗 押熊店 学研奈良登美ヶ丘駅 28 1 4 ## 8 無鉄砲がむしゃら 帯解駅 15 2 4 ## 9 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅 4 1 4 ## 10 彩華ラーメン 田原本店 石見駅 15 1 4 ## 11 らーめん食堂 よってこや 平群店 元山上口駅 10 1 4 ## 12 神座 大和高田店 大和高田駅 17 2 3.75 ## 13 彩華ラーメン 本店 前栽駅 12 5 3.6 ## 14 天下一品 東生駒店 東生駒駅 19 1 3.5 ## 15 力皇 天理駅 13 1 3.5 ## 16 博多長浜らーめん夢街道 奈良土橋店 真菅駅 11 1 3.5 ## 17 ラーメン家 みつ葉 富雄駅 4 1 3.5 ## 18 丸源ラーメン 橿原店 金橋駅 8 1 3.5 ## 19 天理スタミナラーメン本店 櫟本駅 11 2 3.25 ## 20 麺屋 一徳 天理駅 7 1 3 ## 21 どうとんぼり神座 奈良柏木店 西ノ京駅 22 1 3 ## 22 彩華ラーメン 桜井店 大福駅 18 1 3 ## 23 天下一品 新大宮店 新大宮駅 6 1 3 ## 24 博多長浜らーめん 夢街道 四条大路店 新大宮駅 29 4 2.88 よく考えてみれば、「評価が同点の場合、どうなるの?」と疑問を抱く方がいるかも知れません。たとえば、7行目の「河童ラーメン本舗 押熊店」と8行目の「無鉄砲がむしゃら」はどれも評価が4点ですが、「河童ラーメン本舗 押熊店」が先に表示されます。そのこれは簡単です。同点の場合、データセット内で上に位置する行が先に表示されます。これを確認するにはwhich()関数を使います。()内に条件文を指定することで、この条件に合致する要素の位置を返します。もし、条件に合致するものが複数あった場合は全ての位置を返します3。 which(df$Name == &quot;河童ラーメン本舗 押熊店&quot;) ## [1] 6021 which(df$Name == &quot;無鉄砲がむしゃら&quot;) ## [1] 6040 データ内に「河童ラーメン本舗 押熊店」がより上に位置することが分かります。「もし同点なら口コミ評価数が多いところにしたい」場合はどうすれば良いでしょうか。これはarrange()内に変数名を足すだけで十分です。 df %&gt;% filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;% select(Name, Station, Walk, ScoreN, Score) %&gt;% arrange(desc(Score), desc(ScoreN)) %&gt;% print(n = Inf) ## # A tibble: 24 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 まりお流ラーメン 新大宮駅 20 1 5 ## 2 ぶ～け 奈良駅 11 1 5 ## 3 麺屋 あまのじゃく 本店 富雄駅 2 2 4.5 ## 4 らーめん きみちゃん 京終駅 14 2 4.5 ## 5 彩華ラーメン 奈良店 尼ヶ辻駅 17 3 4.33 ## 6 つけめん らーめん元喜神 押熊店 学研奈良登美ヶ丘駅 12 4 4.12 ## 7 無鉄砲がむしゃら 帯解駅 15 2 4 ## 8 河童ラーメン本舗 押熊店 学研奈良登美ヶ丘駅 28 1 4 ## 9 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅 4 1 4 ## 10 彩華ラーメン 田原本店 石見駅 15 1 4 ## 11 らーめん食堂 よってこや 平群店 元山上口駅 10 1 4 ## 12 神座 大和高田店 大和高田駅 17 2 3.75 ## 13 彩華ラーメン 本店 前栽駅 12 5 3.6 ## 14 天下一品 東生駒店 東生駒駅 19 1 3.5 ## 15 力皇 天理駅 13 1 3.5 ## 16 博多長浜らーめん夢街道 奈良土橋店 真菅駅 11 1 3.5 ## 17 ラーメン家 みつ葉 富雄駅 4 1 3.5 ## 18 丸源ラーメン 橿原店 金橋駅 8 1 3.5 ## 19 天理スタミナラーメン本店 櫟本駅 11 2 3.25 ## 20 麺屋 一徳 天理駅 7 1 3 ## 21 どうとんぼり神座 奈良柏木店 西ノ京駅 22 1 3 ## 22 彩華ラーメン 桜井店 大福駅 18 1 3 ## 23 天下一品 新大宮店 新大宮駅 6 1 3 ## 24 博多長浜らーめん 夢街道 四条大路店 新大宮駅 29 4 2.88 ソートの基準はarrange()内において先に指定された変数の順番となります。「口コミ評価も評価数も同じなら、駅から近いところにしたい」場合は変数が3つとなり、Score、ScoreN、Walkの順で入れます。 df %&gt;% filter(Pref == &quot;奈良県&quot;, !is.na(Station), ScoreN &gt; 0) %&gt;% select(Name, Station, Walk, ScoreN, Score) %&gt;% arrange(desc(Score), desc(ScoreN), Walk) %&gt;% print(n = Inf) ## # A tibble: 24 x 5 ## Name Station Walk ScoreN Score ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ぶ～け 奈良駅 11 1 5 ## 2 まりお流ラーメン 新大宮駅 20 1 5 ## 3 麺屋 あまのじゃく 本店 富雄駅 2 2 4.5 ## 4 らーめん きみちゃん 京終駅 14 2 4.5 ## 5 彩華ラーメン 奈良店 尼ヶ辻駅 17 3 4.33 ## 6 つけめん らーめん元喜神 押熊店 学研奈良登美ヶ丘駅 12 4 4.12 ## 7 無鉄砲がむしゃら 帯解駅 15 2 4 ## 8 紀州和歌山らーめんきぶんや 奈良富雄店 富雄駅 4 1 4 ## 9 らーめん食堂 よってこや 平群店 元山上口駅 10 1 4 ## 10 彩華ラーメン 田原本店 石見駅 15 1 4 ## 11 河童ラーメン本舗 押熊店 学研奈良登美ヶ丘駅 28 1 4 ## 12 神座 大和高田店 大和高田駅 17 2 3.75 ## 13 彩華ラーメン 本店 前栽駅 12 5 3.6 ## 14 ラーメン家 みつ葉 富雄駅 4 1 3.5 ## 15 丸源ラーメン 橿原店 金橋駅 8 1 3.5 ## 16 博多長浜らーめん夢街道 奈良土橋店 真菅駅 11 1 3.5 ## 17 力皇 天理駅 13 1 3.5 ## 18 天下一品 東生駒店 東生駒駅 19 1 3.5 ## 19 天理スタミナラーメン本店 櫟本駅 11 2 3.25 ## 20 天下一品 新大宮店 新大宮駅 6 1 3 ## 21 麺屋 一徳 天理駅 7 1 3 ## 22 彩華ラーメン 桜井店 大福駅 18 1 3 ## 23 どうとんぼり神座 奈良柏木店 西ノ京駅 22 1 3 ## 24 博多長浜らーめん 夢街道 四条大路店 新大宮駅 29 4 2.88 10.6 記述統計量の計算 10.6.1 summarise()による記述統計料の計算 ある変数の平均値や標準偏差、最小値、最大値などの記述統計量 (要約統計量)を計算することも可能です。これはsummarize()またはsummarise()関数を使いますが、この関数は後で紹介するgroup_by()関数と組み合わせることで力を発揮します。ここではグルーピングを考えずに、全データの記述統計量を計算する方法を紹介します。 summarise()関数の使い方は以下の通りです。 # summarise()関数の使い方 データフレーム名 %&gt;% summarise(新しい変数名 = 関数名(計算の対象となる変数名)) もし、Score変数の平均値を計算し、その結果をMeanという列にしたい場合は以下のようなコードになります。 df %&gt;% summarise(Mean = mean(Score)) ## # A tibble: 1 x 1 ## Mean ## &lt;dbl&gt; ## 1 NA ただし、mean()関数は欠損値が含まれるベクトルの場合、NAを返します。この場合方法は2つ考えられます。 filter()関数を使ってScoreが欠損しているケースを予め除去する。 na.rm引数を指定し、欠損値を除去した平均値を求める。 ここでは2番目の方法を使います。 df %&gt;% summarise(Mean = mean(Score, na.rm = TRUE)) ## # A tibble: 1 x 1 ## Mean ## &lt;dbl&gt; ## 1 3.66 dfのScore変数の平均値はNAであることが分かります。また、summarise()関数は複数の記述統計量を同時に計算することも可能です。以下はScore変数の平均値、中央値、標準偏差、最小値、最大値、第一四分位点、第三四分位点を計算し、Score.Descという名のデータフレームに格納するコードです。 Score.Desc &lt;- df %&gt;% summarize(Mean = mean(Score, na.rm = TRUE), # 平均値 Median = median(Score, na.rm = TRUE), # 中央値 SD = sd(Score, na.rm = TRUE), # 標準偏差 Min = min(Score, na.rm = TRUE), # 最小値 Max = max(Score, na.rm = TRUE), # 最大値 Q1 = quantile(Score, 0.25, na.rm = TRUE), # 第一四分位点 Q3 = quantile(Score, 0.75, na.rm = TRUE)) # 第三四分位点 Score.Desc ## # A tibble: 1 x 7 ## Mean Median SD Min Max Q1 Q3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3.66 3.58 0.719 1 5 3 4 むろん、複数の変数に対して記述統計量を計算することも可能です。たとえば、平均予算 (Budget)、口コミ数 (ScoreN)、口コミ評価 (Score)の平均値を求めるとしたら、 df %&gt;% summarize(Budget_Mean = mean(Budget, na.rm = TRUE), # 平均予算の平均値 SocreN_Mean = mean(ScoreN, na.rm = TRUE), # 口コミ数の平均値 Score_Mean = mean(Score, na.rm = TRUE)) # 評価の平均値 ## # A tibble: 1 x 3 ## Budget_Mean SocreN_Mean Score_Mean ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1232. 0.537 3.66 のように書きます。実はsummarise()はこれくらいで十分便利です。ただし、以上の操作はもっと簡単なコードに置換できます。ただし、ラムダ式など、やや高度な内容になるため、以下の内容は飛ばして、次の節 (グルーピング)を読んでいただいても構いません。 まずは、複数の変数に対して同じ記述統計量を求める例を考えてみましょう。たとえば、Budget、ScoreN、Scoreに対して平均値を求める例です。これはacross()関数を使うとよりコードが短くなります。まずはacross()関数の書き方から見ましょう。 # across()の使い方 データフレーム名 %&gt;% summarise(across(変数名のベクトル, 記述統計を計算する関数名, 関数の引数)) 変数名のベクトルは長さ1以上のベクトルです。たとえば、Budget、ScoreN、Scoreの場合c(Budget, ScoreN, Score)になります。これはdf内で隣接する変数ですからBudget:Scoreの書き方も使えます。また、where()やany_of()、starts_with()のような関数を使って変数を指定することも可能です。関数名はmeanやsdなどの関数名です。ここは関数名()でななく、関数名であることに注意してください。引数は前の関数に必要な引数です。引数を必要としない関数なら省略可能ですが、na.rm = TRUEなどの引数が必要な場合は指定する必要があります。それではBudget、ScoreN、Scoreの平均値を計算してみましょう。 df %&gt;% summarize(across(Budget:Score, mean, na.rm = TRUE)) ## # A tibble: 1 x 3 ## Budget ScoreN Score ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1232. 0.537 3.66 across()使わない場合、4行必要だったコードが2行になりました。変数が少ない場合はacross()を使わない方が、可読性が高くなる場合もあります。しかし、変数が多くなる場合、可読性がやや落ちてもacross()を使った方が効率的でしょう。 次は、ある変数に対して複数の記述統計量を計算したい場合について考えます。Budget、ScoreN、Score変数の第一四分位点と第三四分位点をacross()を使わずに計算すると家のような7行のコードになります。 df %&gt;% summarize(Budget_Q1 = quantile(Budget, 0.25, na.rm = TRUE), Budget_Q3 = quantile(Budget, 0.75, na.rm = TRUE), ScoreN_Q1 = quantile(ScoreN, 0.25, na.rm = TRUE), ScoreN_Q3 = quantile(ScoreN, 0.75, na.rm = TRUE), Score_Q1 = quantile(Score, 0.25, na.rm = TRUE), Score_Q3 = quantile(Score, 0.75, na.rm = TRUE)) ## # A tibble: 1 x 6 ## Budget_Q1 Budget_Q3 ScoreN_Q1 ScoreN_Q3 Score_Q1 Score_Q3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 800 1000 0 0 3 4 この作業もacross()を使ってより短縮することができます。ここではラムダ式の知識が必要になります。ラムダ関数とは関数名を持たない無名関数 (anonymous functions)を意味しますが、詳細は割愛します。興味のある読者はWikipediaなどを参照してください。簡単にいうとその場で即席に関数を作成し、計算が終わったら破棄する関数です。ただ、Rは基本的にラムダ式を提供しているのではなく、purrrパッケージのラムダ式スタイルを使用します。まずは、書き方から確認します。 # ラムダ式を用いたacross()の使い方 データフレーム名 %&gt;% summarise(across(変数名のベクトル, list(結果の変数名 = ラムダ式))) 先ほどの書き方と似ていますが、関数を複数書く必要があるため、今回は関数名をlist型にまとめます。そして、結果の変数名は結果として出力されるデータフレームの列名を指定する引数です。たとえば、Meanにすると結果は元の変数名1_Mean、元の変数名2_Mean…のように出力されます。そして、ラムダ式が実際の関数が入る箇所です。とりあえず今回はコードを走らせ、結果から確認してみましょう。 df %&gt;% summarize(across(Budget:Score, list(Q1 = ~quantile(.x, 0.25, na.rm = TRUE), Q3 = ~quantile(.x, 0.75, na.rm = TRUE)))) ## # A tibble: 1 x 6 ## Budget_Q1 Budget_Q3 ScoreN_Q1 ScoreN_Q3 Score_Q1 Score_Q3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 800 1000 0 0 3 4 結果の列名がBudget_Q1、Budget_Q3、ScoreN_Q1…のようになり、それぞれの変数の第一四分位点と第三四分位点が出力されます。問題はラムダ式の方ですが、普通の関数に非常に近いことが分かります。across()内のラムダ式は~関数名(.x, その他の引数)のような書き方になります。関数名の前に~が付いていることに注意してください。分位数を求める関数はquantile()であり、quantile(ベクトル, 分位数)であり、必要に応じてna.rmを付けます。この分位数が0.25なら第一四分位点、0.5なら第二四分位点 (=中央値)、0.75なら第三四分位点になります。それではラムダ式~quantile(.x, 0.25, na.rm = TRUE)はどういう意味でしょうか。これは.xの箇所にBudgetやScoreN、Scoreが入ることを意味します。.xという書き方は決まりです。.yとか.Song-san-Daisukiなどはダメです。そして、0.25を付けることによって第一四分位点を出力するように指定します。また、Budget、ScoreN、Scoreに欠損値がある場合、無視するようにna.rm = TRUEを付けます。 ラムダ式を第9章で解説した自作関数で表現すると、以下のようになります。 # 以下の3つは同じ機能をする関数である # ラムダ式 ~quantile(.x, 0.25, na.rm = TRUE) # 一般的な関数の書き方1 名無し関数 &lt;- function(x) { quantile(x, 0.25, na.rm = TRUE) } # 一般的な関数の書き方2 名無し関数 &lt;- function(x) quantile(x, 0.25, na.rm = TRUE) この3つは全て同じですが、ラムダ式は関数名を持たず、その場で使い捨てる関数です。むろん、ラムダ式を使わずに事前に第一四分位点と第三四分位点を求める関数を予め作成し、ラムダ式の代わりに使うことも可能です。まずは第一四分位点と第三四分位点を求める自作関数FuncQ1とFuncQ2を作成します。 # ラムダ式を使わない場合は事前に関数を定義しておく必要がある FuncQ1 &lt;- function(x) { quantile(x, 0.25, na.rm = TRUE) } FuncQ3 &lt;- function(x) { quantile(x, 0.75, na.rm = TRUE) } 後は先ほどのほぼ同じ書き方ですが、今回はラムダ式を使わないため関数名に~を付けず、関数名のみで十分です。 # やっておくと、summarise()文は簡潔になる df %&gt;% summarize(across(Budget:Score, list(Q1 = FuncQ1, Q3 = FuncQ3))) ## # A tibble: 1 x 6 ## Budget_Q1 Budget_Q3 ScoreN_Q1 ScoreN_Q3 Score_Q1 Score_Q3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 800 1000 0 0 3 4 事前に関数を用意するのが面倒ですが、across()の中身はかなりスッキリしますね。もし、このような作業を何回も行うなら、ラムダ式を使わず、自作関数を用いることも可能です。ただし、自作関数であっても引数が2つ以上必要な場合はラムダ式を使います。 10.6.2 summarise()に使える便利な関数 以下の内容は後で説明するgroup_by()関数を使っているため、まだgroup_by()に馴染みのない読者はまずはここを読み飛ばし、グルーピングの節にお進みください。 IQR(): 四分位範囲を求める 四分位範囲は第三四分位点から第一四分位点を引いた値であり、Rの内蔵関数であるIQR()を使えば便利です。この関数はmeanやsd()関数と同じ使い方となります。 df %&gt;% filter(!is.na(Walk)) %&gt;% # 予め欠損したケースを除くと、後でna.rm = TRUEが不要 group_by(Pref) %&gt;% summarise(Mean = mean(Walk), SD = sd(Walk), IQR = IQR(Walk), N = n(), .groups = &quot;drop&quot;) %&gt;% arrange(Mean) ## # A tibble: 9 x 5 ## Pref Mean SD IQR N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 東京都 4.29 4.49 4 919 ## 2 大阪府 5.92 6.08 6 932 ## 3 神奈川県 8.21 7.91 10 878 ## 4 京都府 8.38 6.95 9 339 ## 5 兵庫県 8.52 7.27 10 484 ## 6 奈良県 10.6 6.59 10 123 ## 7 千葉県 10.6 8.21 12 776 ## 8 埼玉県 11.6 8.99 14 817 ## 9 和歌山県 12.8 6.83 9 107 first()、last()、nth(): n番目の要素を求める 稀なケースかも知れませんが、データ内、またはグループ内のn番目の行を抽出する時があります。たとえば、市区町村の情報が格納されているデータセットで、人口が大きい順でデータがソートされているとします。各都道府県ごとに最も人口が大きい市区町村のデータ、あるいは最も少ない市区町村のデータが必要な際、first()とlast()関数が有効です。 それでは各都道府県ごとに「最も駅から遠いラーメン屋」の店舗名と最寄りの駅からの徒歩距離を出力したいとします。まずは、徒歩距離のデータが欠損しているケースを除去し、データを徒歩距離順でソートします。これはfilter()とarrange()関数を使えば簡単です。続いて、group_by()を使って都府県単位でデータをグループ化します。最後にsummarise()関数内にlast()関数を使います。データは駅から近い順に鳴っているため、各都府県内の最後の行は駅から最も遠い店舗になるからです。 df %&gt;% filter(!is.na(Walk)) %&gt;% arrange(Walk) %&gt;% group_by(Pref) %&gt;% summarise(Farthest = last(Name), Distance = last(Walk)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 9 x 3 ## Pref Farthest Distance ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 京都府 熱烈らぁめん 30 ## 2 埼玉県 札幌ラーメン どさん子 小鹿野店 116 ## 3 神奈川県 札幌ラーメン どさん子 中津店 73 ## 4 千葉県 札幌ラーメン どさん子 佐原51号店 59 ## 5 大阪府 河童ラーメン本舗 岸和田店 38 ## 6 東京都 てんがら 青梅新町店 30 ## 7 奈良県 博多長浜らーめん 夢街道 四条大路店 29 ## 8 兵庫県 濃厚醤油 中華そば いせや 玉津店 43 ## 9 和歌山県 中華そば まる乃 30 このlast()をfirst()に変えると、最寄りの駅から最も近い店舗情報が表示されます。また、「n番目の情報」が必要な際はnth()関数を使います。nth(Name, 2)に変えることで2番目の店舗名が抽出できます。 n_distinct(): ユニーク値の個数を求める n_distinct()は何種類の要素が含まれているかを計算する関数であり、length(unique())関数と同じ機能をします。たとえば、以下のmyVec1に対して何種類の要素があるかを確認してみましょう。 myVec1 &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;D&quot;, &quot;A&quot;, &quot;B&quot;, &quot;D&quot;, &quot;C&quot;, &quot;A&quot;) unique(myVec1) ## [1] &quot;A&quot; &quot;B&quot; &quot;D&quot; &quot;C&quot; myVec1は\"A\"、\"B\"、\"D\"、\"C\"の要素で構成されていることが分かります。これがmyVec1のユニーク値 (unique values)です。そして、このユニーク値の個数を調べるためにlength()を使います。 length(unique(myVec1)) ## [1] 4 これでmyVec1は4種類の値が存在することが分かります。これと全く同じ機能をする関数がn_distinct()です。 n_distinct(myVec1) ## [1] 4 この関数をsummarise()に使うことで、都府県ごとに駅の個数が分かります。あるいは「東京都内の選挙区に、これまでの衆院選において何人の候補者が存在したか」も分かります。ここではdf内の都府県ごとに駅の個数を計算してみましょう。最後の駅数が多い順でソートします。 df %&gt;% filter(!is.na(Station)) %&gt;% # 最寄りの駅が欠損しているケースを除去 group_by(Pref) %&gt;% summarise(N_Station = n_distinct(Station), .groups = &quot;drop&quot;) %&gt;% arrange(desc(N_Station)) ## # A tibble: 9 x 2 ## Pref N_Station ## &lt;chr&gt; &lt;int&gt; ## 1 東京都 368 ## 2 大阪府 341 ## 3 千葉県 241 ## 4 神奈川県 240 ## 5 兵庫県 199 ## 6 埼玉県 185 ## 7 京都府 123 ## 8 奈良県 52 ## 9 和歌山県 46 当たり前かも知れませんが、駅数が最も多いのは東京都で次が大阪府であることが分かります。 any()、all(): 条件に合致するか否かを求める any()とall()はベクトル内の全要素に対して条件に合致するか否かを判定する関数です。ただし、any()は一つの要素でも条件に合致すればTRUEを、全要素が合致しない場合FALSEを返します。一方、all()は全要素に対して条件を満たせばTRUE、一つでも満たさない要素があればFALSEを返します。以下はany()とall()の例です。 myVec1 &lt;- c(1, 2, 3, 4, 5) myVec2 &lt;- c(1, 3, 5, 7, 11) any(myVec1 %% 2 == 0) # myVec1を2で割った場合、一つでも余りが0か ## [1] TRUE all(myVec1 %% 2 == 0) # myVec1を2で割った場合、全ての余りが0か ## [1] FALSE all(myVec2 %% 2 != 0) # myVec2を2で割った場合、全ての余りが0ではないか ## [1] TRUE それでは実際にdfに対してany()とall()関数を使ってみましょう。一つ目は「ある都府県に最寄りの駅から徒歩60分以上の店舗が一つでもあるか」であり、二つ目は「ある都府県の店舗は全て最寄りの駅から徒歩30分以下か」です。それぞれの結果をOver60とWithin30という列で出力してみましょう。 df %&gt;% group_by(Pref) %&gt;% summarise(Over60 = any(Walk &gt;= 60, na.rm = TRUE), Within30 = all(Walk &lt;= 30, na.rm = TRUE), .groups = &quot;drop&quot;) ## # A tibble: 9 x 3 ## Pref Over60 Within30 ## &lt;chr&gt; &lt;lgl&gt; &lt;lgl&gt; ## 1 京都府 FALSE TRUE ## 2 埼玉県 TRUE FALSE ## 3 神奈川県 TRUE FALSE ## 4 千葉県 FALSE FALSE ## 5 大阪府 FALSE FALSE ## 6 東京都 FALSE TRUE ## 7 奈良県 FALSE TRUE ## 8 兵庫県 FALSE FALSE ## 9 和歌山県 FALSE TRUE 埼玉県と神奈川県において、最寄りの駅から徒歩60以上の店がありました。また、京都府、東京都、奈良県、和歌山県の場合、全店舗が最寄りの駅から徒歩30分以下ということが分かります。当たり前ですがOver60がTRUEならWithin30は必ずFALSEになりますね。 10.7 グルーピング 10.7.1 group_by()によるグループ化 先ほどのsummarise()関数は確かに便利ですが、特段に便利とも言いにくいです。dfのScoreの平均値を計算するだけなら、summarise()関数を使わない方が楽です。 # これまでのやり方 df %&gt;% summarise(Mean = mean(Score, na.rm = TRUE)) ## # A tibble: 1 x 1 ## Mean ## &lt;dbl&gt; ## 1 3.66 # 普通にこれでええんちゃう? mean(df$Score, na.rm = TRUE) ## [1] 3.663457 しかし、これをグループごとに計算するならどうでしょう。たとえば、Scoreの平均値を都府県ごとに計算するとします。この場合、以下のようなコードになります。 mean(df$Score[df$Pref == &quot;東京都&quot;], na.rm = TRUE) ## [1] 3.674256 mean(df$Score[df$Pref == &quot;神奈川県&quot;], na.rm = TRUE) ## [1] 3.533931 mean(df$Score[df$Pref == &quot;千葉県&quot;], na.rm = TRUE) ## [1] 3.715983 mean(df$Score[df$Pref == &quot;埼玉県&quot;], na.rm = TRUE) ## [1] 3.641573 mean(df$Score[df$Pref == &quot;大阪府&quot;], na.rm = TRUE) ## [1] 3.765194 mean(df$Score[df$Pref == &quot;京都府&quot;], na.rm = TRUE) ## [1] 3.684976 mean(df$Score[df$Pref == &quot;兵庫県&quot;], na.rm = TRUE) ## [1] 3.543936 mean(df$Score[df$Pref == &quot;奈良県&quot;], na.rm = TRUE) ## [1] 3.854762 mean(df$Score[df$Pref == &quot;和歌山県&quot;], na.rm = TRUE) ## [1] 3.96999 変わったのはdf$Scoreがdf$Score[df$Pref == \"東京都\"]に変わっただけです。df$Prefが\"東京都\"であるか否かをTRUEとFALSEで判定し、これを基準にdf$Scoreを抽出する仕組みです。df$Scoreとdf$Prefは同じデータフレームですから、このような書き方で問題ありません。 これだけでもかなり書くのが面倒ですが、これが47都道府県なら、あるいは200ヶ国ならかなり骨の折れる作業でしょう。ここで大活躍するのがdplyrパッケージのgroup_by()関数です。引数はグループ化する変数名だけです。先ほどの作業をdplyrを使うならPref変数でグループ化し、summarise()関数で平均値を求めるだけです。今回はScoreだけでなく、ScoreNの平均値も求めてみましょう。そして、評価が高い順にソートもしてみます。 # ScoreNとScoreの平均値をPrefごとに求める df %&gt;% group_by(Pref) %&gt;% summarise(ScoreN_Mean = mean(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE)) %&gt;% arrange(desc(Score_Mean)) ## `summarise()` ungrouping output (override with `.groups` argument) ## # A tibble: 9 x 3 ## Pref ScoreN_Mean Score_Mean ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 和歌山県 0.593 3.97 ## 2 奈良県 0.306 3.85 ## 3 大阪府 0.516 3.77 ## 4 千葉県 0.259 3.72 ## 5 京都府 0.522 3.68 ## 6 東京都 1.16 3.67 ## 7 埼玉県 0.278 3.64 ## 8 兵庫県 0.389 3.54 ## 9 神奈川県 0.587 3.53 評判が最も高い都府県は和歌山県、最も低いのは神奈川県ですね。Songも和歌山ラーメンは井出系も車庫前系も好きです。しかし、大事なのは「井出系」と「車庫前系」といった分類が正しいかどうかではありません。コードが非常に簡潔となり、ソートなども自由自在であることです。都府県ごとにScoreNとScoreの平均値を求める場合、dplyr()を使わなかったら18行のコードとなり、ソートも自分でやる必要があります。一方、group_by()関数を使うことによってコードが5行になりました。 また、これは2020年6月に公開されたdplyr1.0.0からの問題ですが、group_by()の後にsummarise()を使うと以下のようなメッセージが出力されます。 ## `summarise()` ungrouping output (override with `.groups` argument) これはgroup_by()で指定された変数のグループ化が自動的に解除されたことを意味します。なぜならsummarise()をする際はPrefをグループ変数として使いましたが、出力された結果のPref変数はもはやグループとして機能できなくなるからです。元のdfにはPrefが\"東京都\"だったケースが1000行、\"京都府\"だったのが414行あったので、Pref変数でグループ化する意味がありました。しかし、summarise()から得られたデータフレームはPref == \"東京都\"の行が1つしかありません。これはグループ化する意味がなくなったことを意味します。したがって、自動的にグループを解除してくれます。自動的にやってくれるのはありがたいことですが、可能ならば関数内に自分で明記することが推奨されます。そこで使う引数が.groupsであり、\"drop\"を指定すると全てのグループ化変数を解除します。以下のようなコードだと先ほどのメッセージが表示されません。今後、意識的に入れるようにしましょう。 # ScoreNとScoreの平均値をPrefごとに求める df %&gt;% group_by(Pref) %&gt;% summarise(ScoreN_Mean = mean(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(desc(Score_Mean)) ## # A tibble: 9 x 3 ## Pref ScoreN_Mean Score_Mean ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 和歌山県 0.593 3.97 ## 2 奈良県 0.306 3.85 ## 3 大阪府 0.516 3.77 ## 4 千葉県 0.259 3.72 ## 5 京都府 0.522 3.68 ## 6 東京都 1.16 3.67 ## 7 埼玉県 0.278 3.64 ## 8 兵庫県 0.389 3.54 ## 9 神奈川県 0.587 3.53 続いて、一つ便利な関数を紹介します。それはグループのサイズを計算する関数、n()です。この関数をsummarise()内に使うと、各グループに属するケース数を出力します。先ほどのコードを修正し、各グループのサイズをNという名の列として追加してみましょう。そしてソートの順番はNを最優先とし、同じ場合はScore_Meanが高い方を上に出力させます。また、ScoreN_Meanの前に、口コミ数の合計も出してみましょう。 # Prefごとに口コミ数の合計、口コミ数の平均値、評価の平均値、店舗数を求める # 店舗数-評価の平均値順でソートする df %&gt;% group_by(Pref) %&gt;% summarise(ScoreN_Sum = sum(ScoreN, na.rm = TRUE), ScoreN_Mean = mean(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), N = n(), .groups = &quot;drop&quot;) %&gt;% arrange(desc(N), desc(Score_Mean)) ## # A tibble: 9 x 5 ## Pref ScoreN_Sum ScoreN_Mean Score_Mean N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 大阪府 516 0.516 3.77 1000 ## 2 千葉県 259 0.259 3.72 1000 ## 3 東京都 1165 1.16 3.67 1000 ## 4 埼玉県 278 0.278 3.64 1000 ## 5 神奈川県 587 0.587 3.53 1000 ## 6 兵庫県 230 0.389 3.54 591 ## 7 京都府 216 0.522 3.68 414 ## 8 奈良県 45 0.306 3.85 147 ## 9 和歌山県 83 0.593 3.97 140 記述統計をグループごとに求めるのは普通にあり得るケースですし、実験データの場合はほぼ必須の作業でう。統制群と処置群間においてグループサイズが均一か、共変量のバラツキが十分に小さいかなどを判断する際にgroup_by()とsummarise()関数の組み合わせは非常に便利です。 10.7.2 複数の変数を用いたグループ化 グループ化変数は2つ以上指定することも可能です。たとえば、都府県 (Pref)と最寄りの駅の路線 (Line)でグループ化することも可能です。それではPrefとLineでグループ化し、店舗数と口コミ数、評価の平均値を計算し、ソートの順番は店舗数、店舗数が同じなら評価の平均値が高い順にしましょう。今回もsummarise()内に.group = \"drop\"を指定し、グループ化を解除します。今回はTop 20まで出してみましょう。 # ScoreNとScoreの平均値をPrefごとに求める df %&gt;% filter(!is.na(Line)) %&gt;% # Lineが欠損していないケースのみ残す group_by(Pref, Line) %&gt;% # PrefとLineでグループ化 summarise(N = n(), ScoreN_Sum = sum(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(desc(N), desc(Score_Mean)) %&gt;% print(n = 20) ## # A tibble: 523 x 5 ## Pref Line N ScoreN_Sum Score_Mean ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 埼玉県 東武東上線 122 27 3.68 ## 2 東京都 ＪＲ 104 231 3.56 ## 3 神奈川県 小田急小田原線 96 31 3.59 ## 4 埼玉県 東武伊勢崎線 96 18 3.51 ## 5 神奈川県 横浜市営ブルーライン 82 77 3.66 ## 6 千葉県 京成本線 82 29 3.34 ## 7 神奈川県 京急本線 68 40 3.33 ## 8 千葉県 東武野田線 63 2 4.75 ## 9 神奈川県 小田急江ノ島線 62 8 3.79 ## 10 大阪府 阪急京都本線 53 32 3.67 ## 11 大阪府 南海本線 52 11 4.22 ## 12 兵庫県 阪神本線 52 23 3.80 ## 13 埼玉県 JR高崎線 51 5 4 ## 14 兵庫県 山陽電鉄本線 51 15 2.98 ## 15 千葉県 JR総武本線（東京-銚子） 47 8 4 ## 16 埼玉県 西武新宿線 45 8 4.17 ## 17 埼玉県 秩父鉄道線 43 10 3.82 ## 18 大阪府 京阪本線 43 10 3.69 ## 19 千葉県 新京成電鉄 43 6 3.6 ## 20 京都府 阪急京都本線 43 27 3.5 ## # … with 503 more rows ぐるなびに登録されているラーメン屋が最も多い路線は埼玉県内の東武東上線で122店舗があります。東武東上線は東京都と埼玉県をまたがる路線ですので、東武東上線だけならもっと多いかも知れませんね。 ここで一つ考えたいのはsummarise()内の.groups引数です。前回はグループ化に使った変数ごとに1行しか残っていなかったのでグループ化を全て解除しました。しかし、今回は状況がやや異なります。グループ化変数に使ったPrefを考えると、まだPref == \"東京都\"であるケースがいくつかあります。やろうとすればまだグループ化出来る状態です。これはLineについても同じです。Line == \"東武東上線\"の行はここには表示されていないものの、まだデータに残っています。もし、これ以上グループ化しないなら今のように.groups = \"drop\"が正しいですが、もしもう一回グループ化したい場合はどうすればよいでしょうか。方法は2つ考えられます。 もう一度パイプ演算子を使ってgroup_by()関数を使う (以下の9行目)。 結果を見ると## # Groups: Pref, Line [523]で、ちゃんとグループ化されていることが分かります。 df %&gt;% filter(!is.na(Line)) %&gt;% group_by(Pref, Line) %&gt;% summarise(N = n(), ScoreN_Sum = sum(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% arrange(desc(N), desc(Score_Mean)) %&gt;% group_by(Pref, Line) %&gt;% # group_by()、もう一度 print(n = 5) ## # A tibble: 523 x 5 ## # Groups: Pref, Line [523] ## Pref Line N ScoreN_Sum Score_Mean ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 埼玉県 東武東上線 122 27 3.68 ## 2 東京都 ＪＲ 104 231 3.56 ## 3 神奈川県 小田急小田原線 96 31 3.59 ## 4 埼玉県 東武伊勢崎線 96 18 3.51 ## 5 神奈川県 横浜市営ブルーライン 82 77 3.66 ## # … with 518 more rows .groups引数を何とかする。 推奨される方法は2番です。具体的には.groups = \"keep\"を指定するだけであり、こっちの方が無駄なコードを省けることができます。 df %&gt;% filter(!is.na(Line)) %&gt;% group_by(Pref, Line) %&gt;% summarise(N = n(), ScoreN_Sum = sum(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), .groups = &quot;keep&quot;) %&gt;% arrange(desc(N), desc(Score_Mean)) %&gt;% print(n = 5) ## # A tibble: 523 x 5 ## # Groups: Pref, Line [523] ## Pref Line N ScoreN_Sum Score_Mean ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 埼玉県 東武東上線 122 27 3.68 ## 2 東京都 ＪＲ 104 231 3.56 ## 3 神奈川県 小田急小田原線 96 31 3.59 ## 4 埼玉県 東武伊勢崎線 96 18 3.51 ## 5 神奈川県 横浜市営ブルーライン 82 77 3.66 ## # … with 518 more rows .groups引数は\"drop\"と\"keep\"以外にも\"drop_last\"があります。実はsummarise()に.groups引数を指定したい場合のデフォルト値は.groups == \"drop_last\"または\"keep\"ですが、主なケースにおいて前者となります4。.groups == \"drop_last\"これは最後のグループ化変数のみ解除する意味です。今回の例だと、2番目のグループ化変数であるLineがグループ化変数から外され、Prefのみがグループ化変数として残る仕組みです。 .groups引数は記述統計量だけを計算する意味ではあまり意識する必要がありません。しかし、得られた記述統計量から何らかの計算をしたり、またグループ化する際は予期せぬ結果が得られる可能性があるため、出来る限り.groups引数は指定するようにしましょう。 10.8 変数の計算 10.8.1 mutate()関数の使い方 続いて、データフレーム内の変数を用いて計算を行い、その結果を新しい列として格納するmutate()関数について紹介します。まず、mutate()関数の書き方からです。 # mutate()関数の使い方 データフレーム名 %&gt;% mutate(新しい変数名 = 処理内容) これは何らかの処理を行い、その結果を新しい変数としてデータフレームに追加することを意味します。新しく出来た変数は、基本的に最後の列になります。ここでは分単位であるWalkを時間単位に変換したWalk_Hour変数を作成するとします。処理内容はWalk / 60です。最後に、都府県名、店舗名、徒歩距離 (分)、徒歩距離 (時間)のみを残し、遠い順にソートします。 df %&gt;% filter(!is.na(Walk)) %&gt;% mutate(Walk_Hour = Walk / 60) %&gt;% select(Pref, Name, Walk, Walk_Hour) %&gt;% arrange(desc(Walk_Hour)) ## # A tibble: 5,375 x 4 ## Pref Name Walk Walk_Hour ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 埼玉県 札幌ラーメン どさん子 小鹿野店 116 1.93 ## 2 神奈川県 札幌ラーメン どさん子 中津店 73 1.22 ## 3 千葉県 札幌ラーメン どさん子 佐原51号店 59 0.983 ## 4 神奈川県 札幌ラーメン どさん子 山際店 50 0.833 ## 5 千葉県 札幌ラーメン どさん子 関宿店 49 0.817 ## 6 兵庫県 濃厚醤油 中華そば いせや 玉津店 43 0.717 ## 7 大阪府 河童ラーメン本舗 岸和田店 38 0.633 ## 8 埼玉県 ラーメン山岡家 上尾店 35 0.583 ## 9 兵庫県 濃厚醤油 中華そば いせや 大蔵谷店 35 0.583 ## 10 大阪府 河童ラーメン本舗 松原店 31 0.517 ## # … with 5,365 more rows mutate()は3行目に登場しますが、これはWalkを60に割った結果をWalk_Hourとしてデータフレームの最後の列として格納することを意味します。もし、最後の列でなく、ある変数の前、または後にしたい場合は、.beforeまたは.after引数を追加します。これはselect()関数の.beforeと.afterと同じ使い方です。たとえば、新しく出来たWalk_HourをIDとNameの間に入れたい場合は # コードの3行名を修正 (.before使用) mutate(Walk_Hour = Walk / 60, .before = Name) # コードの3行名を修正 (.after使用) mutate(Walk_Hour = Walk / 60, .after = ID) のようにコードを修正します。 むろん、変数間同士の計算も可能です。たとえば、以下のようなdf2があり、1店舗当たりの平均口コミ数を計算し、ScoreN_Meanという変数名でScoreN_Sumの後に格納うするとします。この場合、ScoreN_Sum変数をNで割るだけです。 df2 &lt;- df %&gt;% group_by(Pref) %&gt;% summarise(Budget_Mean = mean(Budget, na.rm = TRUE), ScoreN_Sum = sum(ScoreN, na.rm = TRUE), Score_Mean = mean(Score, na.rm = TRUE), N = n(), .groups = &quot;drop&quot;) df2 %&gt;% mutate(ScoreN_Mean = ScoreN_Sum / N, .after = ScoreN_Sum) ## # A tibble: 9 x 6 ## Pref Budget_Mean ScoreN_Sum ScoreN_Mean Score_Mean N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 京都府 1399. 216 0.522 3.68 414 ## 2 埼玉県 1147. 278 0.278 3.64 1000 ## 3 神奈川県 1239. 587 0.587 3.53 1000 ## 4 千葉県 1124. 259 0.259 3.72 1000 ## 5 大阪府 1203. 516 0.516 3.77 1000 ## 6 東京都 1283. 1165 1.16 3.67 1000 ## 7 奈良県 1169. 45 0.306 3.85 147 ## 8 兵庫県 1197. 230 0.389 3.54 591 ## 9 和歌山県 1252 83 0.593 3.97 140 このように、データ内の変数を用いた計算結果を新しい列として追加する場合は、mutate()が便利です。これをmutate()を使わずに処理する場合、以下のようなコードになりますが、可読性が相対的に低いことが分かります。 df2$ScoreN_Mean &lt;- df2$ScoreN_Sum / df2$N df2 &lt;- df2[, c(&quot;Pref&quot;, &quot;Budget_Mean&quot;, &quot;Walk_Mean&quot;, &quot;ScoreN_Sum&quot;, &quot;ScoreN_Mean&quot;, &quot;Score_Mean&quot;, &quot;N&quot;)] むろんですが、計算には+や/のような演算子だけでなく、関数を使うことも可能です。たとえば、Budgetが1000円未満なら\"Cheap\"、1000円以上なら\"Expensive\"と示す変数Budget2を作成する場合はifelse()関数が使えます。 df %&gt;% mutate(Budget2 = ifelse(Budget &lt; 1000, &quot;Cheap&quot;, &quot;Expensive&quot;)) %&gt;% filter(!is.na(Budget2)) %&gt;% # Budget2が欠損した店舗を除外 group_by(Pref, Budget2) %&gt;% # PrefとBudget2でグループ化 summarise(N = n(), # 店舗数を表示 .groups = &quot;drop&quot;) ## # A tibble: 18 x 3 ## Pref Budget2 N ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 京都府 Cheap 22 ## 2 京都府 Expensive 28 ## 3 埼玉県 Cheap 37 ## 4 埼玉県 Expensive 45 ## 5 神奈川県 Cheap 66 ## 6 神奈川県 Expensive 54 ## 7 千葉県 Cheap 64 ## 8 千葉県 Expensive 72 ## 9 大阪府 Cheap 104 ## 10 大阪府 Expensive 115 ## 11 東京都 Cheap 206 ## 12 東京都 Expensive 236 ## 13 奈良県 Cheap 11 ## 14 奈良県 Expensive 10 ## 15 兵庫県 Cheap 39 ## 16 兵庫県 Expensive 27 ## 17 和歌山県 Cheap 10 ## 18 和歌山県 Expensive 5 これは各都府県ごとの予算1000円未満の店と以上の店の店舗数をまとめた表となります。もし、500円未満なら\"Cheap\"、500円以上~1000円未満なら\"Reasonable\"、1000円以上なら\"Expensive\"になるBudget3変数を作るにはどうすればよいでしょうか。第9章で紹介しましたifelse()を重ねることも出来ますが、ここではcase_when()関数が便利です。まずは、ifelse()を使ったコードは以下の通りです。 # ifelse()を使う場合 df %&gt;% mutate(Budget3 = ifelse(Budget &lt; 500, &quot;Cheap&quot;, ifelse(Budget &gt;= 500 &amp; Budget &lt; 1000, &quot;Reasonable&quot;, &quot;Expensive&quot;))) %&gt;% filter(!is.na(Budget3)) %&gt;% group_by(Pref, Budget3) %&gt;% summarise(N = n(), .groups = &quot;drop&quot;) case_when()を使うと以下のような書き方になります。 # ifelse()を使う場合 df %&gt;% mutate(Budget3 = case_when(Budget &lt; 500 ~ &quot;Cheap&quot;, Budget &gt;= 500 &amp; Budget &lt; 1000 ~ &quot;Reasonable&quot;, Budget &gt;= 1000 ~ &quot;Expensive&quot;), # 新しく出来た変数をfactor型にその場で変換することも可能 Budget3 = factor(Budget3, levels = c(&quot;Cheap&quot;, &quot;Reasonable&quot;, &quot;Expensive&quot;))) %&gt;% filter(!is.na(Budget3)) %&gt;% group_by(Pref, Budget3) %&gt;% summarise(N = n(), .groups = &quot;drop&quot;) 書く手間の観点ではcase_when()はifelse()と大きく違いはないかも知れませんが、コードが非常に読みやすくなっています。case_when()関数の書き方は以下の通りです。 # case_when()の使い方 データフレーム名 %&gt;% mutate(新変数名 = case_when(条件1 ~ 条件1を満たす場合の結果値, 条件2 ~ 条件2を満たす場合の結果値, 条件3 ~ 条件3を満たす場合の結果値, ...)) 似たような機能をする関数としてrecode()関数があります。これは変数の値を単純に置換したい場合に便利な関数です。たとえば、都府県名をローマ字に変換するケースを考えてみましょう。 # recode()を使う場合 df2 %&gt;% mutate(Pref2 = recode(Pref, &quot;東京都&quot; = &quot;Tokyo&quot;, &quot;神奈川県&quot; = &quot;Kanagawa&quot;, &quot;千葉県&quot; = &quot;Chiba&quot;, &quot;埼玉県&quot; = &quot;Saitama&quot;, &quot;大阪府&quot; = &quot;Osaka&quot;, &quot;京都府&quot; = &quot;Kyoto&quot;, &quot;兵庫県&quot; = &quot;Hyogo&quot;, &quot;奈良県&quot; = &quot;Nara&quot;, &quot;和歌山県&quot; = &quot;Wakayama&quot;, .default = &quot;NA&quot;)) ## # A tibble: 9 x 6 ## Pref Budget_Mean ScoreN_Sum Score_Mean N Pref2 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; ## 1 京都府 1399. 216 3.68 414 Kyoto ## 2 埼玉県 1147. 278 3.64 1000 Saitama ## 3 神奈川県 1239. 587 3.53 1000 Kanagawa ## 4 千葉県 1124. 259 3.72 1000 Chiba ## 5 大阪府 1203. 516 3.77 1000 Osaka ## 6 東京都 1283. 1165 3.67 1000 Tokyo ## 7 奈良県 1169. 45 3.85 147 Nara ## 8 兵庫県 1197. 230 3.54 591 Hyogo ## 9 和歌山県 1252 83 3.97 140 Wakayama 使い方は非常に直感的です。 # case_when()の使い方 データフレーム名 %&gt;% mutate(新変数名 = recode(元の変数名, 元の値1 = 新しい値1, 元の値2 = 新しい値2, 元の値3 = 新しい値3, ..., .default = 該当しない場合の値)) 最後の.default引数は、もし該当する値がない場合に返す値を意味し、長さ1のベクトルを指定します。もし、指定しない場合はNAが表示されます。また、ここには紹介しておりませんでしたが、.missing引数もあり、これは欠損値の場合に返す値を意味します。 もう一つ注意すべきところは、今回はcharacter型変数をcharacter型へ変換したため、「\"東京都\" = \"Tokyo\"」のような書き方をしました。しかし、numeric型からcharacter型に変換する場合は数字の部分を`で囲む必要があります。たとえば、「`1` = \"Tokyo\"」といった形式です。ただし、character型からnumeric型への場合は「\"東京都\" = 1」で構いません。 recode()は値をまとめる際にも便利です。たとえば、EastJapanという変数を作成し、関東なら1を、それ以外なら0を付けるとします。そして、これはPref変数の後に位置づけます。 # 都府県を関東か否かでまとめる df2 %&gt;% mutate(EastJapan = recode(Pref, &quot;東京都&quot; = 1, &quot;神奈川県&quot; = 1, &quot;千葉県&quot; = 1, &quot;埼玉県&quot; = 1, &quot;大阪府&quot; = 0, &quot;京都府&quot; = 0, &quot;兵庫県&quot; = 0, &quot;奈良県&quot; = 0, &quot;和歌山県&quot; = 0, .default = 0), .after = Pref) ## # A tibble: 9 x 6 ## Pref EastJapan Budget_Mean ScoreN_Sum Score_Mean N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 京都府 0 1399. 216 3.68 414 ## 2 埼玉県 1 1147. 278 3.64 1000 ## 3 神奈川県 1 1239. 587 3.53 1000 ## 4 千葉県 1 1124. 259 3.72 1000 ## 5 大阪府 0 1203. 516 3.77 1000 ## 6 東京都 1 1283. 1165 3.67 1000 ## 7 奈良県 0 1169. 45 3.85 147 ## 8 兵庫県 0 1197. 230 3.54 591 ## 9 和歌山県 0 1252 83 3.97 140 ただし、関東以外は全て0になるため、以下のように省略することも可能です。 # .default引数を指定する場合 df3 &lt;- df2 %&gt;% mutate(EastJapan = recode(Pref, &quot;東京都&quot; = 1, &quot;神奈川県&quot; = 1, &quot;千葉県&quot; = 1, &quot;埼玉県&quot; = 1, .default = 0), .after = Pref) df3 ## # A tibble: 9 x 6 ## Pref EastJapan Budget_Mean ScoreN_Sum Score_Mean N ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 京都府 0 1399. 216 3.68 414 ## 2 埼玉県 1 1147. 278 3.64 1000 ## 3 神奈川県 1 1239. 587 3.53 1000 ## 4 千葉県 1 1124. 259 3.72 1000 ## 5 大阪府 0 1203. 516 3.77 1000 ## 6 東京都 1 1283. 1165 3.67 1000 ## 7 奈良県 0 1169. 45 3.85 147 ## 8 兵庫県 0 1197. 230 3.54 591 ## 9 和歌山県 0 1252 83 3.97 140 新しく出来たEastJapanのデータ型はなんでしょうか。 class(df3$EastJapan) ## [1] &quot;numeric&quot; EastJapanはnumeric型ですね。もし、これをfactor型にしたい場合はどうすればよいでしょうか。それはmutate()内でEastJapanを生成した後にfactor()関数を使うだけです。 # EastJapan変数をfactor型にする df3 &lt;- df2 %&gt;% mutate(EastJapan = recode(Pref, &quot;東京都&quot; = 1, &quot;神奈川県&quot; = 1, &quot;千葉県&quot; = 1, &quot;埼玉県&quot; = 1, .default = 0), EastJapan = factor(EastJapan, levels = c(0, 1)), .after = Pref) df3$EastJapan ## [1] 0 1 1 1 0 1 0 0 0 ## Levels: 0 1 EastJapanがfactor型になりました。実は、recodeは再コーディングと同時にfactor化をしてくれる機能があります。ただし、recode()関数でなく、recode_factor()関数を使います。 # recode_factor()を使う方法 df3 &lt;- df2 %&gt;% mutate(EastJapan = recode_factor(Pref, &quot;東京都&quot; = 1, &quot;神奈川県&quot; = 1, &quot;千葉県&quot; = 1, &quot;埼玉県&quot; = 1, .default = 0), .after = Pref) df3$EastJapan ## [1] 0 1 1 1 0 1 0 0 0 ## Levels: 1 0 ただし、levelの順番はrecode_factor()内で定義された順番になることに注意してください。 10.8.2 factor型の処理に便利な関数 10.9 行単位の操作 ここでは行単位の操作について考えたいと思います。第10.3章で使ったmyDF1を見てみましょう。 myDF1 &lt;- data.frame( ID = 1:5, X1 = c(2, 4, 6, 2, 7), Y1 = c(3, 5, 1, 1, 0), X1D = c(4, 2, 1, 6, 9), X2 = c(5, 5, 6, 0, 2), Y2 = c(3, 3, 2, 3, 1), X2D = c(8, 9, 5, 0, 1), X3 = c(3, 0, 3, 0, 2), Y3 = c(1, 5, 9, 1, 3), X3D = c(9, 1, 3, 3, 8) ) myDF1 ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D ## 1 1 2 3 4 5 3 8 3 1 9 ## 2 2 4 5 2 5 3 9 0 5 1 ## 3 3 6 1 1 6 2 5 3 9 3 ## 4 4 2 1 6 0 3 0 0 1 3 ## 5 5 7 0 9 2 1 1 2 3 8 ここでX1とX2とX3の平均値を計算し、X_Meanという名の変数にする場合、以下のような書き方が普通でしょう。 myDF1 %&gt;% mutate(X_Mean = mean(c(X1, X2, X3))) ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D X_Mean ## 1 1 2 3 4 5 3 8 3 1 9 3.133333 ## 2 2 4 5 2 5 3 9 0 5 1 3.133333 ## 3 3 6 1 1 6 2 5 3 9 3 3.133333 ## 4 4 2 1 6 0 3 0 0 1 3 3.133333 ## 5 5 7 0 9 2 1 1 2 3 8 3.133333 あら、なんかおかしくありませんか。1行目の場合、X1とX2、X3それぞれ2、5、3であり、平均値は3.333であるはずなのに3.133になりました。これは2行目以降も同じです。なぜでしょうか。 実はdplyrは行単位の計算が苦手です。実際、データフレームというのは既に説明したとおり、縦ベクトルを横に並べたものです。列をまたがる場合、データ型が異なる場合も多いため、そもそも使う場面も多くありません。したがって、以下のような書き方が必要でした。 myDF1 %&gt;% mutate(X_Mean = (X1 + X2 + X3) / 3) ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D X_Mean ## 1 1 2 3 4 5 3 8 3 1 9 3.3333333 ## 2 2 4 5 2 5 3 9 0 5 1 3.0000000 ## 3 3 6 1 1 6 2 5 3 9 3 5.0000000 ## 4 4 2 1 6 0 3 0 0 1 3 0.6666667 ## 5 5 7 0 9 2 1 1 2 3 8 3.6666667 先ほどのmean(c(X1, X2, X3))は(X1列とX2列、X3列)の平均値です。X1は長さ1のベクトルではなく、その列全体を指すものです。つまり、mean(c(X1, X2, X3))はmean(c(myD1F$X1, myDF1$X2, myDF1$X3))と同じことになります。だから全て3.133という結果が得られました。ただし、後者はベクトル同士の加減乗除になるため問題ありません。実際c(1, 2, 3) + c(3, 5, 0)は同じ位置の要素同士の計算になることを既に第8.2章で説明しました。 ここでmean()関数を使う場合には全ての演算を、一行一行に分けて行う必要があります。ある一行のみに限定する場合、mean(c(X1, X2, X3))のX1などは長さ1のベクトルになるため、(X1 + X2 + X3) / 3と同じことになります。この「一行単位で処理を行う」ことを指定する関数がrowwise()関数です。これは行単位の作業を行う前に指定するだけです。 myDF1 %&gt;% rowwise() %&gt;% mutate(X_Mean = mean(c(X1, X2, X3))) ## # A tibble: 5 x 11 ## # Rowwise: ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D X_Mean ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 3 4 5 3 8 3 1 9 3.33 ## 2 2 4 5 2 5 3 9 0 5 1 3 ## 3 3 6 1 1 6 2 5 3 9 3 5 ## 4 4 2 1 6 0 3 0 0 1 3 0.667 ## 5 5 7 0 9 2 1 1 2 3 8 3.67 これで問題なく行単位の処理ができるようになりました。今回は変数が3つのみだったので、これで問題ありませんが、変数が多くなると:やstarts_with()、num_range()などを使って変数を選択したくなります。この場合は計算する関数内にc_across()を入れます。ここではX1列からX3D列までの平均値を求めてみましょう。 myDF1 %&gt;% rowwise() %&gt;% mutate(X_Mean = mean(X1:X3D)) ## # A tibble: 5 x 11 ## # Rowwise: ## ID X1 Y1 X1D X2 Y2 X2D X3 Y3 X3D X_Mean ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 2 3 4 5 3 8 3 1 9 5.5 ## 2 2 4 5 2 5 3 9 0 5 1 2.5 ## 3 3 6 1 1 6 2 5 3 9 3 4.5 ## 4 4 2 1 6 0 3 0 0 1 3 2.5 ## 5 5 7 0 9 2 1 1 2 3 8 7.5 実はrowwise()関数、2020年6月に公開されたdplyr 1.0.0で注目された関数ですが、昔のdplyrにもrowwise()関数はありました。ただし、purrrパッケージやtidyrパッケージのnest()関数などにより使い道がなくなりましたが、なぜか華麗に復活しました。データ分析に使うデータは基本単位は列であるため、実際にrowwise()が使われる場面は今の段階では多くないでしょう。また、簡単な作業ならX1 + X2のような演算でも対応できます。それでも、覚えておけば便利な関数であることには間違いありません。 10.10 練習問題 実はselect(starts_with(\"X\"), -ends_with(\"D\"), ID)のように順番を変えるとIDは最後の列になりますが、とりあえず残ります。なぜなら、select()関数は左側から右側の方へコードを実行するからです。↩︎ サービスによってはこの機能が有料になっていたりもしますね。↩︎ たとえば、データ内に「ラーメンショップ」という店舗は3店舗あり、この場合、長さ3のベクトルが返されます。↩︎ 「When .groups is not specified, you either get “drop_last” when all the results are size 1, or “keep” if the size varies.」と書かれていますが、ここの“size 1”の意味がまだ不明瞭です。しかし、場合によっては.groupsのデフォルト値が\"keep\"になることは分かります。↩︎ "]
]
