# スクレイピング {#sec-scraping}

```{r scraping-common}
#| include: false
source("_common.R")
```

　まず、本章で使用するパッケージを読み込んでおく。

```{r}
#| label: scraping-setup
pacman::p_load(tidyverse, rvest, gt, gtExtras)
```

## HTML

　我々が普段見るウェブページは主にHTML（**H**yper**T**ext **M**arkup **L**anguage）という言語で記述されている。裏ではPhp、Ruby、Pythonなどが動いているかも知れないが、少なくとも我々がウェブブラウザー（Firefox、Chrome、Safari、Edge等）越しで見る内容はHTML（+CSS、JavaScript、WebAssembly等）で記述されたものだ。（ウェブ）スクレイピングはこのHTMLで記述された表示内容（の一部）を構造化されたデータとして読み込むことである。

　したがって、スクレイピングをするためにはHTMLの基本的な知識が必要だ。一つの画面に表示された内容の中で我々が欲しいものは、全体内容の一部だ。これはスクレイピングを行う際、全体内容の中から取得する箇所を指定する必要があることを意味する。そこで重要なのがタグ（tag）と属性（attribute）、セレクター（selector）だ。

### タグ

　タグは`<タグ名>`と`</タグ名>`で構成され[^tag-pair]、この間に挟まれた内容は予め決まった書式となる。例えば、`<em>R Not for Everyone</em>`は「R Not for Everyone」という文字列に対して`<em>`タグを適用するコードである。`<em>`タグは予めHTMLで用意されているものであり、文字列をイタリック（例：<em>R Not for Everyone</em>）にするものだ。また、`<strong>`タグは太字を意味し、`<strong>R Not for Everyone</strong>`は「<strong>R Not for Everyone</strong>」と出力される。また、段落を意味する`<p>`タグも頻繁に使われる。HTMLには様々なタグが用意されており、詳細なリストは[W3C](https://www.w3.org/TR/2018/SPSD-html5-20180327/index.html#elements-1)などを参照されたい（リンク先はHTML5基準）。

[^tag-pair]: 通常、タグはカッコのように開いたら（`<タグ名>`）閉じる（`</タグ名>`）必要がある。しかし、タグの中には閉じる必要のないものもある。たとえば、改行を意味するタグとして`<br>`があるが、これは`<br>`、または`<br/>`のみで良い。

　タグの中にタグを入れることもできる。以下のコードを見てみよう。

::::{.columns}
:::{.column width=49%}
**HTMLコード**

```{.html code-line-numbers="true"}
<ol>
  <li> 項目1 
    <ul>
      <li> 項目1A </li>
      <li> 項目1B </li>
      <li> 項目1C </li>
    </ul>
  </li>
  <li> 項目2 </li>
  <li> 項目3 </li>
</ol>
```
:::

:::{.column width=2%}
:::

:::{.column width=49%}
**ブラウザー上の出力内容**

1. 項目1
   * 項目1A
   * 項目1B
   * 項目1C
1. 項目2
1. 項目3
:::
::::

　`<ol>`は順序付きリスト（箇条書き）を意味し、一つ一つの項目は`<li>`タグで指定する。以上の例は`<ol>`タグの中に`<li>`タグが入っている入れ子構造だ。また、順序なしリストのタグ`<ul>`は最初の`<li>`の中に入っている。たとえば、「項目1B」は`<ol>` > `<li>` > `<ul>` > `<li>`で定義された内容である。

### 属性

　タグの中には属性といものが定義されている場合がある。タグをプログラミング言語における関数とすれば、属性は引数（argumentとparameter）に該当する。たとえば、画像を貼り付けるタグは`<img>`だ。ちなみに`<img>`はタグを閉じる必要がなく、単体のみ存在するため`<img>`〜`</img>`でなく、`<img>`のみか`<img/>`と記述する。本書では単体で使うタグを区分するために`<img/>`と表記する。この`<img/>`タグだけではどの画像を表示するかが分からない。画像の具体的なパスやURLを指定する必要がある。`<img/>`タグには`src`という属性があり、`src="パス or URL"`と書く。たとえば、<https://www.jaysong.net/RBook/Figs/favicon.png>というURLの画像を表示させるためには`<img src="https://www.jaysong.net/RBook/Figs/favicon.png"/>`と記述する必要がある。

　一つのタグは複数の属性を持つこともできる。`<img/>`タグの場合、画像の幅と高さを`width`と`height`属性で指定することができ、`alt`で代替テキストを指定することもできる。ちなみに属性が不要なタグもあるが、属性を持つことが**できない**タグは存在しない。すべてのタグは`class`や`hidden`、`style`などの属性を持つことができ、このようにすべてのタグで使える属性はグローバル属性（global attributes）と呼ばれる。

### セレクター

　セレクターを理解するためにはCSS（Cascading Style Sheets）の知識が必要であるが、ここでは最低限のことのみ解説する。ウェブスクレイピングは指定したHTMLファイルから特定のタグに囲まれた内容を取得するのが一般的、かつ基本的なやり方だ。たとえば、あるページ上の表を取得するためには表のタグである`<table>`タグで囲まれた内容を取得する。しかし、一つのページ内に複数の`<table>`タグがあればどうだろうか。多くのスクレイピングのパッケージやライブラリはすべてを読み込むが、それはメモリの無駄遣いだ。予め具体的にどの表を取得するかを指定した方が効率的だろう。ここで必要なのがセレクターだ。

　そもそもセレクターが何なのかを知るためには、CSSの話を簡単にしておく必要がある。CSSはHTMLの「見た目」を担当するものであり、通常、HTMLとは別途のファイル（`.css`ファイル）で作成され、HTMLに読み込まれる。`.css`ファイルの内部には「この箇所はこのような見た目にしてくれ」といったものが細かく書かれている。

　まずは以下の簡単な[HTMLページ](Data/scraping/sample00.html){target="_blank"}（`sample00.html`）を確認してみよう。

* [https://www.jaysong.net/RBook/Data/scraping/sample00.html](Data/scraping/sample00.html){target="_blank"}

　変哲もないページであるが、このページのソースコードは以下の通りである。例えば、`<title>`タグで囲まれているテキストはそのページのタイトルとなり、`<h1>`は見出しとなる。いくつかのタグには`id`や`class`といった属性もついている。たとえば、7行目の`<a>`タグには`href`、`id`、`class`の3つの属性がある。

```{.html filename="https://www.jaysong.net/RBook/Data/scraping/sample00.html" code-line-numbers="true"}
<html>
	<head>
		<meta charset="utf-8">
		<title>HTMLの例</title>
	</head>
	<body>
		<h1>第1章：文章</h1>
		<p>『<a href="https://www.jaysong.net/RBook/" id="rbook" class="book-title">私たちのR</a>』は<a href="https://www.jaysong.net/">宋財泫</a>（SONG Jaehyun）と<a href="https://yukiyanai.github.io/">矢内勇生</a>が共同で執筆するRプログラミングの「入門書」である。統計学の本ではない。</p>
		<p>また、本書はデータ分析の手法の解説書でもない。Rを用いたデータ分析については他の本を参照されたい。私たちが専門とする政治学におけるデータ分析については、以下の本を勧める。</p>
		<h1>第2章：箇条書き</h1>
		  <ul>
    		<li>浅野正彦・矢内勇生. 2018. 『<span class="book-title">Rによる計量政治学</span>』オーム社.</li>
    		<li>飯田健. 2013.『<span class="book-title">計量政治分析</span>』共立出版.</li>
  		</ul>
  		<ol>
    		<li>聞いて...</li>
    		<li>感じて...</li>
    		<li>考えて...</li>
  		</ol>
		<h1>第3章：表</h1>
		<h2>数学成績</h2>
		<table class="score" id="math">
			<thead>
				<tr>
					<td>ID</td>
					<td>名前</td>
					<td>成績</td>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>1</td>
					<td>田中</td>
					<td class="tbl-score">80</td>
				</tr>
				<tr>
					<td>2</td>
					<td>佐藤</td>
					<td class="tbl-score">100</td>
				</tr>
				<tr>
					<td>3</td>
					<td>渡辺</td>
					<td class="tbl-score">75</td>
				</tr>
			</tbody>
		</table>
		<h2>英語成績</h2>
		<table class="score" id="english">
			<thead>
				<tr>
					<td>ID</td>
					<td>名前</td>
					<td>成績</td>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>1</td>
					<td>田中</td>
					<td class="tbl-score">20</td>
				</tr>
				<tr>
					<td>2</td>
					<td>佐藤</td>
					<td class="tbl-score">100</td>
				</tr>
				<tr>
					<td>3</td>
					<td>渡辺</td>
					<td class="tbl-score">90</td>
				</tr>
			</tbody>
		</table>
	</body>
</html>
```

　続いて、もう一つの[ページ](Data/scraping/sample01.html){target="_blank"}（`sample01.html`）も見てみよう。

* [https://www.jaysong.net/RBook/Data/scraping/sample01.html](Data/scraping/sample01.html){target="_blank"}

　内容的には同じものであるが、見た目がだいぶ異なることが分かるだろう。ソースコードを見ると、一行を除き、`sample00.html`と`sample01.html`のコードは一致していることが分かる。具体的には4行目に`<link/>`タグが追加されているだけだ。この4行目のコードは`style01.css`ファイルを読み込み、本ファイル（`sample01.html`）へ適用するということを意味する。他の内容は`sample00.html`と全く同じだ。つまり、この2つのファイルの見た目が異なるのは`style01.css`の存在が原因であると推測できる。

:::{.panel-tabset}
## `.html`コード

```{.html filename="https://www.jaysong.net/RBook/Data/scraping/sample01.html" code-line-numbers="true"}
<html>
	<head>
		<meta charset="utf-8">
		<link href="sample01.css" rel="stylesheet" type="text/css" media="all"/>
		<title>HTMLの例</title>
	</head>
	<body>
		<h1>第1章：文章</h1>
		<p>『<a href="https://www.jaysong.net/RBook/" id="rbook" class="book-title">私たちのR</a>』は<a href="https://www.jaysong.net/">宋財泫</a>（SONG Jaehyun）と<a href="https://yukiyanai.github.io/">矢内勇生</a>が共同で執筆するRプログラミングの「入門書」である。統計学の本ではない。</p>
		<p>また、本書はデータ分析の手法の解説書でもない。Rを用いたデータ分析については他の本を参照されたい。私たちが専門とする政治学におけるデータ分析については、以下の本を勧める。</p>
		<h1>第2章：箇条書き</h1>
		  <ul>
    		<li>浅野正彦・矢内勇生. 2018. 『<span class="book-title">Rによる計量政治学</span>』オーム社.</li>
    		<li>飯田健. 2013.『<span class="book-title">計量政治分析</span>』共立出版.</li>
  		</ul>
  		<ol>
    		<li>聞いて...</li>
    		<li>感じて...</li>
    		<li>考えて...</li>
  		</ol>
		<h1>第3章：表</h1>
		<h2>数学成績</h2>
		<table class="score" id="math">
			<thead>
				<tr>
					<td>ID</td>
					<td>名前</td>
					<td>成績</td>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>1</td>
					<td>田中</td>
					<td class="tbl-score">80</td>
				</tr>
				<tr>
					<td>2</td>
					<td>佐藤</td>
					<td class="tbl-score">100</td>
				</tr>
				<tr>
					<td>3</td>
					<td>渡辺</td>
					<td class="tbl-score">75</td>
				</tr>
			</tbody>
		</table>
		<h2>英語成績</h2>
		<table class="score" id="english">
			<thead>
				<tr>
					<td>ID</td>
					<td>名前</td>
					<td>成績</td>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>1</td>
					<td>田中</td>
					<td class="tbl-score">20</td>
				</tr>
				<tr>
					<td>2</td>
					<td>佐藤</td>
					<td class="tbl-score">100</td>
				</tr>
				<tr>
					<td>3</td>
					<td>渡辺</td>
					<td class="tbl-score">90</td>
				</tr>
			</tbody>
		</table>
	</body>
</html>
```

## `.css`コード

```{.css filename="https://www.jaysong.net/RBook/Data/scraping/sample01.css" code-line-numbers="true"}
h1, h2, h3 {
	font-family: sans-serif;
}
a {
	text-decoration: none;
	color: royalblue;
}
table {
	border-collapse: collapse;
	border: 1px solid;
}
td {
	border-collapse: collapse;
	border: 1px solid;
}
thead {
	text-align: center;
	font-weight: 600;
}
#rbook {
	color: red;
}
.book-title {
	font-weight: 600;
}
.score {
	width: 300px;
}
.tbl-score {
	text-align: right;
}
```
:::

　一つずつ確認していこう。まず、「第1章：文章」や「英語成績」のような見出しが明朝体（serif）からゴジック体（sans-serif）に変わったことが分かる。続いて`sample01.css`の1〜3行目を確認してみよう。

```css
h1, h2, h3 {
	font-family: sans-serif;
}
```

　このCSSの意味は`<h1>`、`<h2>`、`<h3>`タグに囲まれた内容に対し、`{}`内の設定を適用するといういみで、今回はフォント族（font-family）をゴジック（sans-serif）にした。また、リンクの下線が無くなり、文字の色もロイヤルブルーになったが、これも`sample01.css`の4〜7行目で適宜されたものである。このように`タグ名 {}`で特定のタグに対し、スタイルを適用することができ、ここでの`タグ名`はタグに対するセレクターである。このようなタグ名のセレクターは要素型セレクター（type selector）と呼ばれる。

　引き続き、`sample01.html`を見ると『私たちのR』が太字、かつ赤色になっていることが分かる。また、コードの8行目を見ると『私たちのR』の部分が`<a>`タグで囲まれ、
リンク先を意味する`href`属性以外にも、`id`と`class`にそれぞれ`"rbook"`と`"book-title"`の値が指定されていることが分かる。そして、`sample01.css`の20〜25行目に`id`が`rbook`の場合と`class`が`book-title`の場合のスタイルが定義されている。たとえば、idは`#ID名`がセレクターであり（今回は`#rbook`）、赤色が定義されている。クラスは`.クラス名`がセレクターであり（今回は`.book-title`）、文字の太さ（weight）が600になっていることが分かる。ちなみに一つのタグに対して複数のクラスを与えることもできる。この場合、タグ内に`class="クラス名1 クラス名2 クラス名3"`のように半角スペースでクラス名を区切れば良い。

　このようにIDセレクターとクラスセレクターが用意されているが、特定のタグに識別可能な名前を付ける点で、2つの役割は非常に似ている。しかし、IDとクラスには決定的な違いがある。それはIDは一つのページ内において**1回**しか登場できないものの、クラスはこのような制限がないことだ。何回も登場するスタイルであればクラスを使用し、固有の識別子が必要な場合はIDを使う。それでも「クラスを1回だけ使っても良いのでは？」と思う読者もいるだろう。たしかにその通りである。しかし、IDとクラスのもう一つの違いはスタイルが衝突する場合、IDセレクターがクラスセレクターに優先する点にある。たとえば、あるタグが`#A`IDと`.B`クラスを両方持ち、`.css`内部においてそれぞれ文字の太さが600、300に定義されていると、`#A`に指定された太さ600が適用される。スクレイピングにおいてIDとクラスの違いは重要ではないが、念のために述べておく。

　以上で紹介したもの以外にも、セレクターは多数用意されている。たとえば、文章全体にスタイルを適用したい場合のセレクターは`*`であり、全称セレクター（universal selector）と呼ばれる。また、特定の属性を持つタグに対してスタイルを適用できる。たとえば、`<img>`タグすべてでなく、`alt`属性を持つ`<img>`タグのみにスタイルを適用する場合のセレクターは`img[alt]`のように`タグ名[属性名]`のように記述する。また、`a[href="http://www.jaysong.net"]`のように`href`属性の値が`"http://www.jaysong.net"`と一致する`<a>`タグを選択することもできる[^attr-selector]。

[^attr-selector]: 属性セレクターはいくつかのバリエーションがある。たとえば、`a[href$=".net"]`は`href`の値が`".net"`で**終わる**`<a>`タグ、`a[href^="www"]`は`href`の値が`"www"`で**始まる**`<a>`タグ、`a[href~="jaysong"]`は`href`の値に`"jaysong"`が**含まれていない**`<a>`タグ、`a[href*="rbook"]`は`href`の値に`"rbbok"`が**含まれている**`<a>`タグを意味する。

### セレクターの確認

　CSSを勉強する場合のセレクターの話はもっと長くなるが、スクレイピング**入門**レベルであれば、タグ、ID、クラス、属性セレクターだけでも問題ない[^selector-advanced]。つまり、自分がスクレイピングしたい内容のタグ、ID、クラス、属性を知るだけで十分だ。これを調べるにはHTMLソースコードを読む必要はあるが、最近のHTMLページは数百〜数千行のコードで構成されているため、すべてを精査することは現実的でない。最近のウェブブラウザーには開発者専用のメニューが用意されており、これを活用すると素早く必要な内容のセレクターを調べることができる。しかし、ブラウザーごとに開発者メニューの開き方が異なる。以下では[statcounter](https://gs.statcounter.com/browser-market-share)基準、代表的な4つのブラウザーの例を紹介する。

[^selector-advanced]: もっと深く入ると、セレクターの親子関係など様々な書き方がある。

:::{.panel-tabset}
## Firefox

右上の「≡」>その他のツール>ウェブ開発ツール

![](Figs/Scraping/devtools_firefox.png)

## Chrome

右上の「⋮」>その他のツール>デベロッパーツール

![](Figs/Scraping/devtools_chrome.jpg)

## Safari

開発 > Webインスペクタを接続

* 開発メニューがない場合は環境設定の「詳細」タブの「メニューバーに"開発"メニューを表示」にチェックを入れる必要がある。

![](Figs/Scraping/devtools_safari.jpg)

## Edge

右上の「…」>その他のツール>開発者ツール

![](Figs/Scraping/devtools_edge.png)
:::

　ここからは筆者（宋）が使用しているFirefox基準で説明するが、どのブラウザーでも使い方は大きく変わらない。以下は『私たちのR』の初期ページからウェブ開発メニューを開いたものである。

![](Figs/Scraping/find_selector00.png)

　このページのコードは2023年6月現在、1148行である。ここで、画面右にある『私たちのR』のカーバー（仮）のタグ、クラス、ID、属性、親タグなどを調べてみよう。まず、ウェブ開発メニューの左上にある![](Figs/Scraping/find_selector01.png){fig-width=10px}ボタンをクリックする。これはページ内の要素を選択し、その要素のコードなどを表示してくれる機能である。このボタンのアイコンはブラウザーごとにことなるが、開発者メニューの左上か右上に位置する。

　続いて、調べたい要素を選択する。マウスカーソルを要素の上に乗せるとハイライトされるため、分かりやすい。調べたい要素がハイライトされたらそのままクリックすると、開発者メニューに当該箇所のソースコードが表示される。

![](Figs/Scraping/find_selector02.png)

　以下は当該箇所のコードの一部を抜粋したものだ。

```{.html code-line-numbers="true"}
<section id="紹介" class="level1 unnumbered">
  <h1 class="unnumbered">紹介</h1>
  <p>
    <img src="Figs/Cover.png" title="私たちのR" class="quarto-cover-image img-fluid">
  </p>
```

　当該箇所のタグは`<img>`である。クラスは`quarto-cover-image`と`img-fluid`、2つだ。他にも`src`と`title`という属性を持ち、それぞれ`"Figs/Cover.png"`と`"私たちのR"`という値が割り当てられている。他にもこの`<img>`タグの親タグは`<p>`であり、その親タグは`<section>`タグだということが分かる。ここでこの図の情報が必要な場合、セレクターは`img`十分だろうか。答えはNoだ。このページにはこの画像以外にもイケメン著者たちの写真もある。`img`だけだとどの図なのかが分からない。この図を特定するためには更に情報が必要だ。

　たとえば、`<img>`の`title`属性に注目しても良いだろう。イケメン著者たちの画像は`title`属性を持たない（各自確認してみよう）が、カーバー（仮）には`title="私たちのR"`がある。これを利用すると`img[title="私たちのR"]`といったセレクターも有効だろう。もう一つは親のタグ、ID、クラスなどを利用する方法だ。カーバー（仮）の親タグの一つは`<section>`であり、`"紹介"`というIDが指定されている。IDはこのページに1回しか登場しないものであるため、これは使えるかも知れない。このページ内の2つの画像のコードを簡単に示すと以下の通りだ。

```{.html code-line-numbers="true"}
<section id="紹介" class="level1 unnumbered">
  <img src="Figs/Cover.png" title="私たちのR" class="quarto-cover-image img-fluid">
</section>
<section id="著者紹介" class="level1 unnumbered">
  <img src="Figs/Authors/SongYanai.jpg" class="img-fluid figure-img" width="350">
</section>
```

　どの画像も親タグは`<section>`であるが、異なるIDを持つ。つまり、異なる親を持つ。カーバー（仮）は`id="紹介"`、イケメン著者は`id="著者紹介"`の`<section>`親を持つ。この場合、（1）IDが`"著者"`の要素を選択し（`#紹介`）、（2）`<img>`タグを選択する（`img`）といった手順で、欲しい内容が抽出できる。本章では基本的に、このような多段階の抽出方法を採用する。より洗練された書き方で効率的なスクレイピングもできるが、入門レベルだとこのようなやり方でも問題ないだろう。それではRにおけるスクレイピングの定番パッケージ、{rvest}の簡単な使い方を見てみよう。

## {rvest}の使い方

　実際のウェブスクレイピングをやってみる前に、{rvest}パッケージを使って[実習用のページ](https://www.jaysong.net/RBook/Data/scraping/sample01.html)（`sample01.html`）の内容を取得してみよう。

* テキスト/表の取得
   * `html_elment()`、`html_elments()`で特定のタグやクラス、IDを抽出
   * `html_text()`、`html_text2()`や`html_table()`で抽出
   * 画像の場合、`<img>`タグの`src`属性を抽出する必要があるため、`html_attr()`

　まずは、`read_html()`関数を使用し、スクレイピングするHTMLファイルそのものを読み込んでおく必要がある。引数はHTMLファイルのURL、もしくはパスだけで問題ないが、Shift-JISやEUC-KRといった邪悪なロケールで作成されたページであれば、`encoding`引数が必要となる。サンプルページはUTF-8であるため、URLのみで問題ない。

```{r}
#| label: scraping-rvest-read
my_html <- read_html("https://www.jaysong.net/RBook/Data/scraping/sample01.html")
my_html
```

　中身は簡単にしか確認できないが、そもそもRでコードをすべて表示する必要もないので問題ないだろう。HTMLのソースコード全体が見たい場合はウェブブラウザーから確認しよう。ここでは問題なくHTMLファイルが読み込まれていることだけを確認すれば良い。

　それではこの`my_html`からいくつかの要素を抽出してみよう。まずは、`タグ名`セレクターを使用し、特定のタグだけを抽出する。ここで使用する関数は`html_elements()`だ[^html_elements]。たとえば、ハイパーリンクを意味する`<a>`タグが使用された箇所すべてを読み組むには`html_elemtns(HTMLオブジェクト名, "a")`で良い。HTMLオブジェクト名（今回は`my_html`）は第1引数だから、パイプ演算子を使用しよう。

[^html_elements]: 似たような名前の`html_element()`がある。ほぼ同じものであるが、`html_element()`は1ページ内に当該セレクターが複数回ある場合、最初のものだけを抽出する。一方、`html_elements()`はすべての要素を抽出する。

```{r}
#| label: scraping-rvest-elements-01
my_html |> 
  html_elements("a")
```

　しかし、通常、これらの内容すべてが必要になるケースは稀だろう。普通、`<a>`と`</a>`に囲まれたテキストの内容や、リンク先のURLのリストが欲しいだろう。`html_elements()`で指定したセレクター内のテキストを抽出する場合は、`html_text()`を使用する[^html_text2]。

[^html_text2]: 似たような関数として`html_text2()`があるが、これは前後の不要なスペースやタブ、改行などを除外した上でテキストを取得する関数だ。

```{r}
#| label: scraping-rvest-elements-02
my_html |> 
  html_elements("a") |> 
  html_text()
```

　`<a>`と`</a>`に囲まれたテキストの内容でなく、リンク先のURLを抽出することもできる。`<a>`タグのリンク先は`href`属性で指定するため、`href`属性の値を抽出すれば良い。特定の属性の値を取得する関数は`html_attr()`であり、引数として属性名を指定すれば良い。

```{r}
#| label: scraping-rvest-elements-03
my_html |> 
  html_elements("a") |> 
  html_attr("href")
```

 続いて、箇条書きの要素を抽出してみよう。今回は2本の書籍リストが対象だ。箇条書きの内容は`<li>`タグで記述されるので、`html_elements("li")`で`<li>`タグの内容を取得してみよう。

```{r}
#| label: scraping-rvest-elements-04
my_html |> 
  html_elements("li")
```

　書籍リストだけでなく、謎の言葉も取得される。実際、サンプルページには2つの箇条書きがあり、書籍は順序なしの箇条書き（`<ul>`）、謎の言葉は順序付き箇条書き（`<ol>`）である。したがって、まず、`<ul>`タグを抽出し、そこから`<li>`を抽出すれば良い。

```{r}
#| label: scraping-rvest-elements-05
my_html |> 
  html_elements("ul") |> 
  html_elements("li")
```

　ちなみに`html_elements()`が続く場合は引数を`"タグ名 > タグ名"`にしても同じ結果が得られる。

```{r}
#| label: scraping-rvest-elements-06
my_html |> 
  html_elements("ul > li")
```

　ここから更にテキストのみ抽出する場合は`html_text()`を使えば良い。

```{r}
#| label: scraping-rvest-elements-07
my_html |> 
  html_elements("ul > li") |> 
  html_text()
```

　`html_elements()`にはタグ名以外のセレクターも使える。たとえば、クラス（`.クラス名`）やID（`#ID名`）の指定もできる。サンプルページには書籍名が3回登場し、それらは`<span>`タグに囲まれている。`<span>`タグ単体の機能はないが、特定のテキストにIDやクラスを割り当てる際によく使われる。今回の例だと、書籍名はクラスが`book-title`の`<span>`タグで囲まれている。したがって、書籍名を抽出する時には`html_elements(".book-title")`

```{r}
#| label: scraping-rvest-elements-08
my_html |> 
  html_elements(".book-title")
```

　このように`book-title`クラスのタグと、その内容が全て抽出される。ここからテキストを抽出する場合は`html_text()`を使えば良い。

```{r}
#| label: scraping-rvest-elements-09
my_html |> 
  html_elements(".book-title") |> 
  html_text()
```

　スクレイピングで最も需要の高いものは表だろう。表の場合、HTMLでは`<table>`タグで記述されるが、{rvest}は表を取得し、tibble形式で返す`html_table()`関数が用意されている。これまで使ってきた`html_elements()`関数はあっても良いが、なくても問題ない。サンプルページには2つの表があるが、HTMLオブジェクトをそのまま`html_table()`に渡すと表が抽出される。

```{r}
#| label: scraping-rvest-table-01
my_html |> 
  html_table()
```

　長さ2のリストが出力され、それぞれ表が格納されている。今回のように、表のヘッダー（1行目）が中身として出力される場合もあるが、このような場合は`header = TRUE`を指定すると、1行目が変数名となる。

```{r}
#| label: scraping-rvest-table-02
my_tables <- my_html |> 
  html_table(header = TRUE)

my_tables
```

　この2つの表を`bind_rows()`を使って結合することもできる。まず、`names()`関数を使って、リストの各要素に名前を割り当てる。

```{r}
#| label: scraping-rvest-table-03
names(my_tables) <- c("数学", "英語")

my_tables
```

　続いて、`bind_rows()`関数に表のリストを入れ、`.id`変数で2つの表を識別する値が格納される列名を指定する。`bind_rows()`の詳細は第[-@sec-handling2-merge]章を参照されたい。

```{r}
#| label: scraping-rvest-table-04
my_table <- bind_rows(my_tables, .id = "科目")

my_table
```

　すべての表ではない、英語成績の表だけを抽出する場合はどうすれば良いだろうか。今回は表が2つしかなく、2番目の表が英語成績ということが分かっているので`my_table[[2]]`のような書き方でも問題ない。しかし、表が数百個ある場合は、何番目の表かを数えるのも簡単ではない。幸い、今回はそれぞれの表に`math`と`english`といったIDが割り当てられている。このセレクターを使えば、IDが`"english"`の表を選択することもできよう。`html_element()`関数の引数として`"#english"`を指定し、そこから`html_table()`を実行すると英語成績の表だけが抽出される。

```{r}
#| label: scraping-rvest-table-05
my_html |> 
  html_element("#english") |> 
  html_table(header = TRUE)
```

　ここで一つ注意事項があるが、`html_elements()`でなく、`html_element()`を使う点だ。IDが1ページに1つしか存在しないため、`html_element()`を使った方が楽である。`html_elements()`を使っても良いが、返ってくるのはtibbleでなく、長さ1のリストになるので、更に`[[1]]`などでリストから表を取り出す必要がある。

## 実践

### 表の抽出

Wikipediaの[世界報道自由度ランキング](https://en.wikipedia.org/wiki/World_Press_Freedom_Index)の表をスクレイピング

```{r}
#| label: scraping-hdi
#| cache: true
#| warning: false
url <- "https://en.wikipedia.org/wiki/World_Press_Freedom_Index"

pfi_html <- read_html(url)

pfi_html

pfi_tbls <- pfi_html |> 
  html_table()

pfi_df <- pfi_tbls[[1]] |> 
  rename("Year2023" = "2023[5]",
         "Year2022" = "2022[6]",
         "Year2021" = "2021[7]",
         "Year2020" = "2020[8]",
         "Year2019" = "2019[9]") |> 
  mutate(across(Year2023:Year2019, ~str_replace(.x, "\\(([0-9]+)\\)", "")),
         across(Year2023:Year2019, as.numeric))

pfi_df

pfi_df |> 
  filter(Country %in% c("Japan", "South Korea", "North Korea", "China",
                        "Hong Kong", "Taiwan", "Mongolia")) |> 
  gt() |> 
  cols_label("Year2023" = "2023",
             "Year2022" = "2022",
             "Year2021" = "2021",
             "Year2020" = "2020",
             "Year2019" = "2019") |> 
  data_color(columns = Year2023:Year2019,
             palette = "ggsci::blue_material")
```

### 表の抽出（複数ページ）

```{r}
#| label: scraping-j
#| cache: true
j_list <- paste0("https://www.jleague.jp/standings/j", 1:3)

tbl_list <- list()

for (i in seq_along(j_list)) {
  temp_html <- read_html(j_list[i])
  temp_tbl  <- temp_html |> 
    html_table(header = TRUE)
  
  tbl_list[[paste0("J", i)]] <- temp_tbl[[1]]
  
  Sys.sleep(1)
}

tbl_list

j_df <- bind_rows(tbl_list, .id = "League")

j_df

j_df <- j_df |> 
  select(!c("...1", "直近5試合"))

j_df |> 
  mutate(クラブ名 = str_sub(クラブ名, 1, nchar(クラブ名) / 2)) |> 
  group_by(League) |> 
  gt()
```

### 表以外の内容

OpenCritic (2021; PC Games)

* <https://opencritic.com/browse/pc/2021>
* 表のように見えるが、表ではない（`<div>`が並んでいるだけ）。
* `html_nodes()`でランキング、画像URL、スコアなどをベクトルとして抽出し、R側で表にする。

```{r}
#| label: scraping-oc-single
#| cache: true
oc_html <- read_html("https://opencritic.com/browse/all/2021")

oc_html <- oc_html |> 
  html_element(".desktop-game-display")


oc_df <- tibble(Rank      = html_elements(oc_html, ".rank") |> 
                  html_text2(),
                Tier      = html_elements(oc_html, "img") |> 
                  html_attr("src"),
                Score     = html_elements(oc_html, ".score") |> 
                  html_text2(),
                Name      = html_elements(oc_html, ".game-name") |>
                  html_text2(),
                Platforms = html_elements(oc_html, ".platforms") |>
                  html_text2(),
                Date      = html_elements(oc_html, ".first-release-date") |>
                  html_text2()) |> 
  mutate(Rank = str_remove(Rank, "\\."),
         Rank = as.numeric(Rank),
         Date = paste0(Date, ", 2021"),
         Date = mdy(Date))

#oc_df |> 
#  separate(Platforms,
#           into = paste0("P", 1:6),
#           sep = ", ")

oc_df |> 
  gt() |> 
  gt_img_rows(Tier) |> 
  cols_label("Date" = "First release date")
```

### 表以外の内容（複数ページ）

1位から500位まで

```{r}
#| label: scraping-oc-multiple
#| cache: true
oc_url <- paste0("https://opencritic.com/browse/pc/2021?page=", 1:25)

oc_list <- list()

get_oc <- function (url) {
  temp_html <- read_html(url) |> 
    html_element(".desktop-game-display")
  temp_df <- tibble(Rank  = html_elements(temp_html, ".rank") |> 
                      html_text2(),
                    Tier  = html_elements(temp_html, "img") |> 
                      html_attr("src"),
                    Score = html_elements(temp_html, ".score") |> 
                      html_text2(),
                    Name  = html_elements(temp_html, ".game-name") |>
                      html_text2(),
                    Date  = html_elements(temp_html, ".first-release-date") |>
                      html_text2()) |> 
    mutate(Rank = str_remove(Rank, "\\."),
           Rank = as.numeric(Rank),
           Date = paste0(Date, ", 2021"),
           Date = mdy(Date))
}

for (i in seq_along(oc_url)) {
  
  temp_df      <- get_oc(oc_url[i])
  oc_list[[i]] <- temp_df
  
  Sys.sleep(1)
}

bind_rows(oc_list) |> 
  gt() |> 
  gt_img_rows(Tier) |> 
  cols_label("Date" = "First release date")
```

### スクレイピングの注意事項

* Terms and conditions / Terms of serviceを読もう
* 著作権
* 個人情報
* `Sys.sleep()`