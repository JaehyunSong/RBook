# 文字列の処理 {#sec-string}

```{r}
#| label: string-common
#| include: false
#| message: false
source("_common.R")
```

この章で使うパッケージを読み込む。

```{r}
pacman::p_load(tidyverse)
```

## Rにおける文字列

　Rは数値だけでなく文字列 (string) も扱うことができる。近年、文字や文書をデータとして扱う機会が増えており、文字列を効率的に処理する方法を身につけることで、データとして扱う対象を拡大することができる。

　まず、最も基本的な文字列の扱い方を確認（復習）しよう（第[-@sec-datatype]章も参照されたい）。Rで文字列を使う際は、文字列を引用符 (quotation marks) で**囲む**（囲むというのは、文字列が始まる前とそれが終わった後にそれぞれ引用符をつけるという意味である）。例えば、「SONG Jaehyun」という文字列を`author1`というオブジェクトに格納するには、次のようにする。

```{r}
author1 <- "SONG Jaehyun"
author1
```

文字列の中にスペースが含まれる場合、そのスペースもそのまま保存される。この例では、半角スペースを1つ含む文字列が保存される。

　Rにおける文字列は、`character` クラス・型として扱われる。

```{r}
class(author1)
is.character(author1)
typeof(author1)
mode(author1)
```

　引用符は、二重引用符`""` でも 単一引用符`''` でも良い。ただし、同じ記号をペアで使う必要がある。

```{r}
author2 <- '矢内　勇生'
print(author2)
```

この例では、全角スペースを1つ含む文字列が保存される。また、`''`を使って文字列を作ったのに、表示結果で文字列を囲む引用符は`""`に変わっていることがわかる。これは、文字列を作る際には二重引用符を使うことが想定されているためである。よって、特にこだわりがなければ、二重引用符`""`を使ったほうがよいだろう。

　引用符自体を文字列の一部として保存したいときは、次のようにする。

```{r}
quote1 <- "Mura'Kamisama'"
quote2 <- 'We we"R"e born to use "R."'
quote1
quote2
```

`quote2` の表示結果を見ると、文字列に含まれる二重引用符の前にバックスラッシュ `\` が付いている。これは、文字列のエスケープと呼ばれる方法である。これについては後で詳しく説明する。この例においては、二重引用符を文字列を作るための命令として使う代わりに、単なる1つの文字として扱うために必要な処理である。`cat()`を使うと、保存した内容をそのまま表示することができる。

```{r}
cat(quote2)
```

　上の例では文字列内で二重引用符を使うので、文字列の外側ではは単一引用符を使った。
二重引用符のみで上と同じ文字列を作りたい場合は、エスケープ処理を利用すればよい。

```{r}
quote3 <- "We we\"R\"e born to use \"R.\""
quote3
cat(quote3)
```

エスケープ処理をしないとエラーになる。

```{r}
#| error: true
quote3 <- "We we"R"e born to use "R.""
```

これは、「"We we"」で二重引用符のペアが完成し、そのすぐ後の「R」が文字列として認識されていないために起こるエラーである。

　文字列を要素とするベクトルやリストなども、数値を要素とする場合と同じように作ることができる。
```{r}
authors <- c(author1, author2, "Super Cat")
authors
```

　数値と文字列の両者を要素としてもつベクトルを作ると、すべての要素が文字として保存される。
```{r}
numchar <- c(1, 2, "three", 4, "five")
numchar
class(numchar)
sapply(numchar, class)
```

Rでは、ベクトルのすべての要素は同じクラスになる。数値は文字として扱える一方で、一般的に文字を数値として扱うことはできないので、型が文字 (character) に統一される。

　リストは異なる型を保存することできる。

```{r}
numchar_list <- list(1, 2, "three", 4, "five")
numchar_list
class(numchar_list)
lapply(numchar_list, class)
```

 数値を文字として扱いたいときは、`as.character()` を使う。

```{r}
one <- as.character(1)
one
one2ten <- 1:10 |> 
  as.character()
one2ten
class(one2ten)
```

保存されているのが数字であっても、それが文字列として保存されているなら、そのまま計算に利用することはできない。

```{r}
#| error: true
sum(one2ten)
```

しかし，`as.numeric()` や `as.integer()` を使って数値に変換すれば、計算に利用することができる。

```{r}
as.numeric(one2ten)
one2ten |> 
  as.integer() |> 
  sum()
```

```{r}
as.numeric("3.35") + as.numeric("4.24") * 2
```

数字以外の文字を数値に変換することはできない（`NA`になる）。

```{r}
c("1", "2", "three", "4") |> 
  as.integer()
```

　Rの文字列に対して、そのままスライシング操作を行うことはできない。たとえば、`author1`の1文字目を取り出したいときに、次のようにしても1文字目の"S"は抽出できない。

```{r}
author1[1]
```

このように、文字列全体が取り出されてしまう。これは、この文字列が長さ1のベクトル（つまり、冗長に書けば`c("SONG Jaehyun")` である）なので、スライス操作で1番目の要素を取り出すと、ベクトルの第1要素が取り出されるためである。

したがって、文字列自体の長さを`length()`で測ることはできない。

```{r}
length(author1)
length(author2)
```
いずれの結果も1になるのは、どちらも長さが1のベクトルだからである。

　文字列に対して様々な処理を施す方法については、次節で説明する。


## 文字列の操作

Rでは、文字列に対して様々な処理を行うこができる。
文字列操作をする際に欠かせないのが、**stringr**パッケージである。
このパッケージは私たちが住む**tidyverse**に含まれているので、あらためて読み込む必要はない。

**stringr**パッケージで文字列操作を行う関数は、`str_xxx()`のような形式の関数である（`xxx`の部分を、操作に応じて変える）。まず、文字列の長さ（つまり、文字数）を数えるために、`str_length()` を使う。

```{r}
str_length(authors)
```

スペースを含む文字数が返される。

　上で試みたように文字列の一部 (substring) を取り出すときは、`str_sub()`を使う。

```{r}
str_sub(author1, start = 1, end = 1)
```

このように始点 (`start`) と終点 (`end`) を指定することで、文字列の一部を取り出すことができる。
5文字目から8文字目までを取り出してみよう。

```{r}
str_sub(author1, start = 6, end = 8)
```

特定の位置より後をすべて取り出したいときは、`start`のみを指定する。

```{r}
str_sub(author1, start = 6)
```

同様に、特定の位置までを取り出したいときは、`end`のみを指定する。

```{r}
str_sub(author1, end = 4)
```

`end` に指定した位置も含めて抽出されることに注意されたい。

文字列を分割 (split) したいときは、`str_split()`を使う。
`pattern`で指定した文字の前後で文字列を分割する。
たとえば、次のようにする。

```{r}
author1_s <- str_split(author1, pattern = " ") |> 
  print()
```

結果として返されるのは、リストである。
2つ以上の文字列に対して同様の操作を行うと、リストで返される理由がわかるだろう。

```{r}
authors_s1 <- str_split(authors, pattern = " ") |> 
  print()
```

`authors` は3つの文字列を要素としてもつベクトルである。
このベクトルに対して文字列分割の操作を行うと、それぞれの文字列の分割結果を要素とするリストが返される。そしてリストの各要素の中に、分割したそれぞれの文字列を要素をしてもつベクトルが保存される。

　ここで、リストの2つ目の要素が分割されて**いない**ことに注意してほしい。これは、この文字列には半角スペースがないからだ。代わりに全角スペースがあるので、これを分割したいなら`pattern`に全角スペースを指定する必要がある。

```{r}
authors_s2 <- str_split(authors, pattern = "　") |> 
  print()
```

今度は、2番目の文字列のみ分割された。すべて分割するには、`|` (or) を使って次のようにする。

```{r}
authors_s3 <- str_split(authors, pattern = " |　") |> 
  print()
```

上のコードでは、`|` の左側に半角スペース、右側に全角スペースが指定されている。

　あるいは、次のように「空白文字」を`\\s`で指定すれば、半角・全角をまとめて扱える（これについては後で正規表現を説明する際にもう少し説明する）。

```{r}
authors_s3 <- str_split(authors, pattern = "\\s") |> 
  print()
```

　文字列操作をもう少し練習するために、以下の例文を使おう。
```{r}
eg_Acton <- "Power tends to corrupt. Absolute power corrupts absolutely."
eg_Wilde <- "A little sincerity is a dangerous thing, and a great deal of it is absolutely fatal."
```

　`str_split()`は、同じパタンが複数回出てくる場合には、すべてを分割してくれる。

```{r}
str_split(eg_Acton, pattern = "\\s")
```

この例からわかるとおり、このような操作は英文をはじめとする単語間にスペースがある言語データをに対し、文字列を単語に分割する際に有用である。

　特定の文字（単語）を抽出したいときは、`str_extract()` を使う。

```{r}
str_extract(eg_Acton, pattern = "corrupt")
```

`eg_Acton`オブジェクトには指定した文字列である "corrupt" に一致する部分があるので、関数は指定した文字列そのものを返す。 このオブジェクトには "corrupt" という文字列が2回登場するが、この関数は最初の "corrupt" を発見した時点でそれを返し、2つ目の"corrupt" には到達しない。

　オブジェクトの中に指定した文字列が存在しない場合、`NA`が返される。

```{r}
str_extract(eg_Acton, pattern = "cats")
```

　`str_extract()` は指定した文字列を1度しか返さないが、`str_extract_all()` は一致したものをすべてを返す。

```{r}
str_extract_all(eg_Acton, pattern = "corrupt")
```

この例が示す通り、 `str_extract_all()` はリストを返す。 リストの長さは文字列が一致した回数ではなく、パタンを探す対象として渡したオブジェクトの数である。 上の例では、1つのオブジェクトで2回マッチしているので、返されたリストの長さは1であり、リストの第1要素の長さは2である。

```{r}
list_corrupt <- str_extract_all(eg_Acton, pattern = "corrupt") 
length(list_corrupt)
length(list_corrupt[[1]])
```

　次の例では、返されるリストの長さが2になる。

```{r}
list_absolute <- str_extract_all(c(eg_Acton, eg_Wilde), 
                                 pattern = "absolute") |> 
  print()
```

　これらの関数は、いずれも大文字と小文字を区別する (case-sensitive)。大文字、小文字の別を無視したいときは`regex()`を使って`ignore_case = TRUE` を指定する。

```{r}
str_extract_all(c(eg_Acton, eg_Wilde),
                pattern = regex("absolute", ignore_case = TRUE))
```

　オブジェクトの「先頭で」特定の文字列に一致するものを見つけたいときは、`^` (the caret symbol) を次のように使う。

```{r}
str_extract(eg_Acton, pattern = "^corrupt")
```

```{r}
str_extract(eg_Acton, pattern = "^Power")
```

同様に、文字列の「末尾で」一致を探すときは、`$` を使う。

```{r}
str_extract_all(c(eg_Acton, eg_Wilde), pattern = ".$")
```


## 正規表現

　ウェブ上に存在するデータのほとんどはテキスト（文字）である。また、その大部分はデータセットとして利用可能な状態に構造化されていない。構造化されていない文字の集合そのものをデータとして利用する場合もあるが、たいていの場合、特定のパタンに合致する文字情報だけを取り出して利用したい。 よって、文字列の中から特定のパタンに当てはまるものを見つけてそれを取り出す必要がある。そのために使われるのが、**正規表現 (regular expressions)** である。

　ここでは、基本的な正規表現を紹介する。

### 一般的なパタン一致

　ここまでは、特定の文字列に一致する文字列を見つけてきた。 しかし、正規表現を使うと、より一般的なパタンに一致する文字列を見つけることができる。
たとえば、`.` (dot) は正規表現ではあらゆる文字 (character) と一致する。

```{r}
str_extract_all(eg_Wilde, pattern = "i.")
```

ドット自体を取り出したいときは、バックスラッシュ と一緒にして `\.` とする。

```{r}
str_extract_all(eg_Wilde, pattern = '\\.')
```

ここで、バックスラッシュ (`\`) はRで定義された文字列の意味から私たちを逃してくれるので、 エスケープ文字 (escape character) と呼ばれる。R（やその他の多くのプログラミング言語における正規表現）において `.` は「あらゆる文字」を意味するが、`\.` はその意味から私たちを解放し、ドットそのものとの一致を探してくれる。 ただし、バックスラッシュ自体が正規表現のバックスラッシュであることをRに伝えるために、バックスラッシュを二重にする必要がある。

　"it" または "in"を見つけるには次のようにする。

```{r}
str_extract_all(eg_Wilde, pattern = "i[tn]")
```

つまり、`[]` で囲まれ文字のうちいずれかが入るパタンで一致を探す。

パタンではなく、単語としての "it" と "in" のみを抜き出す（たとえば、littleに含まれる "it" は除く）には、次のようにする。

```{r}
str_extract_all(eg_Wilde, pattern = "\\bi[tn]\\b")
```

`\b`は、そこが単語の境界 (boundary) であることを示す。

ある文字**以外**を指定したいとき、たとえば、i から始まりt以外で終わる2文字の単語は、`[^]`を使って次のようにして取り出せる。

```{r}
str_extract_all(eg_Wilde, pattern = "\\bi[^t]\\b")
```

　これらの例からわかるように、正規表現を使えば様々な条件にあった文字列を探し出すことができる。
[@tbl-regex1-html]{.content-visible when-format="html"}
[@tbl-regex1-pdf]{.content-visible when-format="pdf"}
に、よく使う正規表現のパタンを示す。

```{r}
#| label: tbl-regex1-html
#| eval: !expr knitr::is_html_output()
#| echo: false
#| message: false
#| tbl-cap: "よく使う正規表現"
data.frame(正規表現 = 
             c("[:digit:]",
               "[:lower:]",
               "[:upper:]",
               "[:alpha:]",
               "[:alnum:]",
               "[:punct:]",
               "[:blank:]",
               "[:space:]",
               "[:print:]"),
           意味 = 
             c("数字（0, 1, 2, ..., 9）",
               "小文字（a, b, c, ..., z）",
               "大文字（A, B, C, ..., Z）",
               "アルファベット (a, b, ..., z と A, B, ..., Z",
               "アルファベットと数字（a, ..., z, A, ..., Z, 0, ..., 9）",
               "パンクチュエーション文字（! \" # $ % & ’ ( ) * + , - . /）",
               "空白文字（スペースとタブ）",
               "スペース文字（スペース、タブ、改行など）",
               "印刷可能な文字 ([:alnum:], [:punct:], [:space:])")) |> 
  gt() |> 
  tab_style(style     = cell_text(align = "center"),
            locations = cells_column_labels()) |> 
  gt_theme_espn()
```

```{r}
#| label: tbl-regex1-pdf
#| eval: !expr knitr::is_latex_output()
#| echo: false
#| message: false
#| tbl-cap: "よく使う正規表現"
if (!("regex1.png" %in% dir("Figs/String"))) {
  temp_tbl <- data.frame(正規表現 = 
             c("[:digit:]",
               "[:lower:]",
               "[:upper:]",
               "[:alpha:]",
               "[:alnum:]",
               "[:punct:]",
               "[:blank:]",
               "[:space:]",
               "[:print:]"),
           意味 = 
             c("数字（0, 1, 2, ..., 9）",
               "小文字（a, b, c, ..., z）",
               "大文字（A, B, C, ..., Z）",
               "アルファベット (a, b, ..., z と A, B, ..., Z",
               "アルファベットと数字（a, ..., z, A, ..., Z, 0, ..., 9）",
               "パンクチュエーション文字（! \" # $ % & ’ ( ) * + , - . /）",
               "空白文字（スペースとタブ）",
               "スペース文字（スペース、タブ、改行など）",
               "印刷可能な文字 ([:alnum:], [:punct:], [:space:])")) |> 
  gt() |> 
  tab_style(style     = cell_text(align = "center"),
            locations = cells_column_labels()) |> 
  gt_theme_espn()
  gtsave_extra(temp_tbl, "Figs/String/regex1.png")
}

knitr::include_graphics("Figs/String/regex1.png")
```

また、特別な意味をもつ記号を @tbl-regex2 に示す。
これらを使うときには `\\w` のようにバックスラッシュを1つ増やす必要がある。

```{r}
#| label: tbl-regex2
#| echo: false
#| message: false
#| tbl-cap: "特別な意味をもつ記号"
data.frame(正規表現 = 
             c("\\w",
               "\\W",
               "\\s",
               "\\S",
               "\\d",
               "\\D",
               "\\b",
               "\\B",
               "\\<",
               "\\>",
               "^",
               "$"),
           意味 = 
             c("文字",
               "文字以外",
               "スペース文字",
               "スペース文字以外",
               "数字",
               "数字以外",
               "単語の境界",
               "単語の境界以外",
               "単語の先頭",
               "単語の末尾",
               "文字列の先頭",
               "文字列の末尾")) |> 
  gt() |> 
  tab_style(style     = cell_text(align = "center"),
            locations = cells_column_labels()) |> 
  gt_theme_espn()
```

　これらの正規表現を組み合わせて使うことで、様々なパタンに一致する文字列を探したり、抜き出したり、入れ替えたりすることができる。さらに、それぞれの正規表現に一致する回数も指定することができる。たとえば、5文字の単語を探すには、次のようにする。

```{r}
str_extract_all(eg_Wilde, pattern = "\\b[:alpha:]{5}\\b")
```

数を指定するときは、 @tbl-regex3 に示す限量詞 (quantifier) を登場回数を指定したい表現の直後につける。

```{r}
#| label: tbl-regex3
#| echo: false
#| message: false
#| tbl-cap: "正規表現と一緒に使う限量詞"
data.frame(限量詞 = 
             c("?",
               "*",
               "+",
               "{m}",
               "{m,}",
               "{m,n}"),
           意味 = 
             c("直前の表現と0回以上一致（あってもなくてもよい）で、最大で1回一致",
               "直前の表現と0回以上一致",
               "直前の表現と1回以上一致",
               "直前の表現とちょうどm回一致",
               "直前の表現とm回以上一致",
               "直前の表現とm回以上n回以下の一致")) |> 
  gt() |> 
  tab_style(style     = cell_text(align = "center"),
            locations = cells_column_labels()) |> 
  gt_theme_espn()
```

限量詞をつけない場合はちょうど1回一致である。

　これらの限量詞を使うと、指定した条件に一致する範囲において**貪欲マッチング (greedy matching)** が実行される。貪欲マッチングとは、パタンに一致するもののうち、できるだけ長いものとマッチしようとする性質である。たとえば、以下の例を見てみよう。

```{r}
cats <- c("猫猫猫猫猫猫虎猫猫虎")
str_extract(cats, pattern = ".+虎")
```

限量詞`+`で「何らかの文字」が**1回以上**出現した後に「虎」が1回（限量詞がないので、ちょうど1回）出現するパタンを抜き出したところ、先頭の猫から途中の虎を1回含んで最後の猫までを貪欲に抜き出した。

　同様に、次の例を見てみよう。

```{r}
str_extract(cats, pattern = "猫+\\w+")
```

この例では、限量詞`+`で「猫」が**1回以上**出現した後に「何らかの文字」が**1回以上**出現するパタンを抜き出したところ、先頭の「猫」から6個の猫が貪欲に抜き出された後に、1回以上の何らかの文字として「虎猫猫虎」が抜き出された。結果として、文字列全体が抽出された。

　では、「猫虎」という2文字だけを抜き出したいときはどうすればいいのだろうか。そのような処理には、**怠惰マッチング (lazy matching)** を使う。怠惰マッチングを実行する際には、限量詞の後に`?` を付ける。
　
　たとえば、次のようにする。

```{r}
str_extract(cats, pattern = ".+?虎")
```

限量詞`+`で「何らかの文字」が1回以上出現した後に「虎」が1回というパタンを指定しているが、前半の「1回以上」の部分を`+?`として怠惰マッチングにした効果として、（2回目ではなく）1回目の「虎」まででマッチングが終了している。ただし、「虎」の前についている「猫」の個数は1個ではないので注意が必要である。

　同様に、次の例を見てみよう。

```{r}
str_extract(cats, pattern = "猫+?\\w+?")
```

ここでは、「猫」を1回以上怠惰にマッチした後に、何らかの文字を1回以上怠惰にマッチするという指示をしている。結果として、最初の2文字「猫猫」の時点で条件を満たし、マッチングが完了している。

　`+?` だけでなく、`*?`、`??`、`{m,n}?` なども怠惰マッチングとして利用できる。

　例を用いて、正規表現の使い方をもう少し確認してみよう。練習のために、似たような文字列をいくつか含むベクトル `y_names` を用意する。

```{r}
y_names <- c("Yada", "Yano", "Yamada", "Yamaji", "Yamamoto", 
             "Yamashita", "Yamai", "Yanai", "Yanagi", "Yoshida")
```

この中から、"Ya.a.+" というパタンに一致する文字列のみ抜き出そう（結果を見やすくするために、`unlist()`を使ってベクトルにする）。

```{r}
y_names |> 
  str_extract_all(pattern = "Ya.a.+") |> 
  unlist()
```

これらの文字列のみが抜き出された理由はわかるだろうか？たとえば、"Yada" が抜き出されなかったのはなぜだろうか？それは、パタンで指定した"Ya.a.+" の".+"が、"Ya.a"の後に何らかの文字が1回以上出現することを要求しているからである。
したがって、その部分を".?"に変えると、結果が変わる。

```{r}
y_names |> 
  str_extract_all(pattern = "Ya.a.?") |> 
  unlist()
```

　他のパタンもいくつか試してみよう。

```{r}
y_names |> 
  str_extract_all(pattern = "Ya.a.?i") |> 
  unlist()
```

```{r}
y_names |> 
  str_extract_all(pattern = "Y.+da") |> 
  unlist()
```

```{r}
y_names |> 
  str_extract_all(pattern = "Yama.+t.?") |> 
  unlist()
```

```{r}
y_names |> 
  str_extract_all(pattern = "Ya[:alpha:]{4}$") |> 
  unlist()
```

```{r}
y_names |> 
  str_extract_all(pattern = "^\\w{6,}$") |> 
  unlist()
```

```{r}
y_names |> 
  str_extract_all(pattern = "^[:alpha:]{6,8}$") |> 
  unlist()
```

```{r}
y_names |> 
  str_extract_all(pattern = "\\w+m\\w+") |> 
  unlist()
```

### 文字列操作の例

例として、全国の市区役所と町村役場のデータ `Offices.csv`を読み込んで利用する。

```{r}
Offices <- read_csv("Data/Offices.csv")
```

```{r}
head(Offices, n = 3)
```

このデータフレームには5つの列がある。このうち、`Address`に注目しよう。この列には、役所・役場の住所が記録されている。

```{r}
Offices$Address[1:5]
```

練習として、ここから都道府県名のみを抜き出してみよう。
当然ながら、都道府県名の末尾は「都」「道」「府」「県」のいずれかなので、「何らかの文字列を1回以上 (`\\w+)`」含み、その後に「都または道または府まはた県を1回 (`[都道府県]`)」というパタンを試してみよう（実は、これはうまくいかない）。
各都道府県を1回だけ抜き出すために、最後に`unique()`を使う。

```{r}
try1 <- Offices |> 
  pull(Address) |> 
  str_extract(pattern = "\\w+[都道府県]") |> 
  unique()
length(try1)
```

得られた都道府県の数が111になっており、「失敗」したことがわかる。結果を一部見てみよう。

```{r}
try1[1:10]
```

抽出したすべての文字列の末尾が「都道府県」で終わっている。
つまり、私たちのRが（いつも通り！）私たちの指示に従ってくれたという意味において、この結果は決して失敗ではない。しかし、都道府県名のみを抽出するという私たちの希望通は叶えられなかった。
パタンの指示がまずかったのだ。

　`\\w+[都道府県]`というパタン指示では、`\\w+`の部分が貪欲マッチングになっている。
そのため、`[都道府県]`という文字を最後に含む文字列のうち、最も長い文字列が抽出されたのだ。

　貪欲マッチングを怠惰マッチングに変えて、もう1度試してみよう。

```{r}
try2 <- Offices |> 
  pull(Address) |> 
  str_extract(pattern = "\\w+?[都道府県]") |> 
  unique()
length(try2)
```

47の都道府県が抽出されたようだ。果たして、うまくいったのだろうか。
確認してみよう。

```{r}
try2
```

この結果には1つ問題がある。基本的には都道府県名が「都道府県」までを含めて抽出されているが、京都府のみ「京都」になってしまった。これは、京都の「都」が「都道府県」にマッチしたためである。今回のパタン指示の問題はどこにあったのだろうか。問題は、「都」の前の「京」のみで、怠惰マッチングである`"\\w+?`に合致してしまった点にある。

　こういうときには、自分がもっている知識が役に立つことがある。私たちは、日本の都道府県名（末尾の`[都道府県]`を除く）が、2文字または3文字であることを知っている。この知識を使えば、「京」という1文字だけが取り出されるパタンを除外することができる。2文字以上3文字以下で怠惰マッチングを実行するために`{2,3}?`という限量詞を使う。

```{r}
try3 <- Offices |> 
  pull(Address) |> 
  str_extract(pattern = "\\w{2,3}?[都道府県]") |> 
  unique()
length(try3)
try3
```

これで、市区町村役場（所）の住所から、47都道府県の名前を抽出することができた。

ここから、末尾の`[道府県]`を取り除いてみよう（北海道はそのまま残す）。`str_replace()` を使って、特定の文字列を`""`（つまり、何も含まない文字列）に置換 (replace) する[^str_remove]。

[^str_remove]: 特定の文字列を削除するだけなら`str_replace()`でなく、`str_remove()`を使っても良い。これは`replacement = ""`と指定された`str_replace()`と同じ機能をする。したがって、`str_replace(pattern = "[都府県]", replacement = "")`は`str_remove(pattern = "[都府県]")`と簡略化することができる。

```{r}
try3 |> 
  str_replace(pattern = "[都府県]",
              replacement = "")
```

ほとんどの都道府県については意図通りの結果が得られたが、「京都府」については「都」が取り除かれて「京府」になってしまった。これを防ぐためには、`[道府県]`が末尾にあることを`$`で指定すればよい。次のようにする。

```{r}
try3 |> 
  str_replace(pattern = "[都府県]$",
              replacement = "")
```

これで望み通りの結果が得られた。

次に、`Offices` の `Tel`の列に注目しよう。
この列には、電話番号が記録されている。
ハイフンで番号が区切られているので、それを利用して市外局番を抜き出してみよう。
数字を1文字以上の怠惰マッチング (`\\d+?`) の後に、ハイフン1つとマッチング (`-`) するパタンを指定する。ただし、必要なのは数字だけなので、ハイフンまでを含む文字列を抽出した後、ハイフンを取り除く。

```{r}
area_code <- Offices |> 
  pull(Tel) |> 
  str_extract(pattern = "\\d+?-") |> 
  str_replace(pattern = "-",
              replacement = "")
head(area_code)
```

0から始まる数字が抜き出されている。市外局番の桁数を調べてみよう。

```{r}
area_code |> 
  str_length() |> 
  table()
```

市外局番の桁数は、2桁から5桁までであることがわかる。ユニークな市外局番の個数は、

```{r}
area_code |> 
  unique() |> 
  length()
```

である。

最後に、電話番号の下4桁を抜き出してみよう。
パタン一致の代わりに、`str_sub()` で最後から4文字目 (`-4`) から最後まで（`end` は指定しない）を抽出する。

```{r}
last4 <- Offices |> 
  pull(Tel) |> 
  str_sub(start = -4)
head(last4)
```

念の為、すべての結果が4桁であることを確認する。まず、4文字であることを確認する。

```{r}
last4 |> 
  str_length() |> 
  table()
```

すべて4文字である。次に、すべてが数字であることを確認する。そのために`str_count()` で、特定のパタンに一致する回数を数える。ここでは、`pattern = "\\d"` で数字を指定し、その回数が4になることを確かめる。

```{r}
last4 |> 
  str_count(pattern = "\\d") |> 
  table()
```

すべの結果で数字が4回登場することが確認できた。文字の長さが4であることと合わせて、4桁の数字の抜き出しに成功したことがわかる。

ユニークな電話番号下4桁の個数は、

```{r}
last4 |> 
  unique() |> 
  length()
```

であり、下4桁については同じ番号が多く利用されていることがわかる。

北海道を例として、電話番号についてもう少し詳しく検討しよう。
そのために、まず北海道のデータを抜き出そう。住所 (`Address`) に「北海道」という文字列が含まれている行を、`dplyr::filter()` と`stringr::str_detect()` で抜き出す。

```{r}
H <- Offices |> 
  filter(str_detect(Address, pattern = "北海道")) 
head(H, n = 3)
tail(H, n =3)
nrow(H)
```

北海道には179の市区町村がある。このデータに対し、先程と同じ方法で電話番号の下4桁を抽出する。

```{r}
H_last4 <-  H |> 
  pull(Tel) |> 
  str_sub(start = -4)
H_last4 |> 
  unique() |> 
  length()
```

179の自治体に対し、電話番号下4桁のパタンは58しかない。
下2桁はどうだろうか？

```{r}
H |> 
  pull(Tel) |> 
  str_sub(start = -2) |> 
  table()
```

下2桁は全部で20パタンあるが、ほとんどの自治体で下2桁が「11」になっていることがわかる。
入力しやすい電話番号にしようという配慮だろう。


## 文書データの分析


  「吾輩は猫である」

　にゃーにゃーにゃにゃーにゃにゃにゃ！にゃーにゃー！
















