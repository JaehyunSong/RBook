# (PART) データハンドリング {-}

# データハンドリング [基礎編: 抽出] {#datahandling1}

```{r handling1-common}
#| include: FALSE
source("_common.R")
```

ここでは比較的綺麗に整形されているデータフレームを扱う方法について考えます。ここでいう「比較的綺麗なデータ」とは、すぐに分析に使えるレベルのデータを意味します。したがって、ここではデータ内の値を変更するような作業は行いません。基本的に分析しやすくなるように列の順番を替えたり、特定の列や行のみを抽出したり、データの順番を並び替える作業に注目します。

本性では以下の3つの内容を中心に解説します。

1. パイプ演算子 (`%>%`)に慣れる
2. 特定の行と列の抽出
3. データのソート

本章で学習する内容でデータを加工した場合、得られる結果物は元のデータの一部 (subset)となります。データの中身の値を変えたり、新しい列を追加したり、平均値などの記述統計量をまとめたりする方法については次の第\@ref(datahandling2)章で解説します。

---

## データハンドリングとtidyverse {#handling1-intro}

> The tidyverse is an opinionated collection of R packages designed for data science. All packages share an underlying design philosophy, grammar, and data structures. (Tidyverseホームページから)

Tidyverseとはデータサイエンスのために考案された、強い信念と思想に基づいたRパッケージの集合です。Tidyverseに属するパッケージは思想、文法およびデータ構造を共有しています。Tidyverseの中核をなすパッケージは{ggplot2} (第\@ref(visualization1)、\@ref(visualization2)、\@ref(visualization3)、\@ref(visualization4)章)、{dplyr} (第\@ref(datahandling1)、\@ref(datahandling2)章)、{tidyr} (第\@ref(tidydata)章)、{readr} (第\@ref(io-read)章)、{purrr} (第\@ref(iteration)章)、{tibble} (第\@ref(structure-dataframe)章)、{stringr} (第\@ref(string)章)、{forcats} (第\@ref(factor)章)があり、このパッケージを支える数十のパッケージが含まれています。これらのパッケージは個別に読み込む必要はなく、{tidyverse}パッケージを読み込むだけで十分です。

```{r handling1-setup}
pacman::p_load(tidyverse)
```

Rにおけるデータハンドリング (データ操作) の標準が{dplyr}と{tidyr}中心となり、文字列の処理は{stringr}、factor型の操作は{forcats}、大量のモデルを自動的に分析し、結果を処理するためには{tibble}と{purrr}、可視化は{ggplot2}が主に使われています。これらのパッケージ間、あるいはパッケージ内におけるオブジェクトのやり取りは全てパイプ演算子を通じて行われています。また、これらのパッケージは整然データ (tidydata) を想定するか、整然データの作成するに特化しています。

tidyverseの思想に基づいた「tidyverse流のコーディング」は現在のRそのものと言っても過言ではありません。ただし、tidyverseじゃないと出来ないデータハンドリング、可視化などはありません。tidyverseはデータサイエンスの思想に近いものであり、「異なる思想を持っているからこのような分析はできない」といったものはありません。tidyverseという概念が提唱される前にもRは存在し、tidyverse無き世界で今と同じことをやってきました。ただし、tidyverse流で書かれたRコードは可読性が優れ、コードを書く手間も短くなります。tidyverseの考え方がRのける「標準語」として定着しつつあるのは否めない事実であり、学習する誘引としては十分すぎるでしょう。

---

## パイプ演算子 (`%>%`) {#handling1-pipe}

{dplyr}パッケージを利用する前にパイプ演算子について説明します。パイプ演算子は{dplyr}に含まれている演算子ではなく、`magrittr`という別のパッケージから提供される演算子ですが、{tidyverse}パッケージを読み込むと自動的に読み込まれます。パイプ演算子は`x %>% y()`のような書き方となりますが、これは「`x`を`y()`の第一引数として渡す」ことを意味します。`x`の部分はベクトルやデータフレームのようなオブジェクトでも、関数でも構いません。なぜなら、関数から得られた結果もまたベクトルやデータフレームといったものになるからです。つまり、`x() %>% y()`という使い方も可能です。そして、パイプは無限に繋ぐこともできます。「データ`df`を関数`x()`で処理をし、その結果をまた関数`y()`で処理する」ことは、パイプを使うと`df %>% x() %>% y()`のような書き方となります。

たとえば、「`paste(3, "+", 5, "=", 8)`を実行し、その結果を`rep()`関数を使って3回複製し、それを`print()`を使って出力する」コードを考えてみましょう。方法としては2つ考えられます。まずは、それぞれの処理を別途のオブジェクトに格納する方法です。そして二つ目は関数の中に関数を使う方法です。

```{r handling1-pipe-1}
# 方法1: 一関数一オブジェクト
Result1 <- paste(3, "+", 5, "=", 8)
Result2 <- rep(Result1, 3)
print(Result2)

# 方法2: 関数の中に関数の中に関数
print(rep(paste(3, "+", 5, "=", 8), 3))
```

どれも結果は同じです。コードを書く手間を考えれば、後者の方が楽かも知れませんが、可読性があまりよくありません。一方、前者は可読性は良いものの、コードも長くなり、オブジェクトを2つも作ってしまうのでメモリの無駄遣いになります。

コードの可読性と書く手間、両方を満足する書き方がパイプ演算子`%>%`です。まずは、例から見ましょう。

```{r handling1-pipe-2}
# %>%を使う
paste(3, "+", 5, "=", 8) %>% rep(3) %>% print()
```

まず、結果は先ほどと同じです。それではコードの説明をしましょう。まずは、`paste(3, "+", 5, "=", 8)`を実行します。そしてその結果をそのまま`rep()`関数の第一引数として渡されます。つまり、`rep(paste(3, "+", 5, "=", 8), 3)`になるわけです。ここでは`rep(3)`と書きましたが、第一引数が渡されたため、`3`は第二引数扱いになります (パイプ演算子前のオブジェクトを第二、三引数として渡す方法は適宜説明します。)。そして、これをまた`print()`関数に渡します。結果としては`print(rep(paste(3, "+", 5, "=", 8), 3))`となります。

関数を重ねると読む順番は「カッコの内側から外側へ」になりますが、パイプ演算子を使うと「左 (上)から右 (下)へ」といったより自然な読み方が可能になります。また、以下のコードのように、パイプ演算子後に改行を行うことでより読みやすいコードになります。これからはパイプ演算子の後は必ず改行をします。

```{r handling1-pipe-3}
#| eval: FALSE
# 改行 (+字下げ)したらもっと読みやすくなる
paste(3, "+", 5, "=", 8) %>% 
    rep(3) %>% 
    print()
```

パイプ演算子を使わない方法は図\@ref(fig:handling1-pipe-4)のようにイメージできます。一回の処理ごとに結果を保存し、それをまた次の処理時においてデータとして使うイメージです。

```{r handling1-pipe-4}
#| echo: FALSE
#| out.width: "80%"
#| fig.cap: "パイプ演算子を使わない場合"
knitr::include_graphics("Figures/Handling1/Pipeline1.png")
```

一方、図\@ref(fig:handling1-pipe-5)はパイプ演算子を使う場合のプロセスです。処理後の結果を保存せず、すぐに次のプロセスに渡すことで、メモリ (図だとボウル)や時間、コードの無駄を減らすことができます。むろん、図\@ref(fig:handling1-pipe-4)の結果1を使って色々試してみたい場合は、一旦結果1までは格納し、適宜引き出して使った方が効率的でしょう。パイプ演算子はたしかに便利で、「今どき」のRの書き方を象徴するようなものですが、一つの結果を出すまであまりにも多くのパイプ演算子を使うことはあ望ましくありません。

```{r handling1-pipe-5}
#| echo: FALSE
#| out.width: "100%"
#| fig.cap: "パイプ演算子を使う場合"
knitr::include_graphics("Figures/Handling1/Pipeline2.png")
```

データハンドリングもこれど同様に、様々な作業を順に沿って行う必要があります。例えば、「(1) 列を選択して、(2) 欠損値を含む列を除去して、 (3) ある変数の値を100倍にして、(4) ある変数の値がが小さい行から大きい順へ並び替える」といった手順です。これらの作業はパイプ演算子を使えば、スムーズに行うことが可能です。

## 列の抽出 {#handling1-select}

それでは今回の実習用データを読み込みましょう。[Ramen.csv](Data/Ramen.csv)には「[ぐるなび](https://www.gnavi.co.jp)」から取得したラーメン屋6292店舗の情報が入っています。具体的には東京、神奈川、千葉、埼玉、大阪、京都、兵庫、奈良、和歌山それぞれ都府県にあるラーメン屋の中から最大1000店舗の情報を抽出したものです。東京都は、ぐるなびに登録したラーメン屋が3000店舗以上ですが、1000店舗の基準はぐるなびの「おすすめ」の順で上位1000店舗となります。また、店側またはぐるなびが登録したカテゴリを基準に抽出したため、実際はラーメン屋ではないにもかかわらずラーメン屋としてデータ内に含まれている可能性があります。

まず、このデータを読み込み、`df`という名付けます。

```{r handling1-select-1}
#| message: FALSE
df <- read_csv("Data/Ramen.csv")
```

データの中身を確認してみましょう。

```{r handling1-select-2}
df
```

1行目の`# A tibble: 2,000 x 12`から、ケース数 (店舗数)は2000、変数は12個あることが分かります。各変数の詳細は以下の通りです。

```{r handling1-select-3}
#| echo: FALSE
#| message: FALSE
data.frame(変数名 = c("`ID`", "`Name`", 
                   "`Pref`", "`Zipcode`", "`Latitude`", "`Longitude`",
                   "`Line`", "`Station`", "`Walk`", "`Bus`", "`Car`",
                   "`Budget`", "`ScoreN`", "`Score`"),
              説明 = c("店舗ID",
                     "店舗名",
                     "店舗の所在地 (都府県)",
                     "店舗の郵便番号",
                     "緯度",
                     "経度",
                     "最寄りの駅の路線",
                     "最寄りの駅",
                     "最寄りの駅からの距離 (徒歩; 分)",
                     "最寄りの駅からの距離 (バス; 分)",
                     "最寄りの駅からの距離 (車; 分)",
                     "平均予算 (円)",
                     "口コミの数",
                     "口コミ評価の平均値")) %>%
    kable() %>%
    kable_styling(bootstrap_options = "striped",
                  full_width        = FALSE,
                  latex_options     = "hold_position") %>%
    row_spec(0, align = "c")
```

それではここからは`df`を用いた{dplyr}の様々な機能を紹介していきます。

### 特定の列を抽出する

まずは、データフレームから特定の列のみを残す、除去する方法について紹介します。たとえば、`df`から`ID`、`Name`、`Pref`、`Score`のみを残すとします。{dplyr}を使わない方法と{dplyr}の`select()`関数を使った方法を紹介します。

```{r handling1-select-4}
# dplyrを使わない方法
df[, c("ID", "Name", "Pref", "Score")]

# dplyr::select()を使う方法
# select(df, ID, Name, Pref, Score)でもOK
df %>%
  select(ID, Name, Pref, Score)
```

どれも結果は同じですが、`select()`関数を使った方がより読みやすいコードになっているでしょう。むろん、`select()`関数を使わない方がスッキリする方も知るかも知れません。実際、自分でパッケージなどを作成する際は`select()`を使わない場合が多いです。ただし、一般的な分析の流れでは`select()`の方がコードも意味も明確となり、パイプ演算子でつなぐのも容易です。

`select()`関数の使い方は非常に簡単です。第一引数はデータフレームですが、パイプ演算子を使う場合は省略可能です。第二引数以降の引数はデータフレームの変数名です。つまり、ここには残す変数名のみを書くだけで十分です。

また、`select()`関数を使って列の順番を変えることもできます。たとえば、`ID`、`Pref`、`Name`、`Score`の順で列を残すなら、この順番で引数を書くだけです。

```{r handling1-select-5}
df %>%
  select(ID, Pref, Name)
```

### 特定の列を抽出し、列名を変更する

また、特定の列を残す際、変数名を変更することも可能です。今回も`ID`、`Name`、`Pref`、`Score`のみを残しますが、`Pref`列は`Prefecture`に変えてみましょう。

```{r handling1-select-6}
df %>%
  select(ID, Name, Prefecture = Pref, Score)
```

抽出する際、変数を`新しい変数名 = 既存の変数名`にするだけで、変数名が簡単に変更できました。もし、特定の列は抽出しないものの、変数名を変えるにはどうすれば良いでしょうか。ここでは`df`の`Pref`を`Prefecture`に、`Walk`を`Distance`に変更してみます。{dplyr}を使わない場合と{dplyr}の`rename()`関数を使う場合を両方紹介します。

まずは、`name()`関数についてですが、これはデータフレームの変数名をベクトルとして出力する関数です。

```{r handling1-select-7}
names(df)
```

察しの良い読者は気づいたかも知れませんが、`names(データフレーム名)`の結果はベクトルであり、上書きも可能です。つまり、`names(df)`の3番目と9番目の要素を`"Prefecture"`と`"Distance"`に上書きすることができるということです。

```{r handling1-select-8}
# dplyrを使わずに列名を変更する方法
names(df)[c(3, 9)] <- c("Prefecture", "Distance")

# dfの中身を出力
df
```

簡単に変数名の変更ができました。続いて、{dplyr}の`rename()`関数を使った方法です。今回は、`Prefecture`を`Pref`に、`Distance`を`Walk`に戻して見ましょう。そして、出力するだけにとどまらず、`df`に上書きしましょう。

```{r handling1-select-9}
# dfのPrefectureをPrefに、DistanceをWalkに変更し、上書きする
df <- df %>%
  rename(Pref = Prefecture, Walk = Distance)
```

これで終わりです。実は`select()`関数と使い方がほぼ同じです。ただし、残す変数名を指定する必要がなく、名前を変更する変数名と新しい変数名を入れるだけです。変数が少ないデータなら`select()`でもあまり不便は感じないかも知れませんが、変数が多くなると`rename()`関数は非常に便利です。

### 特定の列を除外する

逆に、一部の変数をデータフレームから除去したい場合もあるでしょう。たとえば、緯度 (`Latitude`)と経度 (`Longitude`)はラーメン屋の情報としては不要かもしれません。この2つの変数を除外するためにはどうすれば良いでしょうか。まず考えられるのは、この2つの変数を除いた変数を指定・抽出する方法です。

```{r handling1-select-10}
df %>%
  select(ID, Name, Pref, Zipcode, 
         Line, Station, Walk, Bus, Car, Budget, ScoreN, Score)
```

かなり長いコードになりましたね。しかし、もっと簡単な方法があります。それは`-`を使う方法です。

```{r handling1-select-11}
df %>%
  select(-Latitude, -Longitude) # select(-c(Latitude, Longitude))
```

除外したい変数名の前に`-`を付けただけです。また、`-Latitude`と`-Longitude`をそれぞれ指定せず、`-c(Latitude, Longitude)`のように`c()`でまとめるのも可能です。

### 隣接した列を指定する

先ほど、`df`から緯度 (`Latitude`)と経度 (`Longitude`)を除外する例を考えてみましょう。`-`を使うと簡単ですが、場合によっては残す変数名を指定する必要もあります。

```{r handling1-select-12}
#| eval: FALSE
df %>%
  select(ID, Name, Pref, Zipcode, 
         Line, Station, Walk, Bus, Car, Budget, ScoreN, Score)
```

よく考えてみれば、`ID`から`Zipcode`は隣接した列ですし、`Line`から`Score`までもそうです。これは`names()`関数で確認できます。

```{r handling1-select-13}
names(df)
```

ここで便利な演算子が`:`です。これまで、`x`から`y`までの公差1の等差数列を作成する際に`x:y`を使って来ましたが、これに非常に似ています。データフレームの「`x`列から`y`列まで」の表記も`select()`関数内では`:`と書くことができます。したがって、上記のコードは以下のように短縮化可能です。

```{r handling1-select-14}
#| eval: FALSE
df %>%
  select(ID:Zipcode, Line:Score)
```

「`df`の`ID`から`Zipcode`まで、そして`Line`から`Score`までの列を選択する」という意味です。非常に便利な演算子ですので、`-`と合わせて覚えておきましょう。

### 一部の列の順番だけを変える

ある列の位置を替えたいとします。たとえば、`Score`と`ScoreN`をそれぞれ1列目、2列目にしたい場合、どうすれば良いでしょうか。これまで勉強したことを考えると、以下のようなコードで問題ないでしょう。

```{r handling1-select-15}
df %>%
  select(Score, ScoreN, ID:Budget)
```

しかし、{dplyr}には`relocate()`というより便利な専用関数を提供しています。`relocate()`には変数名を指定するだけですが、ここで指定した変数がデータフレームの最初列の方に移動します。

```{r handling1-select-16}
df %>%
  relocate(Score, ScoreN)
```

`relocate()`を使うと`ID:Budget`が省略可能となり、より短いコードになります。もう一つの例は、最初に持ってくるのではなく、「ある変数の前」または「ある変数の後」に移動させるケースです。これも`relocate()`で可能ですが、もう一つの引数が必要です。`Pref`と`Zipcdoe`の順番を変えるなら、まずは以下のような方法が考えられます。

```{r handling1-select-17}
df %>%
  select(ID:Name, Zipcode, Pref, Latitude:Score)
```

これを`relocate()`で書き換えるなら、`.after`または`.before`引数が必要になります。`relocate(変数名1, .after = 変数名2)`は「変数1を変数2の直後に移動させる」
ことを意味します。

```{r handling1-select-18}
df %>%
  relocate(Pref, .after = Zipcode)
```

`.before`を使うことできます。この場合は「`Zipcode`を`Pref`の直前に移動させる」
ことを指定する必要があります。結果は省略しますが、自分でコードを走らせ、上と同じ結果が得られるかを確認してみてください。


```{r handling1-select-19}
#| eval: FALSE
df %>%
  relocate(Zipcode, .before = Pref)
```

### `select()`の便利な機能

`select()`関数は他にも便利な機能がいくつかあります。ここではいくつの機能を紹介しますが、より詳しい内容は`?dplyr::select`を参照してください。

**`starts_with()`と`ends_with()`、`contains()`、`num_range()`: 特定の文字を含む変数を選択する**

まずは、特定の文字を含む変数名を指定する方法です。`starts_with("X")`、`ends_with("X")`、`contains("X")`は変数名が`"X"`で始まるか、`"X"`で終わるか、`"X"`を含むかを判断し、条件に合う変数名を返す関数です。実際の例を見ましょう。

```{r handling1-select-20}
# ID、Nameに続いて、Scoreで始まる変数名を抽出
df %>%
  select(ID, Name, starts_with("Score"))

# eで終わる変数名を除去
df %>%
  select(-ends_with("e")) # !ends_with("e")も可能

# reを含む変数名を抽出するが、ScoreNは除去する
df %>%
  select(contains("re"), -ScoreN)
```

他の使い方としては`X1`、`X2`のような「文字+数字」の変数を選択する際、`starts_with()`が活躍します。たとえば、以下のような`myDF1`があるとします。

```{r handling1-select-21}
# tibble()でなく、data.frame()も使用可能です。
myDF1 <- tibble(
  ID  = 1:5,
  X1  = c(2, 4, 6, 2, 7),
  Y1  = c(3, 5, 1, 1, 0),
  X1D = c(4, 2, 1, 6, 9),
  X2  = c(5, 5, 6, 0, 2),
  Y2  = c(3, 3, 2, 3, 1),
  X2D = c(8, 9, 5, 0, 1),
  X3  = c(3, 0, 3, 0, 2),
  Y3  = c(1, 5, 9, 1, 3),
  X3D = c(9, 1, 3, 3, 8)
)

myDF1
```

この`myDF1`から`ID`、`Y1`、`Y2`、`Y3`を抽出するにはどうすれば良いでしょうか。これらの変数は隣接していないため、`:`も使えませんが、`starts_with()`を使えば簡単です。

```{r handling1-select-22}
myDF1 %>%
  select(ID, starts_with("Y"))
```

それでは、`ID`、`X1`、`X2`、`X3`はどうでしょうか。`starts_with("X")`だと、`X1c`なども選択されてしまいますね。ここで`-ends_with()`の出番です。つまり、「まずは`starts_with("X")`で`X`で始まる変数を選択し、続いて、`D`で終わるものを除外すればいいじゃん？」です。それでは、やってみましょうか。

```{r handling1-select-23}
myDF1 %>%
  select(ID, starts_with("X"), -ends_with("D"))
```

あらら、`ID`も同時になくなりましたね[^numrange]。実はこのような時のために用意された関数があり、それが`num_range()`です。`num_range()`の第一引数は`starts_with()`関数と同じですが、第二引数も必要です。この第二引数にはnumeric型のベクトルが必要です。`1:3`でも、`c(1, 2, 3)`でも構いません。たとえば、`ID`、`X1`、`X2`、`X3`するには以下のように書きます。

[^numrange]: 実は`select(starts_with("X"), -ends_with("D"), ID)`のように順番を変えると`ID`は最後の列になりますが、とりあえず残ります。なぜなら、`select()`関数は左側から右側の方へコードを実行するからです。

```{r handling1-select-24}
myDF1 %>%
  select(ID, num_range("X", 1:3))
```

**`all_of()`と`any_of()`: 文字型ベクトルを用いた変数の選択**

`all_of()`と`any_of()`は`select()`内の変数名として文字型ベクトルを使う際に用いる関数です。これは抽出したい列名が既にcharacter型ベクトルとして用意されている場合、便利な関数です。たとえば、以下の`Name_Vec`を考えてみましょう。

```{r handling1-select-25}
Name_Vec <- c("X1", "X2", "X3")
```

この`Name_Vec`の要素と同じ列名を持つ列と`ID`列を`myDF1`から抽出する方法は以下の2通りです。

```{r handling1-select-26}
myDF1[, c("ID", Name_Vec)]

myDF1 %>%
  select(ID, all_of(Name_Vec))
```

今の例だと、`select()`を使わない前者の方が便利かも知れませんが、`select()`内に外の変数名も指定する場合も多いので、後者の方が汎用性は高いです。私から見れば、今の例でも後者の方が読みやすく、使いやすいと思います。

それでは以下のような`Name_Vec`はどうでしょう。今回は、`myDF1`に含まれていない`X4`と`X5`もあります。

```{r handling1-select-27}
#| eval: FALSE
#| error: TRUE
Name_Vec <- c("X1", "X2", "X3", "X4", "X5")

myDF1 %>%
  select(all_of(Name_Vec))
```

```
## Error: Can't subset columns that don't exist.
##   Columns `X4` and `X5` don't exist.
```

このようにエラーが出てしまします。つまり、`all_of()`の場合、引数の要素全てがデータフレームに存在する必要があります。もし、ないものは無視して、合致する列だけ取り出したいはどうすれば良いでしょうか。そこで登場するのが`any_of()`です。

```{r handling1-select-28}
myDF1 %>%
  select(any_of(Name_Vec))
```

`any_of()`の方がより使いやすいと思う方も多いでしょうが、必ずしもそうとは限りません。たとえば、`Name_Vec`に誤字などが含まれる場合、`any_of()`だと誤字が含まれている変数は取り出しません。この場合はむしろちゃんとエラーを表示してくれた方が嬉しいですね。

**`last_col()`: 最後の列を選択する**

普段あまり使わない機能ですが、最後の列を選択する`last_col()`という関数もあります。たとえば、`last_col(0)`にすると最後の列を選択し、`last_col(1)`なら最後から2番目の列を選択します。たとえば、`df`から`ID`と最後の列を取り出してみましょう。

```{r handling1-select-29}
# IDと最後の列のみを抽出
df %>%
  select(ID, last_col(0))
```

最後の2行分を取り出すことも可能です。この場合は`last_col()`の引数を長さ1ベクトルでなく、長さ2以上のベクトルにします。最後の行が`0`、その手前の行が`1`ですから、中の引数は`1:0`となります。`0:1`でも可能ですが、結果が若干異なります。

```{r handling1-select-30}
# IDと最後の2列分を抽出 (引数を1:0と設定)
df %>%
  select(ID, last_col(1:0))
```

```{r handling1-select-31}
# IDと最後の2列分を抽出 (引数を0:1と設定)
df %>%
  select(ID, last_col(0:1))
```

`last_col()`の引数を`1:0`にするか`0:1`にするかによって抽出される順番が異なります。`1:0`は`c(1, 0)`、`0:1`は`c(0, 1)`と同じであることを考えると理由は簡単です。`c(1, 0)`の場合、`last_col(1), last_col(0)`の順番で処理をし、`c(0, 1)`は`last_col(0)`、`last_col(1)`の順番で処理を行うからです。

この`last_col()`の引数を空っぽにするとそれは最後の列を意味します。これを利用すれば、「ある変数の最後の列へ移動させる」こともできます。たとえば、`ID`を最後の列に移動させたい場合、`relocate(ID, .after = last_col())`のように書きます。

**`where()`: データ型から変数を選択する**

最後に、「numeric型の列のみ抽出したい」、「character型の列だけほしい」場合に便利な`where()`関数を紹介します。`where()`の中に入る引数は一つだけであり、データ型を判定する関数名が入ります。たとえば、numeric型か否かを判断する関数は`is.numeric`です。`df`からnumeric型の変数のみを抽出したい場合は以下のように書きます。

```{r handling1-select-32}
# numeric型の列を抽出する
df %>%
  select(where(is.numeric))
```

`!`を使って条件に合致する列を除外することも可能です。もし、character型の列を除外する場合は以下のように`!where(is.character)`を指定します。

```{r handling1-select-33}
# character型でない列を抽出する
df %>%
  select(!where(is.character))
```

`&`を使って複数の条件を使うことも可能です。たとえば、`ID`変数に加えて「`"L"`で始まる変数の中でnumeric型の列を抽出」するコードは以下のようになります。

```{r handling1-select-34}
# IDと、Lで始まるnumeric型の列を抽出する
df %>%
  select(ID, starts_with("L") & where(is.numeric))
```

---

## 行の抽出 {#handling1-filter}

### 指定した行を抽出する

他にも特定の行を抽出する場合があります。たとえば、「`df`の最初の5行」や「`df`の8行目のケース」といった場合です。この操作には{dplyr}の`slice_*()`関数群が便利です。それではそれぞれの関数の使い方について紹介していきます。その前に、実習用データとして`df`から一部の列のみを抽出した`select_df`を作成します。

```{r handling1-filter-1}
select_df <- df %>% 
  select(ID, Name, Pref, Budget, Score)
```

**`slice()`: 指定した番号の行のみ抽出する**

`select_df`から2, 8, 9行目の行を抽出したいとします。このような簡単な操作はパッケージを使わず、以下のように抽出することができます。

```{r handling1-filter-2}
# select_dfから2, 8, 9行目の行を抽出し、出力する
select_df[c(2, 8, 9),]
```

しかし、以下の`slice()`関数を使うとパイプ演算子を前後に付けることが可能であり[^slice1]、コードの可読性も高いです。`slice()`関数には以下のように抽出したい行の番号を入れるだけです。

[^slice1]: 実は`select_df[, c(2, 8, 9)]`でも前後にパイプ演算子を使うことは可能ですが、コードが読みにくくなるため、推奨しません。

```{r handling1-filter-3}
# select_dfから2, 8, 9行目の行を抽出し、出力する
select_df %>% 
  slice(2, 8, 9) # slice(c(2, 8, 9))もOK
```

`slice(2, 8, 9)`でも`slice(c(2, 8, 9))`でも構いません。また、隣接した行でしたら`:`を使うことも可能です。たとえば、10行目から15行目まで抽出する場合は`slice(10:15)`のような書き方も出来ます。

**`slice_head()`: 最初のn行を抽出する**

```{r handling1-filter-4}
# select_dfから最初の3行抽出し、出力する
select_df %>% 
  slice_head(n = 3)
```

これは`head(データ名, n = 出力する個数)`と同じ動きをする関数です。注意点としては引数`n = `を必ず付ける点です。たとえば、`slice_head(3)`にすると、`select_df`の3行目のみ抽出されます。

**`slice_tail()`: 最後のn行を抽出する**

```{r handling1-filter-5}
# select_dfから最後の7行を抽出し、出力する
select_df %>% 
  slice_tail(n = 7)
```

これは`tail(データ名, n = 出力する個数)`と同じ動きをする関数です。ちなみに、この`n`引数も`n =`を明記する必要があります。

**`slice_max()`: 指定した変数が大きい順でn行抽出する**

`slice_max()`は指定した変数が大きい順で`n`行抽出する関数です。たとえば、`Budget`が高い順で4店舗を抽出する場合は以下のように書きます。

```{r handling1-filter-6}
# select_dfからScoreの値が高い順で5行を抽出し、出力する
select_df %>% 
  slice_max(Budget, n = 4)
```

**`slice_min()`: 指定した変数が小さい順でn行抽出する**

一方、`slice_min()`関数が小さい順で抽出します。

```{r handling1-filter-7}
# select_dfからScoreの値が低い順で3行を抽出し、出力する
select_df %>% 
  slice_min(Score, n = 3)
```

ただし、`n = 3`と指定したはずなのに、4行が抽出されました。これは同点のケースがあるからです。実際、`select_df`には`Score`が1のケースが4つあります。もし、同点の存在により`n`に収まらない場合、`slice_max()`、`slice_min()`関数は`n`を超える行を出力します。これを強制的に`n`行に合わせるためには`with_ties = FALSE`引数を付けます。この場合、データで格納されている順で`n`個のみ出力されます。

```{r handling1-filter-8}
select_df %>% 
  slice_min(Score, n = 3, with_ties = FALSE)
```

**`slice_sample()`: 無作為にn行を抽出する**

最後に無作為に`n`行を抽出する`slice_sample()`関数です。引数は`n`であり、抽出したい行数を指定します。たとえば、`select_df`から無作為に10行抽出したい場合は、

```{r handling1-filter-9}
# select_dfから無作為に5行を抽出し、出力する
select_df %>% 
  slice_sample(n = 10)
```

のように書きます。ブートストラップ法や機械学習における交差検証 (cross-validation)の際に有用な関数ですが、ブートストラップや機械学習のパッケージの多くはサンプル分割の関数を提供しているため、あまり使う機会はないでしょう。また、`slice_sample()`関数をブートストラップ法のために用いる場合は、ケースを反復抽出する必要があり、`replace = TRUE`を付けると反復抽出を行います。デフォルト値は`FALSE`です。

### 条件に合致する行を抽出する

これまで見てきた`slice()`を用いる行の抽出は、実際あまり使う機会がありません。多くの場合、「何かの条件と合致するケースのみ抽出する」または、「何かの条件と合致しないケースのみを抽出する」やこれらの組み合わせで行の抽出を行います。そこで登場するのが{dplyr}パッケージの`filter()`関数です。`filter()`関数の使い方は以下の通りです。

```{r handling1-filter-10}
#| eval: FALSE
# dplyr::filter()の使い方
filter(データフレーム名, 条件1, 条件2, ...)
```

むろん、第一引数がデータですから、`%>%`を使うことも可能です。

```{r handling1-filter-11}
#| eval: FALSE
# dplyr::filter()の使い方 (パイプを使う方法)
データフレーム名 %>%
  filter(条件1, 条件2, ...)
```

まずは、条件が一つの場合を考えてみましょう。ここでは「`Pref`が`"京都府"`であるケースのみに絞り、`Name`と`Station`、`Score`列のみを出力する」ケースを考えてみましょう。まず、`filter()`関数で行を抽出し、続いて`select()`関数で抽出する列を指定します。むろん、今回の場合、`filter()`と`select()`の順番は替えても構いません。

```{r handling1-filter-12}
# dfからPrefが"京都府"であるケースのみ残し、df2という名で保存
df2 <- df %>%
  filter(Pref == "京都府")

# df2からName, Station, Score列を抽出
df2 %>%
  select(Name, Station, Score)
```

これは`df`から`Pref == "京都府"`のケースのみ残したものを`df2`として格納し、それをまた`select()`関数を使って列を抽出するコードです。これでも問題ありませんが、これだとパイプ演算子の便利さが分かりません。パイプ演算子は複数使うことが可能です。

```{r handling1-filter-13}
df %>%
  filter(Pref == "京都府") %>%
  select(Name, Station, Score)
```

全く同じ結果ですが、無駄に`df2`というデータフレームを作らず済むので、メモリの観点からも嬉しいですし、何よりコードが短く、しかも可読性も上がりました。

今回は`==`を使って**合致する**ものに絞りましたが、`!=`を使って**合致しない**ものに絞ることも可能です。または、比較演算子 (`<`、`>`、`>=`、`<=`など)を使うことも可能です。それでは、組み込み数 (`ScoreN`)が*0ではない*ケースを取り出し、`Name`、`Station`、`ScoreN`、`Score`列を出力させてみましょう。

```{r handling1-filter-14}
df %>%
  filter(ScoreN != 0) %>%
  select(Name, Station, starts_with("Score"))
```

これで口コミ数が1以上の店舗のみに絞ることができました。ただし、店によっては口コミはあっても、評価 (`Score`)が付いていないところもあります。たとえば、「刀削麺・火鍋・西安料理 XI'AN（シーアン） 後楽園店」の場合、口コミはありますが、評価はありません。したがって、今回は評価が付いている店舗に絞ってみましょう。

```{r handling1-filter-15}
df %>%
  filter(Score != NA) %>%
  select(Name, Station, starts_with("Score"))
```

あらら、何の結果も表示されませんでした。これは`filter()`内の条件に合致するケースが存在しないことを意味します。しかし、先ほどの結果を見ても、評価が付いている店はいっぱいありましたね。これはなぜでしょう。

察しの良い読者さんは気づいているかと思いますが、第\@ref(type-na)章で説明した通り、`NA`か否かを判定する際は`==`や`!=`は使えません。`is.na()`を使います。`filter(is.na(Score))`なら「`Score`が`NA`**である**ケースに絞る」ことを意味しますが、今回は「`Score`が`NA`**でない**ケースに絞る」ことが目的ですので、`is.na()`の前に`!`を付けます。

```{r handling1-filter-16}
df %>%
  filter(!is.na(Score)) %>%
  select(Name, Station, starts_with("Score"))
```

これで口コミ評価が登録された店舗に絞ることができました。

続いて、複数の条件を持つケースを考えてみましょう。例えば、「京都府内の店舗で、口コミ評価が3.5以上の店舗」を出力したい場合、以下のようなコードとなります。

```{r handling1-filter-17}
df %>%
  filter(Pref == "京都府", Score >= 3.5) %>%
  select(Name, Station, ScoreN, Score)
```

条件を`filter()`内に追加するだけです。今回は`!is.na(Score)`は不要です。なぜなら、`Score >= 3.5`という条件で既に欠損値は対象外になるからです。条件文が複数ある場合、ANDかORかを指定する必要があります。つまり、条件文AとBがある場合、「AとB両方満たすものを出力する」か「AとBどちらかを満たすものを出力するか」を指定する必要があります。今の結果ってANDでしたよね。`filter()`関数は、別途の指定がない場合、全てAND扱いになります。RのAND演算子は`&`ですので、以上のコードは以下のコードと同じです。

```{r handling1-filter-18}
df %>%
  filter(Pref == "京都府" & Score >= 3.5) %>%
  select(Name, Station, ScoreN, Score)
```

AND演算子 (`&`)が使えるということはOR演算子 (`|`)も使えることを意味します。たとえば、`Station`が`"高田馬場駅"`か`"三田駅"`の条件を指定したい場合、

```{r handling1-filter-19}
df %>% 
  filter(Station == "高田馬場駅" | Station == "三田駅") %>%
  select(Name, Station, ScoreN, Score)
```

のように書きます（ちなみに高田馬場の「やまぐち」は本当に美味しいです）。むろん、複数の変数を用いたORも可能です。たとえば、「`Pref`が`"京都府"`か`Score`が3以上」のような条件も可能ですが (`Pref == "京都府" | Score >= 3`)、実際、このような例はあまりありません。よく使うのは「変数`X`が`a`か`b`か`c`か」のような例です。ただし、この場合は`|`を使わないもっと簡単な方法があります。それは第\@ref(programming-condition)章で紹介した`%in%`演算子です。以下のコードは上のコードと同じものです。

```{r handling1-filter-20}
df %>% 
  filter(Station %in% c("高田馬場駅", "三田駅")) %>%
  select(Name, Station, ScoreN, Score)
```

結局、`|`が使われるケースがかなり限定されます。あるとすれば、「変数`X`が`a`以下か、`b`以上か」のようなケースですね。ただし、`&`と`|`を同時に使うケースは考えられます。たとえば、大阪駅と京都駅周辺のうまいラーメン屋を調べるとします。問題は美味しさの基準ですが、3.5点以上としましょう。ただし、京都府民はラーメンに非常に厳しく、3点以上なら美味しいと仮定します。この場合、「(`Station`が`"大阪駅"`かつ`Score >= 3.5`)、または(`Station`が`"京都駅"`かつ`Score >= 3`)」のような条件が必要になります。`()`は「`()`の中から判定せよ」という、普通の算数での使い方と同じです。それでは、実際に検索してみましょう。

```{r handling1-filter-21}
df %>%
  filter((Station == "大阪駅" & Score >= 3.5) | (Station == "京都駅" & Score >= 3)) %>%
  select(Name, Station, Walk, ScoreN, Score)
```

Songが大好きな神座がヒットして嬉しいです。

---

## 行のソート {#handling1-arrange}

続いて、行のソートについて解説します。「食べログ」などのレビューサービスを利用する場合、口コミ評価が高い順で見るのが一般的でしょう[^tabelog]。また、サッカーのランキングも多くは1位から下の順位で掲載されるのが一般的です。ここではこのようにある変数の値順に行を並び替える方法について説明します。

[^tabelog]: サービスによってはこの機能が有料になっていたりもしますね。

ソートには{dplyr}パッケージの`arrange()`関数を使います。引数は変数名のみです。たとえば、奈良県のラーメン屋を検索してみましょう。並び替える順は駅から近い店舗を上位に、遠い店舗を下位に並べます。このような順は**昇順 (ascending)**と呼ばれ、ランキング表などでよく見ます。駅から近い順にソートするので、まず最寄りの駅情報が欠損でないことが必要です。また、ラーメン屋の評価も気になるので口コミが1つ以上付いている店舗に絞りましょう。表示する列は店舗名、最寄りの駅、徒歩距離、口コミ数、点数です。

```{r handling1-arrange-1}
df %>%
  filter(Pref == "奈良県", !is.na(Station), ScoreN > 0) %>%
  select(Name, Station, Walk, ScoreN, Score) %>%
  arrange(Walk) %>%
  print(n = Inf)
```

3行まではこれまで習ってきたもので、4行目がソートの関数、`arrange()`です。引数はソートの基準となる変数で、今回は最寄りの駅からの徒歩距離を表す`Walk`です。5行目は省略可能ですが、`tibble`クラスの場合、10行までしか出力されないので、`print(n = Inf)`で「すべての行を表示」させます。`n`を指定することで出力される行数が調整可能です。奈良県のラーメン屋の中で最寄りの駅から最も近い店は「[麺屋 あまのじゃく 本店](https://www.menya-amanojaku.com)」で徒歩2分でした。京田辺店も駅から約2分ですし、近いですね。ちなみにSongはここの塩とんこつが好きです。世界一こってりなラーメンとも言われる「チョモランマ」で有名な「[まりお流ラーメン](http://www.marioramen.com)」は新大宮駅から徒歩20分でかなり遠いことが分かります。

続いて、駅からの距離ではなく、評価が高い順にしてみましょう。評価が高いほど上に来るので、今回は昇順でなく、**降順 (descending)**でソートする必要があります。`arrange()`関数は基本的に、指定された変数を基準に昇順でソートします。降順にするためには`desc()`関数を更に用います。たとえば、`arrange(desc(変数名))`のようにです。それでは実際にやってみましょう。上のコードの4行目を`arange(Walk)`から`arrange(desc(Score))`にちょっと修正するだけです。

```{r handling1-arrange-2}
df %>%
  filter(Pref == "奈良県", !is.na(Station), ScoreN > 0) %>%
  select(Name, Station, Walk, ScoreN, Score) %>%
  arrange(desc(Score)) %>%
  print(n = Inf)
```

よく考えてみれば、「評価が同点の場合、どうなるの?」と疑問を抱く方がいるかも知れません。たとえば、7行目の「河童ラーメン本舗 押熊店」と8行目の「無鉄砲がむしゃら」はどれも評価が4点ですが、「河童ラーメン本舗 押熊店」が先に表示されます。そのこれは簡単です。同点の場合、データセット内で上に位置する行が先に表示されます。これを確認するには`which()`関数を使います。`()`内に条件文を指定することで、この条件に合致する要素の位置を返します。もし、条件に合致するものが複数あった場合は全ての位置を返します[^which]。

[^which]: たとえば、データ内に「ラーメンショップ」という店舗は3店舗あり、この場合、長さ3のベクトルが返されます。

```{r handling1-arrange-3}
which(df$Name == "河童ラーメン本舗 押熊店")
which(df$Name == "無鉄砲がむしゃら")
```

データ内に「河童ラーメン本舗 押熊店」がより上に位置することが分かります。「もし同点なら口コミ評価数が多いところにしたい」場合はどうすれば良いでしょうか。これは`arrange()`内に変数名を足すだけで十分です。

```{r handling1-arrange-4}
df %>%
  filter(Pref == "奈良県", !is.na(Station), ScoreN > 0) %>%
  select(Name, Station, Walk, ScoreN, Score) %>%
  arrange(desc(Score), desc(ScoreN)) %>%
  print(n = Inf)
```

ソートの基準は`arrange()`内において先に指定された変数の順番となります。「口コミ評価も評価数も同じなら、駅から近いところにしたい」場合は変数が3つとなり、`Score`、`ScoreN`、`Walk`の順で入れます。

```{r handling1-arrange-5}
df %>%
  filter(Pref == "奈良県", !is.na(Station), ScoreN > 0) %>%
  select(Name, Station, Walk, ScoreN, Score) %>%
  arrange(desc(Score), desc(ScoreN), Walk) %>%
  print(n = Inf)
```

---

## 練習問題 {#handling1-exercise .unnumbered}